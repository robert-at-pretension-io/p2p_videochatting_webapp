var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// .netlify/server/chunks/index-08869495.js
var require_index_08869495 = __commonJS({
  ".netlify/server/chunks/index-08869495.js"(exports2) {
    var __defProp2 = Object.defineProperty;
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    __export(exports2, {
      a: () => safe_not_equal,
      b: () => subscribe,
      c: () => create_ssr_component,
      d: () => add_attribute,
      e: () => escape2,
      m: () => missing_component,
      n: () => noop,
      s: () => setContext,
      v: () => validate_component
    });
    function noop() {
    }
    function run(fn) {
      return fn();
    }
    function blank_object() {
      return Object.create(null);
    }
    function run_all(fns) {
      fns.forEach(run);
    }
    function safe_not_equal(a, b) {
      return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
    }
    function subscribe(store, ...callbacks) {
      if (store == null) {
        return noop;
      }
      const unsub = store.subscribe(...callbacks);
      return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    var current_component;
    function set_current_component(component) {
      current_component = component;
    }
    function get_current_component() {
      if (!current_component)
        throw new Error("Function called outside component initialization");
      return current_component;
    }
    function setContext(key, context) {
      get_current_component().$$.context.set(key, context);
    }
    Promise.resolve();
    var boolean_attributes = new Set([
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ]);
    var escaped = {
      '"': "&quot;",
      "'": "&#39;",
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;"
    };
    function escape2(html) {
      return String(html).replace(/["'&<>]/g, (match) => escaped[match]);
    }
    var missing_component = {
      $$render: () => ""
    };
    function validate_component(component, name) {
      if (!component || !component.$$render) {
        if (name === "svelte:component")
          name += " this={...}";
        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
      }
      return component;
    }
    var on_destroy;
    function create_ssr_component(fn) {
      function $$render(result, props, bindings, slots, context) {
        const parent_component = current_component;
        const $$ = {
          on_destroy,
          context: new Map(context || (parent_component ? parent_component.$$.context : [])),
          on_mount: [],
          before_update: [],
          after_update: [],
          callbacks: blank_object()
        };
        set_current_component({ $$ });
        const html = fn(result, props, bindings, slots);
        set_current_component(parent_component);
        return html;
      }
      return {
        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
          on_destroy = [];
          const result = { title: "", head: "", css: new Set() };
          const html = $$render(result, props, {}, $$slots, context);
          run_all(on_destroy);
          return {
            html,
            css: {
              code: Array.from(result.css).map((css) => css.code).join("\n"),
              map: null
            },
            head: result.title + result.head
          };
        },
        $$render
      };
    }
    function add_attribute(name, value, boolean) {
      if (value == null || boolean && !value)
        return "";
      return ` ${name}${value === true && boolean_attributes.has(name) ? "" : `=${typeof value === "string" ? JSON.stringify(escape2(value)) : `"${value}"`}`}`;
    }
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports2) {
    "use strict";
    exports2.parse = parse;
    exports2.serialize = serialize;
    var decode = decodeURIComponent;
    var encode = encodeURIComponent;
    var pairSplitRegExp = /; */;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var pairs = str.split(pairSplitRegExp);
      var dec = opt.decode || decode;
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        var eq_idx = pair.indexOf("=");
        if (eq_idx < 0) {
          continue;
        }
        var key = pair.substr(0, eq_idx).trim();
        var val = pair.substr(++eq_idx, pair.length).trim();
        if (val[0] == '"') {
          val = val.slice(1, -1);
        }
        if (obj[key] == void 0) {
          obj[key] = tryDecode(val, dec);
        }
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (opt.maxAge != null) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== "function") {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e) {
        return str;
      }
    }
  }
});

// .netlify/server/app.js
var require_app = __commonJS({
  ".netlify/server/app.js"(exports2) {
    var __create = Object.create;
    var __defProp2 = Object.defineProperty;
    var __defProps2 = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
    var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues2 = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp2.call(b, prop))
          __defNormalProp2(a, prop, b[prop]);
      if (__getOwnPropSymbols2)
        for (var prop of __getOwnPropSymbols2(b)) {
          if (__propIsEnum2.call(b, prop))
            __defNormalProp2(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __reExport = (target, module22, desc) => {
      if (module22 && typeof module22 === "object" || typeof module22 === "function") {
        for (let key of __getOwnPropNames(module22))
          if (!__hasOwnProp2.call(target, key) && key !== "default")
            __defProp2(target, key, { get: () => module22[key], enumerable: !(desc = __getOwnPropDesc(module22, key)) || desc.enumerable });
      }
      return target;
    };
    var __toModule = (module22) => {
      return __reExport(__markAsModule(__defProp2(module22 != null ? __create(__getProtoOf(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? { get: () => module22.default, enumerable: true } : { value: module22, enumerable: true })), module22);
    };
    __export(exports2, {
      App: () => App,
      override: () => override
    });
    var import_index_08869495 = __toModule(require_index_08869495());
    var import_cookie = __toModule(require_cookie());
    var __accessCheck2 = (obj, member, msg) => {
      if (!member.has(obj))
        throw TypeError("Cannot " + msg);
    };
    var __privateGet2 = (obj, member, getter) => {
      __accessCheck2(obj, member, "read from private field");
      return getter ? getter.call(obj) : member.get(obj);
    };
    var __privateAdd2 = (obj, member, value) => {
      if (member.has(obj))
        throw TypeError("Cannot add the same private member more than once");
      member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    };
    var __privateSet2 = (obj, member, value, setter) => {
      __accessCheck2(obj, member, "write to private field");
      setter ? setter.call(obj, value) : member.set(obj, value);
      return value;
    };
    var _map;
    function get_single_valued_header(headers, key) {
      const value = headers[key];
      if (Array.isArray(value)) {
        if (value.length === 0) {
          return void 0;
        }
        if (value.length > 1) {
          throw new Error(`Multiple headers provided for ${key}. Multiple may be provided only for set-cookie`);
        }
        return value[0];
      }
      return value;
    }
    function lowercase_keys(obj) {
      const clone = {};
      for (const key in obj) {
        clone[key.toLowerCase()] = obj[key];
      }
      return clone;
    }
    function decode_params(params) {
      for (const key in params) {
        params[key] = params[key].replace(/%23/g, "#").replace(/%3[Bb]/g, ";").replace(/%2[Cc]/g, ",").replace(/%2[Ff]/g, "/").replace(/%3[Ff]/g, "?").replace(/%3[Aa]/g, ":").replace(/%40/g, "@").replace(/%26/g, "&").replace(/%3[Dd]/g, "=").replace(/%2[Bb]/g, "+").replace(/%24/g, "$");
      }
      return params;
    }
    function error(body) {
      return {
        status: 500,
        body,
        headers: {}
      };
    }
    function is_string(s2) {
      return typeof s2 === "string" || s2 instanceof String;
    }
    var text_types = new Set([
      "application/xml",
      "application/json",
      "application/x-www-form-urlencoded",
      "multipart/form-data"
    ]);
    function is_text(content_type) {
      if (!content_type)
        return true;
      const type = content_type.split(";")[0].toLowerCase();
      return type.startsWith("text/") || type.endsWith("+xml") || text_types.has(type);
    }
    async function render_endpoint(request, route, match) {
      const mod = await route.load();
      const handler = mod[request.method.toLowerCase().replace("delete", "del")];
      if (!handler) {
        return;
      }
      request.params = route.params ? decode_params(route.params(match)) : {};
      const response = await handler(request);
      const preface = `Invalid response from route ${request.url.pathname}`;
      if (!response) {
        return;
      }
      if (typeof response !== "object") {
        return error(`${preface}: expected an object, got ${typeof response}`);
      }
      let { status = 200, body, headers = {} } = response;
      headers = lowercase_keys(headers);
      const type = get_single_valued_header(headers, "content-type");
      if (!is_text(type) && !(body instanceof Uint8Array || is_string(body))) {
        return error(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
      }
      let normalized_body;
      if ((typeof body === "object" || typeof body === "undefined") && !(body instanceof Uint8Array) && (!type || type.startsWith("application/json"))) {
        headers = __spreadProps2(__spreadValues2({}, headers), { "content-type": "application/json; charset=utf-8" });
        normalized_body = JSON.stringify(typeof body === "undefined" ? {} : body);
      } else {
        normalized_body = body;
      }
      return { status, body: normalized_body, headers };
    }
    var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
    var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
    var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
    var escaped = {
      "<": "\\u003C",
      ">": "\\u003E",
      "/": "\\u002F",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
    function devalue(value) {
      var counts = new Map();
      function walk(thing) {
        if (typeof thing === "function") {
          throw new Error("Cannot stringify a function");
        }
        if (counts.has(thing)) {
          counts.set(thing, counts.get(thing) + 1);
          return;
        }
        counts.set(thing, 1);
        if (!isPrimitive(thing)) {
          var type = getType(thing);
          switch (type) {
            case "Number":
            case "String":
            case "Boolean":
            case "Date":
            case "RegExp":
              return;
            case "Array":
              thing.forEach(walk);
              break;
            case "Set":
            case "Map":
              Array.from(thing).forEach(walk);
              break;
            default:
              var proto = Object.getPrototypeOf(thing);
              if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
                throw new Error("Cannot stringify arbitrary non-POJOs");
              }
              if (Object.getOwnPropertySymbols(thing).length > 0) {
                throw new Error("Cannot stringify POJOs with symbolic keys");
              }
              Object.keys(thing).forEach(function(key) {
                return walk(thing[key]);
              });
          }
        }
      }
      walk(value);
      var names = new Map();
      Array.from(counts).filter(function(entry) {
        return entry[1] > 1;
      }).sort(function(a, b) {
        return b[1] - a[1];
      }).forEach(function(entry, i) {
        names.set(entry[0], getName(i));
      });
      function stringify(thing) {
        if (names.has(thing)) {
          return names.get(thing);
        }
        if (isPrimitive(thing)) {
          return stringifyPrimitive(thing);
        }
        var type = getType(thing);
        switch (type) {
          case "Number":
          case "String":
          case "Boolean":
            return "Object(" + stringify(thing.valueOf()) + ")";
          case "RegExp":
            return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
          case "Date":
            return "new Date(" + thing.getTime() + ")";
          case "Array":
            var members = thing.map(function(v, i) {
              return i in thing ? stringify(v) : "";
            });
            var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
            return "[" + members.join(",") + tail + "]";
          case "Set":
          case "Map":
            return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
          default:
            var obj = "{" + Object.keys(thing).map(function(key) {
              return safeKey(key) + ":" + stringify(thing[key]);
            }).join(",") + "}";
            var proto = Object.getPrototypeOf(thing);
            if (proto === null) {
              return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
            }
            return obj;
        }
      }
      var str = stringify(value);
      if (names.size) {
        var params_1 = [];
        var statements_1 = [];
        var values_1 = [];
        names.forEach(function(name, thing) {
          params_1.push(name);
          if (isPrimitive(thing)) {
            values_1.push(stringifyPrimitive(thing));
            return;
          }
          var type = getType(thing);
          switch (type) {
            case "Number":
            case "String":
            case "Boolean":
              values_1.push("Object(" + stringify(thing.valueOf()) + ")");
              break;
            case "RegExp":
              values_1.push(thing.toString());
              break;
            case "Date":
              values_1.push("new Date(" + thing.getTime() + ")");
              break;
            case "Array":
              values_1.push("Array(" + thing.length + ")");
              thing.forEach(function(v, i) {
                statements_1.push(name + "[" + i + "]=" + stringify(v));
              });
              break;
            case "Set":
              values_1.push("new Set");
              statements_1.push(name + "." + Array.from(thing).map(function(v) {
                return "add(" + stringify(v) + ")";
              }).join("."));
              break;
            case "Map":
              values_1.push("new Map");
              statements_1.push(name + "." + Array.from(thing).map(function(_a) {
                var k = _a[0], v = _a[1];
                return "set(" + stringify(k) + ", " + stringify(v) + ")";
              }).join("."));
              break;
            default:
              values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
              Object.keys(thing).forEach(function(key) {
                statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
              });
          }
        });
        statements_1.push("return " + str);
        return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
      } else {
        return str;
      }
    }
    function getName(num) {
      var name = "";
      do {
        name = chars[num % chars.length] + name;
        num = ~~(num / chars.length) - 1;
      } while (num >= 0);
      return reserved.test(name) ? name + "_" : name;
    }
    function isPrimitive(thing) {
      return Object(thing) !== thing;
    }
    function stringifyPrimitive(thing) {
      if (typeof thing === "string")
        return stringifyString(thing);
      if (thing === void 0)
        return "void 0";
      if (thing === 0 && 1 / thing < 0)
        return "-0";
      var str = String(thing);
      if (typeof thing === "number")
        return str.replace(/^(-)?0\./, "$1.");
      return str;
    }
    function getType(thing) {
      return Object.prototype.toString.call(thing).slice(8, -1);
    }
    function escapeUnsafeChar(c) {
      return escaped[c] || c;
    }
    function escapeUnsafeChars(str) {
      return str.replace(unsafeChars, escapeUnsafeChar);
    }
    function safeKey(key) {
      return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
    }
    function safeProp(key) {
      return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
    }
    function stringifyString(str) {
      var result = '"';
      for (var i = 0; i < str.length; i += 1) {
        var char = str.charAt(i);
        var code = char.charCodeAt(0);
        if (char === '"') {
          result += '\\"';
        } else if (char in escaped) {
          result += escaped[char];
        } else if (code >= 55296 && code <= 57343) {
          var next = str.charCodeAt(i + 1);
          if (code <= 56319 && (next >= 56320 && next <= 57343)) {
            result += char + str[++i];
          } else {
            result += "\\u" + code.toString(16).toUpperCase();
          }
        } else {
          result += char;
        }
      }
      result += '"';
      return result;
    }
    function noop() {
    }
    function safe_not_equal(a, b) {
      return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
    }
    Promise.resolve();
    var subscriber_queue = [];
    function writable(value, start = noop) {
      let stop;
      const subscribers = new Set();
      function set(new_value) {
        if (safe_not_equal(value, new_value)) {
          value = new_value;
          if (stop) {
            const run_queue = !subscriber_queue.length;
            for (const subscriber of subscribers) {
              subscriber[1]();
              subscriber_queue.push(subscriber, value);
            }
            if (run_queue) {
              for (let i = 0; i < subscriber_queue.length; i += 2) {
                subscriber_queue[i][0](subscriber_queue[i + 1]);
              }
              subscriber_queue.length = 0;
            }
          }
        }
      }
      function update(fn) {
        set(fn(value));
      }
      function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
          stop = start(set) || noop;
        }
        run(value);
        return () => {
          subscribers.delete(subscriber);
          if (subscribers.size === 0) {
            stop();
            stop = null;
          }
        };
      }
      return { set, update, subscribe };
    }
    function coalesce_to_error(err) {
      return err instanceof Error || err && err.name && err.message ? err : new Error(JSON.stringify(err));
    }
    function hash(value) {
      let hash2 = 5381;
      let i = value.length;
      if (typeof value === "string") {
        while (i)
          hash2 = hash2 * 33 ^ value.charCodeAt(--i);
      } else {
        while (i)
          hash2 = hash2 * 33 ^ value[--i];
      }
      return (hash2 >>> 0).toString(36);
    }
    var escape_json_string_in_html_dict = {
      '"': '\\"',
      "<": "\\u003C",
      ">": "\\u003E",
      "/": "\\u002F",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    function escape_json_string_in_html(str) {
      return escape2(str, escape_json_string_in_html_dict, (code) => `\\u${code.toString(16).toUpperCase()}`);
    }
    var escape_html_attr_dict = {
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function escape_html_attr(str) {
      return '"' + escape2(str, escape_html_attr_dict, (code) => `&#${code};`) + '"';
    }
    function escape2(str, dict, unicode_encoder) {
      let result = "";
      for (let i = 0; i < str.length; i += 1) {
        const char = str.charAt(i);
        const code = char.charCodeAt(0);
        if (char in dict) {
          result += dict[char];
        } else if (code >= 55296 && code <= 57343) {
          const next = str.charCodeAt(i + 1);
          if (code <= 56319 && next >= 56320 && next <= 57343) {
            result += char + str[++i];
          } else {
            result += unicode_encoder(code);
          }
        } else {
          result += char;
        }
      }
      return result;
    }
    var s = JSON.stringify;
    async function render_response({
      branch,
      options,
      $session,
      page_config,
      status,
      error: error2,
      url,
      params
    }) {
      const css2 = new Set(options.manifest._.entry.css);
      const js = new Set(options.manifest._.entry.js);
      const styles = new Set();
      const serialized_data = [];
      let rendered;
      let is_private = false;
      let maxage;
      if (error2) {
        error2.stack = options.get_stack(error2);
      }
      if (page_config.ssr) {
        branch.forEach(({ node, loaded, fetched, uses_credentials }) => {
          if (node.css)
            node.css.forEach((url2) => css2.add(url2));
          if (node.js)
            node.js.forEach((url2) => js.add(url2));
          if (node.styles)
            node.styles.forEach((content) => styles.add(content));
          if (fetched && page_config.hydrate)
            serialized_data.push(...fetched);
          if (uses_credentials)
            is_private = true;
          maxage = loaded.maxage;
        });
        const session = writable($session);
        const props = {
          stores: {
            page: writable(null),
            navigating: writable(null),
            session
          },
          page: { url, params, status, error: error2 },
          components: branch.map(({ node }) => node.module.default)
        };
        const print_error = (property, replacement) => {
          Object.defineProperty(props.page, property, {
            get: () => {
              throw new Error(`$page.${property} has been replaced by $page.url.${replacement}`);
            }
          });
        };
        print_error("origin", "origin");
        print_error("path", "pathname");
        print_error("query", "searchParams");
        for (let i = 0; i < branch.length; i += 1) {
          props[`props_${i}`] = await branch[i].loaded.props;
        }
        let session_tracking_active = false;
        const unsubscribe = session.subscribe(() => {
          if (session_tracking_active)
            is_private = true;
        });
        session_tracking_active = true;
        try {
          rendered = options.root.render(props);
        } finally {
          unsubscribe();
        }
      } else {
        rendered = { head: "", html: "", css: { code: "", map: null } };
      }
      const include_js = page_config.router || page_config.hydrate;
      if (!include_js)
        js.clear();
      const links = options.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
        ...Array.from(css2).map((dep) => `<link rel="stylesheet" href="${options.prefix}${dep}">`),
        ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${options.prefix}${dep}">`)
      ].join("\n		");
      let init2 = "";
      if (options.amp) {
        init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>`;
        init2 += options.service_worker ? '<script async custom-element="amp-install-serviceworker" src="https://cdn.ampproject.org/v0/amp-install-serviceworker-0.1.js"><\/script>' : "";
      } else if (include_js) {
        init2 = `<script type="module">
			import { start } from ${s(options.prefix + options.manifest._.entry.file)};
			start({
				target: ${options.target ? `document.querySelector(${s(options.target)})` : "document.body"},
				paths: ${s(options.paths)},
				session: ${try_serialize($session, (error3) => {
          throw new Error(`Failed to serialize session data: ${error3.message}`);
        })},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s(options.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error2)},
					nodes: [
						${(branch || []).map(({ node }) => `import(${s(options.prefix + node.entry)})`).join(",\n						")}
					],
					url: new URL(${s(url.href)}),
					params: ${devalue(params)}
				}` : "null"}
			});
		<\/script>`;
      }
      if (options.service_worker && !options.amp) {
        init2 += `<script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('${options.service_worker}');
			}
		<\/script>`;
      }
      const head = [
        rendered.head,
        styles.size && !options.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
        links,
        init2
      ].join("\n\n		");
      let body = rendered.html;
      if (options.amp) {
        if (options.service_worker) {
          body += `<amp-install-serviceworker src="${options.service_worker}" layout="nodisplay"></amp-install-serviceworker>`;
        }
      } else {
        body += serialized_data.map(({ url: url2, body: body2, json }) => {
          let attributes = `type="application/json" data-type="svelte-data" data-url=${escape_html_attr(url2)}`;
          if (body2)
            attributes += ` data-body="${hash(body2)}"`;
          return `<script ${attributes}>${json}<\/script>`;
        }).join("\n\n	");
      }
      const headers = {
        "content-type": "text/html"
      };
      if (maxage) {
        headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
      }
      if (!options.floc) {
        headers["permissions-policy"] = "interest-cohort=()";
      }
      const segments = url.pathname.slice(options.paths.base.length).split("/").slice(2);
      const assets2 = options.paths.assets || (segments.length > 0 ? segments.map(() => "..").join("/") : ".");
      return {
        status,
        headers,
        body: options.template({
          head,
          body,
          assets: assets2
        })
      };
    }
    function try_serialize(data, fail) {
      try {
        return devalue(data);
      } catch (err) {
        if (fail)
          fail(coalesce_to_error(err));
        return null;
      }
    }
    function serialize_error(error2) {
      if (!error2)
        return null;
      let serialized = try_serialize(error2);
      if (!serialized) {
        const { name, message, stack } = error2;
        serialized = try_serialize(__spreadProps2(__spreadValues2({}, error2), { name, message, stack }));
      }
      if (!serialized) {
        serialized = "{}";
      }
      return serialized;
    }
    function normalize(loaded) {
      const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
      if (loaded.error || has_error_status) {
        const status = loaded.status;
        if (!loaded.error && has_error_status) {
          return {
            status: status || 500,
            error: new Error()
          };
        }
        const error2 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
        if (!(error2 instanceof Error)) {
          return {
            status: 500,
            error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`)
          };
        }
        if (!status || status < 400 || status > 599) {
          console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
          return { status: 500, error: error2 };
        }
        return { status, error: error2 };
      }
      if (loaded.redirect) {
        if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
          return {
            status: 500,
            error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
          };
        }
        if (typeof loaded.redirect !== "string") {
          return {
            status: 500,
            error: new Error('"redirect" property returned from load() must be a string')
          };
        }
      }
      if (loaded.context) {
        throw new Error('You are returning "context" from a load function. "context" was renamed to "stuff", please adjust your code accordingly.');
      }
      return loaded;
    }
    var absolute = /^([a-z]+:)?\/?\//;
    var scheme = /^[a-z]+:/;
    function resolve(base2, path) {
      if (scheme.test(path))
        return path;
      const base_match = absolute.exec(base2);
      const path_match = absolute.exec(path);
      if (!base_match) {
        throw new Error(`bad base path: "${base2}"`);
      }
      const baseparts = path_match ? [] : base2.slice(base_match[0].length).split("/");
      const pathparts = path_match ? path.slice(path_match[0].length).split("/") : path.split("/");
      baseparts.pop();
      for (let i = 0; i < pathparts.length; i += 1) {
        const part = pathparts[i];
        if (part === ".")
          continue;
        else if (part === "..")
          baseparts.pop();
        else
          baseparts.push(part);
      }
      const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
      return `${prefix}${baseparts.join("/")}`;
    }
    function is_root_relative(path) {
      return path[0] === "/" && path[1] !== "/";
    }
    async function load_node({
      request,
      options,
      state,
      route,
      url,
      params,
      node,
      $session,
      stuff,
      prerender_enabled,
      is_leaf,
      is_error,
      status,
      error: error2
    }) {
      const { module: module22 } = node;
      let uses_credentials = false;
      const fetched = [];
      let set_cookie_headers = [];
      let loaded;
      const url_proxy = new Proxy(url, {
        get: (target, prop, receiver) => {
          if (prerender_enabled && (prop === "search" || prop === "searchParams")) {
            throw new Error("Cannot access query on a page with prerendering enabled");
          }
          return Reflect.get(target, prop, receiver);
        }
      });
      if (module22.load) {
        const load_input = {
          url: url_proxy,
          params,
          get session() {
            uses_credentials = true;
            return $session;
          },
          fetch: async (resource, opts = {}) => {
            let requested;
            if (typeof resource === "string") {
              requested = resource;
            } else {
              requested = resource.url;
              opts = __spreadValues2({
                method: resource.method,
                headers: resource.headers,
                body: resource.body,
                mode: resource.mode,
                credentials: resource.credentials,
                cache: resource.cache,
                redirect: resource.redirect,
                referrer: resource.referrer,
                integrity: resource.integrity
              }, opts);
            }
            opts.headers = new Headers(opts.headers);
            const resolved = resolve(request.url.pathname, requested.split("?")[0]);
            let response;
            const prefix = options.paths.assets || options.paths.base;
            const filename = (resolved.startsWith(prefix) ? resolved.slice(prefix.length) : resolved).slice(1);
            const filename_html = `${filename}/index.html`;
            const is_asset = options.manifest.assets.has(filename);
            const is_asset_html = options.manifest.assets.has(filename_html);
            if (is_asset || is_asset_html) {
              const file = is_asset ? filename : filename_html;
              if (options.read) {
                const type = is_asset ? options.manifest._.mime[filename.slice(filename.lastIndexOf("."))] : "text/html";
                response = new Response(options.read(file), {
                  headers: type ? { "content-type": type } : {}
                });
              } else {
                response = await fetch(`${url.origin}/${file}`, opts);
              }
            } else if (is_root_relative(resolved)) {
              const relative = resolved;
              if (opts.credentials !== "omit") {
                uses_credentials = true;
                if (request.headers.cookie) {
                  opts.headers.set("cookie", request.headers.cookie);
                }
                if (request.headers.authorization && !opts.headers.has("authorization")) {
                  opts.headers.set("authorization", request.headers.authorization);
                }
              }
              if (opts.body && typeof opts.body !== "string") {
                throw new Error("Request body must be a string");
              }
              const rendered = await respond({
                url: new URL(requested, request.url),
                method: opts.method || "GET",
                headers: Object.fromEntries(opts.headers),
                rawBody: opts.body == null ? null : new TextEncoder().encode(opts.body)
              }, options, {
                fetched: requested,
                initiator: route
              });
              if (rendered) {
                if (state.prerender) {
                  state.prerender.dependencies.set(relative, rendered);
                }
                response = new Response(rendered.body, {
                  status: rendered.status,
                  headers: rendered.headers
                });
              } else {
                return fetch(new URL(requested, request.url).href, {
                  method: opts.method || "GET",
                  headers: opts.headers
                });
              }
            } else {
              if (resolved.startsWith("//")) {
                throw new Error(`Cannot request protocol-relative URL (${requested}) in server-side fetch`);
              }
              if (`.${new URL(requested).hostname}`.endsWith(`.${request.url.hostname}`) && opts.credentials !== "omit") {
                uses_credentials = true;
                opts.headers.set("cookie", request.headers.cookie);
              }
              const external_request = new Request(requested, opts);
              response = await options.hooks.externalFetch.call(null, external_request);
            }
            if (response) {
              const proxy = new Proxy(response, {
                get(response2, key, _receiver) {
                  async function text() {
                    const body = await response2.text();
                    const headers = {};
                    for (const [key2, value] of response2.headers) {
                      if (key2 === "set-cookie") {
                        set_cookie_headers = set_cookie_headers.concat(value);
                      } else if (key2 !== "etag") {
                        headers[key2] = value;
                      }
                    }
                    if (!opts.body || typeof opts.body === "string") {
                      fetched.push({
                        url: requested,
                        body: opts.body,
                        json: `{"status":${response2.status},"statusText":${s(response2.statusText)},"headers":${s(headers)},"body":"${escape_json_string_in_html(body)}"}`
                      });
                    }
                    return body;
                  }
                  if (key === "text") {
                    return text;
                  }
                  if (key === "json") {
                    return async () => {
                      return JSON.parse(await text());
                    };
                  }
                  return Reflect.get(response2, key, response2);
                }
              });
              return proxy;
            }
            return response || new Response("Not found", {
              status: 404
            });
          },
          stuff: __spreadValues2({}, stuff)
        };
        if (options.dev) {
          Object.defineProperty(load_input, "page", {
            get: () => {
              throw new Error("`page` in `load` functions has been replaced by `url` and `params`");
            }
          });
        }
        if (is_error) {
          load_input.status = status;
          load_input.error = error2;
        }
        loaded = await module22.load.call(null, load_input);
      } else {
        loaded = {};
      }
      if (!loaded && is_leaf && !is_error)
        return;
      if (!loaded) {
        throw new Error(`${node.entry} - load must return a value except for page fall through`);
      }
      return {
        node,
        loaded: normalize(loaded),
        stuff: loaded.stuff || stuff,
        fetched,
        set_cookie_headers,
        uses_credentials
      };
    }
    async function respond_with_error({ request, options, state, $session, status, error: error2 }) {
      const default_layout = await options.manifest._.nodes[0]();
      const default_error = await options.manifest._.nodes[1]();
      const params = {};
      const loaded = await load_node({
        request,
        options,
        state,
        route: null,
        url: request.url,
        params,
        node: default_layout,
        $session,
        stuff: {},
        prerender_enabled: is_prerender_enabled(options, default_error, state),
        is_leaf: false,
        is_error: false
      });
      const branch = [
        loaded,
        await load_node({
          request,
          options,
          state,
          route: null,
          url: request.url,
          params,
          node: default_error,
          $session,
          stuff: loaded ? loaded.stuff : {},
          prerender_enabled: is_prerender_enabled(options, default_error, state),
          is_leaf: false,
          is_error: true,
          status,
          error: error2
        })
      ];
      try {
        return await render_response({
          options,
          $session,
          page_config: {
            hydrate: options.hydrate,
            router: options.router,
            ssr: options.ssr
          },
          status,
          error: error2,
          branch,
          url: request.url,
          params
        });
      } catch (err) {
        const error3 = coalesce_to_error(err);
        options.handle_error(error3, request);
        return {
          status: 500,
          headers: {},
          body: error3.stack
        };
      }
    }
    function is_prerender_enabled(options, node, state) {
      return options.prerender && (!!node.module.prerender || !!state.prerender && state.prerender.all);
    }
    async function respond$1(opts) {
      const { request, options, state, $session, route } = opts;
      let nodes;
      try {
        nodes = await Promise.all(route.a.map((n) => options.manifest._.nodes[n] && options.manifest._.nodes[n]()));
      } catch (err) {
        const error3 = coalesce_to_error(err);
        options.handle_error(error3, request);
        return await respond_with_error({
          request,
          options,
          state,
          $session,
          status: 500,
          error: error3
        });
      }
      const leaf = nodes[nodes.length - 1].module;
      let page_config = get_page_config(leaf, options);
      if (!leaf.prerender && state.prerender && !state.prerender.all) {
        return {
          status: 204,
          headers: {}
        };
      }
      let branch = [];
      let status = 200;
      let error2;
      let set_cookie_headers = [];
      ssr:
        if (page_config.ssr) {
          let stuff = {};
          for (let i = 0; i < nodes.length; i += 1) {
            const node = nodes[i];
            let loaded;
            if (node) {
              try {
                loaded = await load_node(__spreadProps2(__spreadValues2({}, opts), {
                  url: request.url,
                  node,
                  stuff,
                  prerender_enabled: is_prerender_enabled(options, node, state),
                  is_leaf: i === nodes.length - 1,
                  is_error: false
                }));
                if (!loaded)
                  return;
                set_cookie_headers = set_cookie_headers.concat(loaded.set_cookie_headers);
                if (loaded.loaded.redirect) {
                  return with_cookies({
                    status: loaded.loaded.status,
                    headers: {
                      location: encodeURI(loaded.loaded.redirect)
                    }
                  }, set_cookie_headers);
                }
                if (loaded.loaded.error) {
                  ({ status, error: error2 } = loaded.loaded);
                }
              } catch (err) {
                const e = coalesce_to_error(err);
                options.handle_error(e, request);
                status = 500;
                error2 = e;
              }
              if (loaded && !error2) {
                branch.push(loaded);
              }
              if (error2) {
                while (i--) {
                  if (route.b[i]) {
                    const error_node = await options.manifest._.nodes[route.b[i]]();
                    let node_loaded;
                    let j = i;
                    while (!(node_loaded = branch[j])) {
                      j -= 1;
                    }
                    try {
                      const error_loaded = await load_node(__spreadProps2(__spreadValues2({}, opts), {
                        url: request.url,
                        node: error_node,
                        stuff: node_loaded.stuff,
                        prerender_enabled: is_prerender_enabled(options, error_node, state),
                        is_leaf: false,
                        is_error: true,
                        status,
                        error: error2
                      }));
                      if (error_loaded.loaded.error) {
                        continue;
                      }
                      page_config = get_page_config(error_node.module, options);
                      branch = branch.slice(0, j + 1).concat(error_loaded);
                      break ssr;
                    } catch (err) {
                      const e = coalesce_to_error(err);
                      options.handle_error(e, request);
                      continue;
                    }
                  }
                }
                return with_cookies(await respond_with_error({
                  request,
                  options,
                  state,
                  $session,
                  status,
                  error: error2
                }), set_cookie_headers);
              }
            }
            if (loaded && loaded.loaded.stuff) {
              stuff = __spreadValues2(__spreadValues2({}, stuff), loaded.loaded.stuff);
            }
          }
        }
      try {
        return with_cookies(await render_response(__spreadProps2(__spreadValues2({}, opts), {
          url: request.url,
          page_config,
          status,
          error: error2,
          branch: branch.filter(Boolean)
        })), set_cookie_headers);
      } catch (err) {
        const error3 = coalesce_to_error(err);
        options.handle_error(error3, request);
        return with_cookies(await respond_with_error(__spreadProps2(__spreadValues2({}, opts), {
          status: 500,
          error: error3
        })), set_cookie_headers);
      }
    }
    function get_page_config(leaf, options) {
      return {
        ssr: "ssr" in leaf ? !!leaf.ssr : options.ssr,
        router: "router" in leaf ? !!leaf.router : options.router,
        hydrate: "hydrate" in leaf ? !!leaf.hydrate : options.hydrate
      };
    }
    function with_cookies(response, set_cookie_headers) {
      if (set_cookie_headers.length) {
        response.headers["set-cookie"] = set_cookie_headers;
      }
      return response;
    }
    async function render_page(request, route, match, options, state) {
      if (state.initiator === route) {
        return {
          status: 404,
          headers: {},
          body: `Not found: ${request.url.pathname}`
        };
      }
      const params = route.params ? decode_params(route.params(match)) : {};
      const $session = await options.hooks.getSession(request);
      const response = await respond$1({
        request,
        options,
        state,
        $session,
        route,
        params
      });
      if (response) {
        return response;
      }
      if (state.fetched) {
        return {
          status: 500,
          headers: {},
          body: `Bad request in load function: failed to fetch ${state.fetched}`
        };
      }
    }
    function read_only_form_data() {
      const map = new Map();
      return {
        append(key, value) {
          if (map.has(key)) {
            (map.get(key) || []).push(value);
          } else {
            map.set(key, [value]);
          }
        },
        data: new ReadOnlyFormData(map)
      };
    }
    var ReadOnlyFormData = class {
      constructor(map) {
        __privateAdd2(this, _map, void 0);
        __privateSet2(this, _map, map);
      }
      get(key) {
        const value = __privateGet2(this, _map).get(key);
        return value && value[0];
      }
      getAll(key) {
        return __privateGet2(this, _map).get(key);
      }
      has(key) {
        return __privateGet2(this, _map).has(key);
      }
      *[Symbol.iterator]() {
        for (const [key, value] of __privateGet2(this, _map)) {
          for (let i = 0; i < value.length; i += 1) {
            yield [key, value[i]];
          }
        }
      }
      *entries() {
        for (const [key, value] of __privateGet2(this, _map)) {
          for (let i = 0; i < value.length; i += 1) {
            yield [key, value[i]];
          }
        }
      }
      *keys() {
        for (const [key] of __privateGet2(this, _map))
          yield key;
      }
      *values() {
        for (const [, value] of __privateGet2(this, _map)) {
          for (let i = 0; i < value.length; i += 1) {
            yield value[i];
          }
        }
      }
    };
    _map = new WeakMap();
    function parse_body(raw, headers) {
      if (!raw)
        return raw;
      const content_type = headers["content-type"];
      const [type, ...directives] = content_type ? content_type.split(/;\s*/) : [];
      const text = () => new TextDecoder(headers["content-encoding"] || "utf-8").decode(raw);
      switch (type) {
        case "text/plain":
          return text();
        case "application/json":
          return JSON.parse(text());
        case "application/x-www-form-urlencoded":
          return get_urlencoded(text());
        case "multipart/form-data": {
          const boundary = directives.find((directive) => directive.startsWith("boundary="));
          if (!boundary)
            throw new Error("Missing boundary");
          return get_multipart(text(), boundary.slice("boundary=".length));
        }
        default:
          return raw;
      }
    }
    function get_urlencoded(text) {
      const { data, append } = read_only_form_data();
      text.replace(/\+/g, " ").split("&").forEach((str) => {
        const [key, value] = str.split("=");
        append(decodeURIComponent(key), decodeURIComponent(value));
      });
      return data;
    }
    function get_multipart(text, boundary) {
      const parts = text.split(`--${boundary}`);
      if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
        throw new Error("Malformed form data");
      }
      const { data, append } = read_only_form_data();
      parts.slice(1, -1).forEach((part) => {
        const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
        if (!match) {
          throw new Error("Malformed form data");
        }
        const raw_headers = match[1];
        const body = match[2].trim();
        let key;
        const headers = {};
        raw_headers.split("\r\n").forEach((str) => {
          const [raw_header, ...raw_directives] = str.split("; ");
          let [name, value] = raw_header.split(": ");
          name = name.toLowerCase();
          headers[name] = value;
          const directives = {};
          raw_directives.forEach((raw_directive) => {
            const [name2, value2] = raw_directive.split("=");
            directives[name2] = JSON.parse(value2);
          });
          if (name === "content-disposition") {
            if (value !== "form-data")
              throw new Error("Malformed form data");
            if (directives.filename) {
              throw new Error("File upload is not yet implemented");
            }
            if (directives.name) {
              key = directives.name;
            }
          }
        });
        if (!key)
          throw new Error("Malformed form data");
        append(key, body);
      });
      return data;
    }
    async function respond(incoming, options, state = {}) {
      if (incoming.url.pathname !== "/" && options.trailing_slash !== "ignore") {
        const has_trailing_slash = incoming.url.pathname.endsWith("/");
        if (has_trailing_slash && options.trailing_slash === "never" || !has_trailing_slash && options.trailing_slash === "always" && !(incoming.url.pathname.split("/").pop() || "").includes(".")) {
          incoming.url.pathname = has_trailing_slash ? incoming.url.pathname.slice(0, -1) : incoming.url.pathname + "/";
          if (incoming.url.search === "?")
            incoming.url.search = "";
          return {
            status: 301,
            headers: {
              location: incoming.url.pathname + incoming.url.search
            }
          };
        }
      }
      const headers = lowercase_keys(incoming.headers);
      const request = __spreadProps2(__spreadValues2({}, incoming), {
        headers,
        body: parse_body(incoming.rawBody, headers),
        params: {},
        locals: {}
      });
      const print_error = (property, replacement) => {
        Object.defineProperty(request, property, {
          get: () => {
            throw new Error(`request.${property} has been replaced by request.url.${replacement}`);
          }
        });
      };
      print_error("origin", "origin");
      print_error("path", "pathname");
      print_error("query", "searchParams");
      try {
        return await options.hooks.handle({
          request,
          resolve: async (request2) => {
            if (state.prerender && state.prerender.fallback) {
              return await render_response({
                url: request2.url,
                params: request2.params,
                options,
                $session: await options.hooks.getSession(request2),
                page_config: { ssr: false, router: true, hydrate: true },
                status: 200,
                branch: []
              });
            }
            const decoded = decodeURI(request2.url.pathname).replace(options.paths.base, "");
            for (const route of options.manifest._.routes) {
              const match = route.pattern.exec(decoded);
              if (!match)
                continue;
              const response = route.type === "endpoint" ? await render_endpoint(request2, route, match) : await render_page(request2, route, match, options, state);
              if (response) {
                if (response.status === 200) {
                  const cache_control = get_single_valued_header(response.headers, "cache-control");
                  if (!cache_control || !/(no-store|immutable)/.test(cache_control)) {
                    let if_none_match_value = request2.headers["if-none-match"];
                    if (if_none_match_value == null ? void 0 : if_none_match_value.startsWith('W/"')) {
                      if_none_match_value = if_none_match_value.substring(2);
                    }
                    const etag = `"${hash(response.body || "")}"`;
                    if (if_none_match_value === etag) {
                      return {
                        status: 304,
                        headers: {}
                      };
                    }
                    response.headers["etag"] = etag;
                  }
                }
                return response;
              }
            }
            if (!state.initiator) {
              const $session = await options.hooks.getSession(request2);
              return await respond_with_error({
                request: request2,
                options,
                state,
                $session,
                status: 404,
                error: new Error(`Not found: ${request2.url.pathname}`)
              });
            }
          }
        });
      } catch (err) {
        const e = coalesce_to_error(err);
        options.handle_error(e, request);
        return {
          status: 500,
          headers: {},
          body: options.dev ? e.stack : e.message
        };
      }
    }
    function afterUpdate() {
    }
    var css = {
      code: "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
      map: null
    };
    var Root = (0, import_index_08869495.c)(($$result, $$props, $$bindings, slots) => {
      let { stores } = $$props;
      let { page } = $$props;
      let { components } = $$props;
      let { props_0 = null } = $$props;
      let { props_1 = null } = $$props;
      let { props_2 = null } = $$props;
      (0, import_index_08869495.s)("__svelte__", stores);
      afterUpdate(stores.page.notify);
      if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
        $$bindings.stores(stores);
      if ($$props.page === void 0 && $$bindings.page && page !== void 0)
        $$bindings.page(page);
      if ($$props.components === void 0 && $$bindings.components && components !== void 0)
        $$bindings.components(components);
      if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
        $$bindings.props_0(props_0);
      if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
        $$bindings.props_1(props_1);
      if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
        $$bindings.props_2(props_2);
      $$result.css.add(css);
      {
        stores.page.set(page);
      }
      return `


${components[1] ? `${(0, import_index_08869495.v)(components[0] || import_index_08869495.m, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
        default: () => `${components[2] ? `${(0, import_index_08869495.v)(components[1] || import_index_08869495.m, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
          default: () => `${(0, import_index_08869495.v)(components[2] || import_index_08869495.m, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}`
        })}` : `${(0, import_index_08869495.v)(components[1] || import_index_08869495.m, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {})}`}`
      })}` : `${(0, import_index_08869495.v)(components[0] || import_index_08869495.m, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {})}`}

${``}`;
    });
    var base = "";
    var assets = "";
    function set_paths(paths) {
      base = paths.base;
      assets = paths.assets || base;
    }
    function set_prerendering(value) {
    }
    async function handle({ request, resolve: resolve2 }) {
      var cookies = import_cookie.default.parse(request.headers.cookie || "");
      if (request.url.pathname === "/logout") {
        console.log("attemtping to logout");
        cookies = {};
        request.locals = {};
      }
      console.log("cookies before resolve function: ", JSON.stringify(cookies, null, 2));
      try {
        request.locals = JSON.parse(cookies.data);
      } catch (e) {
        console.log("error parsing cookie user");
        request.locals = {};
      }
      console.log("before resolve function: " + JSON.stringify(request.locals, null, 2));
      const response = await resolve2(request);
      console.log("after resolve function: " + JSON.stringify(request.locals, null, 2));
      response.headers["set-cookie"] = `data=${JSON.stringify(request.locals) || ""}; Path=/; HttpOnly`;
      return response;
    }
    async function getSession(request) {
      console.log("getSession function: " + JSON.stringify(request, null, 2));
      return request.locals ? {
        data: request.locals
      } : { data: {} };
    }
    var user_hooks = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      [Symbol.toStringTag]: "Module",
      handle,
      getSession
    });
    var template = ({ head, body, assets: assets2 }) => '<!DOCTYPE html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<meta name="description" content="" />\n		<link rel="icon" href="' + assets2 + '/favicon.png" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		' + head + '\n	</head>\n	<body>\n		<div id="svelte">' + body + "</div>\n	</body>\n</html>\n";
    var read = null;
    set_paths({ "base": "", "assets": "" });
    var get_hooks = (hooks) => ({
      getSession: hooks.getSession || (() => ({})),
      handle: hooks.handle || (({ request, resolve: resolve2 }) => resolve2(request)),
      handleError: hooks.handleError || (({ error: error2 }) => console.error(error2.stack)),
      externalFetch: hooks.externalFetch || fetch
    });
    var default_protocol = "https";
    function override(settings) {
      default_protocol = settings.protocol || default_protocol;
      set_paths(settings.paths);
      set_prerendering(settings.prerendering);
      read = settings.read;
    }
    var App = class {
      constructor(manifest) {
        const hooks = get_hooks(user_hooks);
        this.options = {
          amp: false,
          dev: false,
          floc: false,
          get_stack: (error2) => String(error2),
          handle_error: (error2, request) => {
            hooks.handleError({ error: error2, request });
            error2.stack = this.options.get_stack(error2);
          },
          hooks,
          hydrate: true,
          manifest,
          paths: { base, assets },
          prefix: assets + "/_app/",
          prerender: true,
          read,
          root: Root,
          service_worker: null,
          router: true,
          ssr: true,
          target: "#svelte",
          template,
          trailing_slash: "never"
        };
      }
      render(request, {
        prerender
      } = {}) {
        if (Object.keys(request).sort().join() !== "headers,method,rawBody,url") {
          throw new Error("Adapters should call app.render({ url, method, headers, rawBody })");
        }
        const host = request.headers["host"];
        const protocol = default_protocol;
        return respond(__spreadProps2(__spreadValues2({}, request), { url: new URL(request.url, protocol + "://" + host) }), this.options, { prerender });
      }
    };
  }
});

// .netlify/multipart-parser-e24c3004.js
var require_multipart_parser_e24c3004 = __commonJS({
  ".netlify/multipart-parser-e24c3004.js"(exports2) {
    "use strict";
    require("fs");
    require("path");
    var node_worker_threads = require("worker_threads");
    var handler = require_handler_a3623ede();
    require("http");
    require("https");
    require("zlib");
    require("stream");
    require("util");
    require("url");
    require("net");
    require_app();
    globalThis.DOMException || (() => {
      const port = new node_worker_threads.MessageChannel().port1;
      const ab = new ArrayBuffer(0);
      try {
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        return err.constructor;
      }
    })();
    var s = 0;
    var S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    var f = 1;
    var F = {
      PART_BOUNDARY: f,
      LAST_BOUNDARY: f *= 2
    };
    var LF = 10;
    var CR = 13;
    var SPACE = 32;
    var HYPHEN = 45;
    var COLON = 58;
    var A = 97;
    var Z = 122;
    var lower = (c) => c | 32;
    var noop = () => {
    };
    var MultipartParser = class {
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop;
        this.onHeaderField = noop;
        this.onHeadersEnd = noop;
        this.onHeaderValue = noop;
        this.onPartBegin = noop;
        this.onPartData = noop;
        this.onPartEnd = noop;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i = 0; i < boundary.length; i++) {
          ui8a[i] = boundary.charCodeAt(i);
          this.boundaryChars[ui8a[i]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      write(data) {
        let i = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index, state, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c;
        let cl;
        const mark = (name) => {
          this[name + "Mark"] = i;
        };
        const clear = (name) => {
          delete this[name + "Mark"];
        };
        const callback = (callbackSymbol, start, end, ui8a) => {
          if (start === void 0 || start !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start, end));
          }
        };
        const dataCallback = (name, clear2) => {
          const markSymbol = name + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name, this[markSymbol], i, data);
            delete this[markSymbol];
          } else {
            callback(name, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        };
        for (i = 0; i < length_; i++) {
          c = data[i];
          switch (state) {
            case S.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c !== CR) {
                  return;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
                  index = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c !== boundary[index + 2]) {
                index = -2;
              }
              if (c === boundary[index + 2]) {
                index++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("onHeaderField");
              index = 0;
            case S.HEADER_FIELD:
              if (c === CR) {
                clear("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              mark("onHeaderValue");
              state = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              if (c === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("onPartData");
            case S.PART_DATA:
              previousIndex = index;
              if (index === 0) {
                i += boundaryEnd;
                while (i < bufferLength && !(data[i] in boundaryChars)) {
                  i += boundaryLength;
                }
                i -= boundaryEnd;
                c = data[i];
              }
              if (index < boundary.length) {
                if (boundary[index] === c) {
                  if (index === 0) {
                    dataCallback("onPartData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c === CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index = 0;
                  if (c === LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index;
        this.state = state;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
    function _fileName(headerValue) {
      const m = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
      if (!m) {
        return;
      }
      const match = m[2] || m[3] || "";
      let filename = match.slice(match.lastIndexOf("\\") + 1);
      filename = filename.replace(/%22/g, '"');
      filename = filename.replace(/&#(\d{4});/g, (m2, code) => {
        return String.fromCharCode(code);
      });
      return filename;
    }
    async function toFormData(Body, ct) {
      if (!/multipart/i.test(ct)) {
        throw new TypeError("Failed to fetch");
      }
      const m = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
      if (!m) {
        throw new TypeError("no or bad content-type header, no multipart boundary");
      }
      const parser = new MultipartParser(m[1] || m[2]);
      let headerField;
      let headerValue;
      let entryValue;
      let entryName;
      let contentType;
      let filename;
      const entryChunks = [];
      const formData = new handler.FormData();
      const onPartData = (ui8a) => {
        entryValue += decoder.decode(ui8a, { stream: true });
      };
      const appendToFile = (ui8a) => {
        entryChunks.push(ui8a);
      };
      const appendFileToFormData = () => {
        const file = new handler.File(entryChunks, filename, { type: contentType });
        formData.append(entryName, file);
      };
      const appendEntryToFormData = () => {
        formData.append(entryName, entryValue);
      };
      const decoder = new TextDecoder("utf-8");
      decoder.decode();
      parser.onPartBegin = function() {
        parser.onPartData = onPartData;
        parser.onPartEnd = appendEntryToFormData;
        headerField = "";
        headerValue = "";
        entryValue = "";
        entryName = "";
        contentType = "";
        filename = null;
        entryChunks.length = 0;
      };
      parser.onHeaderField = function(ui8a) {
        headerField += decoder.decode(ui8a, { stream: true });
      };
      parser.onHeaderValue = function(ui8a) {
        headerValue += decoder.decode(ui8a, { stream: true });
      };
      parser.onHeaderEnd = function() {
        headerValue += decoder.decode();
        headerField = headerField.toLowerCase();
        if (headerField === "content-disposition") {
          const m2 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
          if (m2) {
            entryName = m2[2] || m2[3] || "";
          }
          filename = _fileName(headerValue);
          if (filename) {
            parser.onPartData = appendToFile;
            parser.onPartEnd = appendFileToFormData;
          }
        } else if (headerField === "content-type") {
          contentType = headerValue;
        }
        headerValue = "";
        headerField = "";
      };
      for await (const chunk of Body) {
        parser.write(chunk);
      }
      parser.end();
      return formData;
    }
    exports2.toFormData = toFormData;
  }
});

// .netlify/handler-a3623ede.js
var require_handler_a3623ede = __commonJS({
  ".netlify/handler-a3623ede.js"(exports2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var zlib = require("zlib");
    var Stream = require("stream");
    var node_util = require("util");
    var node_url = require("url");
    var net = require("net");
    var app_js = require_app();
    function _interopDefaultLegacy(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2 : { "default": e2 };
    }
    var http__default = /* @__PURE__ */ _interopDefaultLegacy(http);
    var https__default = /* @__PURE__ */ _interopDefaultLegacy(https);
    var zlib__default = /* @__PURE__ */ _interopDefaultLegacy(zlib);
    var Stream__default = /* @__PURE__ */ _interopDefaultLegacy(Stream);
    function dataUriToBuffer(uri) {
      if (!/^data:/i.test(uri)) {
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
      }
      uri = uri.replace(/\r?\n/g, "");
      const firstComma = uri.indexOf(",");
      if (firstComma === -1 || firstComma <= 4) {
        throw new TypeError("malformed data: URI");
      }
      const meta = uri.substring(5, firstComma).split(";");
      let charset = "";
      let base64 = false;
      const type = meta[0] || "text/plain";
      let typeFull = type;
      for (let i2 = 1; i2 < meta.length; i2++) {
        if (meta[i2] === "base64") {
          base64 = true;
        } else {
          typeFull += `;${meta[i2]}`;
          if (meta[i2].indexOf("charset=") === 0) {
            charset = meta[i2].substring(8);
          }
        }
      }
      if (!meta[0] && !charset.length) {
        typeFull += ";charset=US-ASCII";
        charset = "US-ASCII";
      }
      const encoding = base64 ? "base64" : "ascii";
      const data = unescape(uri.substring(firstComma + 1));
      const buffer = Buffer.from(data, encoding);
      buffer.type = type;
      buffer.typeFull = typeFull;
      buffer.charset = charset;
      return buffer;
    }
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var ponyfill_es2018 = { exports: {} };
    (function(module3, exports3) {
      (function(global2, factory) {
        factory(exports3);
      })(commonjsGlobal, function(exports4) {
        const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
        function noop() {
          return void 0;
        }
        function getGlobals() {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else if (typeof commonjsGlobal !== "undefined") {
            return commonjsGlobal;
          }
          return void 0;
        }
        const globals = getGlobals();
        function typeIsObject(x2) {
          return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
        }
        const rethrowAssertionErrorRejection = noop;
        const originalPromise = Promise;
        const originalPromiseThen = Promise.prototype.then;
        const originalPromiseResolve = Promise.resolve.bind(originalPromise);
        const originalPromiseReject = Promise.reject.bind(originalPromise);
        function newPromise(executor) {
          return new originalPromise(executor);
        }
        function promiseResolvedWith(value) {
          return originalPromiseResolve(value);
        }
        function promiseRejectedWith(reason) {
          return originalPromiseReject(reason);
        }
        function PerformPromiseThen(promise, onFulfilled, onRejected) {
          return originalPromiseThen.call(promise, onFulfilled, onRejected);
        }
        function uponPromise(promise, onFulfilled, onRejected) {
          PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
        }
        function uponFulfillment(promise, onFulfilled) {
          uponPromise(promise, onFulfilled);
        }
        function uponRejection(promise, onRejected) {
          uponPromise(promise, void 0, onRejected);
        }
        function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
          return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
        }
        function setPromiseIsHandledToTrue(promise) {
          PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
        }
        const queueMicrotask = (() => {
          const globalQueueMicrotask = globals && globals.queueMicrotask;
          if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
          }
          const resolvedPromise = promiseResolvedWith(void 0);
          return (fn) => PerformPromiseThen(resolvedPromise, fn);
        })();
        function reflectCall(F, V, args) {
          if (typeof F !== "function") {
            throw new TypeError("Argument is not a function");
          }
          return Function.prototype.apply.call(F, V, args);
        }
        function promiseCall(F, V, args) {
          try {
            return promiseResolvedWith(reflectCall(F, V, args));
          } catch (value) {
            return promiseRejectedWith(value);
          }
        }
        const QUEUE_MAX_ARRAY_SIZE = 16384;
        class SimpleQueue {
          constructor() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          get length() {
            return this._size;
          }
          push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          }
          shift() {
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          }
          forEach(callback) {
            let i2 = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i2 !== elements.length || node._next !== void 0) {
              if (i2 === elements.length) {
                node = node._next;
                elements = node._elements;
                i2 = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i2]);
              ++i2;
            }
          }
          peek() {
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
          }
        }
        function ReadableStreamReaderGenericInitialize(reader, stream) {
          reader._ownerReadableStream = stream;
          stream._reader = reader;
          if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
          } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
          } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
          }
        }
        function ReadableStreamReaderGenericCancel(reader, reason) {
          const stream = reader._ownerReadableStream;
          return ReadableStreamCancel(stream, reason);
        }
        function ReadableStreamReaderGenericRelease(reader) {
          if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          }
          reader._ownerReadableStream._reader = void 0;
          reader._ownerReadableStream = void 0;
        }
        function readerLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released reader");
        }
        function defaultReaderClosedPromiseInitialize(reader) {
          reader._closedPromise = newPromise((resolve, reject) => {
            reader._closedPromise_resolve = resolve;
            reader._closedPromise_reject = reject;
          });
        }
        function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseReject(reader, reason);
        }
        function defaultReaderClosedPromiseInitializeAsResolved(reader) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseResolve(reader);
        }
        function defaultReaderClosedPromiseReject(reader, reason) {
          if (reader._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(reader._closedPromise);
          reader._closedPromise_reject(reason);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        function defaultReaderClosedPromiseResetToRejected(reader, reason) {
          defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
        }
        function defaultReaderClosedPromiseResolve(reader) {
          if (reader._closedPromise_resolve === void 0) {
            return;
          }
          reader._closedPromise_resolve(void 0);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
        const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
        const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
        const PullSteps = SymbolPolyfill("[[PullSteps]]");
        const NumberIsFinite = Number.isFinite || function(x2) {
          return typeof x2 === "number" && isFinite(x2);
        };
        const MathTrunc = Math.trunc || function(v) {
          return v < 0 ? Math.ceil(v) : Math.floor(v);
        };
        function isDictionary(x2) {
          return typeof x2 === "object" || typeof x2 === "function";
        }
        function assertDictionary(obj, context) {
          if (obj !== void 0 && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertFunction(x2, context) {
          if (typeof x2 !== "function") {
            throw new TypeError(`${context} is not a function.`);
          }
        }
        function isObject(x2) {
          return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
        }
        function assertObject(x2, context) {
          if (!isObject(x2)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertRequiredArgument(x2, position, context) {
          if (x2 === void 0) {
            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
          }
        }
        function assertRequiredField(x2, field, context) {
          if (x2 === void 0) {
            throw new TypeError(`${field} is required in '${context}'.`);
          }
        }
        function convertUnrestrictedDouble(value) {
          return Number(value);
        }
        function censorNegativeZero(x2) {
          return x2 === 0 ? 0 : x2;
        }
        function integerPart(x2) {
          return censorNegativeZero(MathTrunc(x2));
        }
        function convertUnsignedLongLongWithEnforceRange(value, context) {
          const lowerBound = 0;
          const upperBound = Number.MAX_SAFE_INTEGER;
          let x2 = Number(value);
          x2 = censorNegativeZero(x2);
          if (!NumberIsFinite(x2)) {
            throw new TypeError(`${context} is not a finite number`);
          }
          x2 = integerPart(x2);
          if (x2 < lowerBound || x2 > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
          }
          if (!NumberIsFinite(x2) || x2 === 0) {
            return 0;
          }
          return x2;
        }
        function assertReadableStream(x2, context) {
          if (!IsReadableStream(x2)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
          }
        }
        function AcquireReadableStreamDefaultReader(stream) {
          return new ReadableStreamDefaultReader(stream);
        }
        function ReadableStreamAddReadRequest(stream, readRequest) {
          stream._reader._readRequests.push(readRequest);
        }
        function ReadableStreamFulfillReadRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readRequest = reader._readRequests.shift();
          if (done) {
            readRequest._closeSteps();
          } else {
            readRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadRequests(stream) {
          return stream._reader._readRequests.length;
        }
        function ReadableStreamHasDefaultReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamDefaultReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamDefaultReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve, reject) => {
              resolvePromise = resolve;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: () => resolvePromise({ value: void 0, done: true }),
              _errorSteps: (e2) => rejectPromise(e2)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamDefaultReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
          });
        }
        function IsReadableStreamDefaultReader(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readRequests")) {
            return false;
          }
          return x2 instanceof ReadableStreamDefaultReader;
        }
        function ReadableStreamDefaultReaderRead(reader, readRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "closed") {
            readRequest._closeSteps();
          } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
          } else {
            stream._readableStreamController[PullSteps](readRequest);
          }
        }
        function defaultReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
        }
        const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
        }).prototype);
        class ReadableStreamAsyncIteratorImpl {
          constructor(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          }
          return(value) {
            const returnSteps = () => this._returnSteps(value);
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }
          _nextSteps() {
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("iterate"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve, reject) => {
              resolvePromise = resolve;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => {
                this._ongoingPromise = void 0;
                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
              },
              _closeSteps: () => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: (reason) => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          }
          _returnSteps(value) {
            if (this._isFinished) {
              return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("finish iterating"));
            }
            if (!this._preventCancel) {
              const result = ReadableStreamReaderGenericCancel(reader, value);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, () => ({ value, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
          }
        }
        const ReadableStreamAsyncIteratorPrototype = {
          next() {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
          },
          return(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value);
          }
        };
        if (AsyncIteratorPrototype !== void 0) {
          Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
        }
        function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
          const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
          iterator._asyncIteratorImpl = impl;
          return iterator;
        }
        function IsReadableStreamAsyncIterator(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl")) {
            return false;
          }
          try {
            return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
          } catch (_a4) {
            return false;
          }
        }
        function streamAsyncIteratorBrandCheckException(name) {
          return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
        }
        const NumberIsNaN = Number.isNaN || function(x2) {
          return x2 !== x2;
        };
        function CreateArrayFromList(elements) {
          return elements.slice();
        }
        function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
          new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
        }
        function TransferArrayBuffer(O) {
          return O;
        }
        function IsDetachedBuffer(O) {
          return false;
        }
        function ArrayBufferSlice(buffer, begin, end) {
          if (buffer.slice) {
            return buffer.slice(begin, end);
          }
          const length = end - begin;
          const slice = new ArrayBuffer(length);
          CopyDataBlockBytes(slice, 0, buffer, begin, length);
          return slice;
        }
        function IsNonNegativeNumber(v) {
          if (typeof v !== "number") {
            return false;
          }
          if (NumberIsNaN(v)) {
            return false;
          }
          if (v < 0) {
            return false;
          }
          return true;
        }
        function CloneAsUint8Array(O) {
          const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
          return new Uint8Array(buffer);
        }
        function DequeueValue(container) {
          const pair = container._queue.shift();
          container._queueTotalSize -= pair.size;
          if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
          }
          return pair.value;
        }
        function EnqueueValueWithSize(container, value, size) {
          if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          }
          container._queue.push({ value, size });
          container._queueTotalSize += size;
        }
        function PeekQueueValue(container) {
          const pair = container._queue.peek();
          return pair.value;
        }
        function ResetQueue(container) {
          container._queue = new SimpleQueue();
          container._queueTotalSize = 0;
        }
        class ReadableStreamBYOBRequest {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("view");
            }
            return this._view;
          }
          respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer))
              ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }
          respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }
        }
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
          respond: { enumerable: true },
          respondWithNewView: { enumerable: true },
          view: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
          });
        }
        class ReadableByteStreamController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("byobRequest");
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
          }
          get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("desiredSize");
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
          }
          enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          }
          error(e2 = void 0) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e2);
          }
          [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              const entry = this._queue.shift();
              this._queueTotalSize -= entry.byteLength;
              ReadableByteStreamControllerHandleQueueDrain(this);
              const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              let buffer;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              const pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          }
        }
        Object.defineProperties(ReadableByteStreamController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          byobRequest: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
          });
        }
        function IsReadableByteStreamController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream")) {
            return false;
          }
          return x2 instanceof ReadableByteStreamController;
        }
        function IsReadableStreamBYOBRequest(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController")) {
            return false;
          }
          return x2 instanceof ReadableStreamBYOBRequest;
        }
        function ReadableByteStreamControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }, (e2) => {
            ReadableByteStreamControllerError(controller, e2);
          });
        }
        function ReadableByteStreamControllerClearPendingPullIntos(controller) {
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          controller._pendingPullIntos = new SimpleQueue();
        }
        function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
          let done = false;
          if (stream._state === "closed") {
            done = true;
          }
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
          } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
          }
        }
        function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
          const bytesFilled = pullIntoDescriptor.bytesFilled;
          const elementSize = pullIntoDescriptor.elementSize;
          return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
        }
        function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
          controller._queue.push({ buffer, byteOffset, byteLength });
          controller._queueTotalSize += byteLength;
        }
        function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
          const elementSize = pullIntoDescriptor.elementSize;
          const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
          const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
          const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
          const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
          let totalBytesToCopyRemaining = maxBytesToCopy;
          let ready = false;
          if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
          }
          const queue = controller._queue;
          while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
              queue.shift();
            } else {
              headOfQueue.byteOffset += bytesToCopy;
              headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
          }
          return ready;
        }
        function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
          pullIntoDescriptor.bytesFilled += size;
        }
        function ReadableByteStreamControllerHandleQueueDrain(controller) {
          if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
          } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }
        function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
          if (controller._byobRequest === null) {
            return;
          }
          controller._byobRequest._associatedReadableByteStreamController = void 0;
          controller._byobRequest._view = null;
          controller._byobRequest = null;
        }
        function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
          while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
              return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
          const stream = controller._controlledReadableByteStream;
          let elementSize = 1;
          if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
          }
          const ctor = view.constructor;
          const buffer = TransferArrayBuffer(view.buffer);
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: "byob"
          };
          if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
          }
          if (stream._state === "closed") {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
          }
          if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
              ReadableByteStreamControllerHandleQueueDrain(controller);
              readIntoRequest._chunkSteps(filledView);
              return;
            }
            if (controller._closeRequested) {
              const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e2);
              readIntoRequest._errorSteps(e2);
              return;
            }
          }
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
          const stream = controller._controlledReadableByteStream;
          if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
          if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
          }
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize;
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
          } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerShiftPendingPullInto(controller) {
          const descriptor = controller._pendingPullIntos.shift();
          return descriptor;
        }
        function ReadableByteStreamControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return false;
          }
          if (controller._closeRequested) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableByteStreamControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
        }
        function ReadableByteStreamControllerClose(controller) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e2);
              throw e2;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
        function ReadableByteStreamControllerEnqueue(controller, chunk) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          const buffer = chunk.buffer;
          const byteOffset = chunk.byteOffset;
          const byteLength = chunk.byteLength;
          const transferredBuffer = TransferArrayBuffer(buffer);
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer))
              ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
              if (controller._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
              }
              const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
          } else if (ReadableStreamHasBYOBReader(stream)) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerError(controller, e2) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return;
          }
          ReadableByteStreamControllerClearPendingPullIntos(controller);
          ResetQueue(controller);
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e2);
        }
        function ReadableByteStreamControllerGetBYOBRequest(controller) {
          if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
          }
          return controller._byobRequest;
        }
        function ReadableByteStreamControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableByteStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableByteStreamControllerRespond(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (bytesWritten !== 0) {
              throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
          } else {
            if (bytesWritten === 0) {
              throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
              throw new RangeError("bytesWritten out of range");
            }
          }
          firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
          ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
        }
        function ReadableByteStreamControllerRespondWithNewView(controller, view) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (view.byteLength !== 0) {
              throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
          } else {
            if (view.byteLength === 0) {
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
          }
          if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
          }
          if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          }
          if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
          }
          const viewByteLength = view.byteLength;
          firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
          ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
        }
        function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
          controller._controlledReadableByteStream = stream;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._byobRequest = null;
          controller._queue = controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._closeRequested = false;
          controller._started = false;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          controller._autoAllocateChunkSize = autoAllocateChunkSize;
          controller._pendingPullIntos = new SimpleQueue();
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }, (r2) => {
            ReadableByteStreamControllerError(controller, r2);
          });
        }
        function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
          const controller = Object.create(ReadableByteStreamController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingByteSource.start !== void 0) {
            startAlgorithm = () => underlyingByteSource.start(controller);
          }
          if (underlyingByteSource.pull !== void 0) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
          }
          if (underlyingByteSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
          }
          const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
          if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
          }
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
        }
        function SetUpReadableStreamBYOBRequest(request, controller, view) {
          request._associatedReadableByteStreamController = controller;
          request._view = view;
        }
        function byobRequestBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
        }
        function byteStreamControllerBrandCheckException(name) {
          return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
        }
        function AcquireReadableStreamBYOBReader(stream) {
          return new ReadableStreamBYOBReader(stream);
        }
        function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
          stream._reader._readIntoRequests.push(readIntoRequest);
        }
        function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readIntoRequest = reader._readIntoRequests.shift();
          if (done) {
            readIntoRequest._closeSteps(chunk);
          } else {
            readIntoRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadIntoRequests(stream) {
          return stream._reader._readIntoRequests.length;
        }
        function ReadableStreamHasBYOBReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamBYOBReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamBYOBReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read(view) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve, reject) => {
              resolvePromise = resolve;
              rejectPromise = reject;
            });
            const readIntoRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
              _errorSteps: (e2) => rejectPromise(e2)
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readIntoRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamBYOBReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
          });
        }
        function IsReadableStreamBYOBReader(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests")) {
            return false;
          }
          return x2 instanceof ReadableStreamBYOBReader;
        }
        function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
          } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
          }
        }
        function byobReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
        }
        function ExtractHighWaterMark(strategy, defaultHWM) {
          const { highWaterMark } = strategy;
          if (highWaterMark === void 0) {
            return defaultHWM;
          }
          if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
          }
          return highWaterMark;
        }
        function ExtractSizeAlgorithm(strategy) {
          const { size } = strategy;
          if (!size) {
            return () => 1;
          }
          return size;
        }
        function convertQueuingStrategy(init3, context) {
          assertDictionary(init3, context);
          const highWaterMark = init3 === null || init3 === void 0 ? void 0 : init3.highWaterMark;
          const size = init3 === null || init3 === void 0 ? void 0 : init3.size;
          return {
            highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
            size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
          };
        }
        function convertQueuingStrategySize(fn, context) {
          assertFunction(fn, context);
          return (chunk) => convertUnrestrictedDouble(fn(chunk));
        }
        function convertUnderlyingSink(original, context) {
          assertDictionary(original, context);
          const abort = original === null || original === void 0 ? void 0 : original.abort;
          const close = original === null || original === void 0 ? void 0 : original.close;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          const write = original === null || original === void 0 ? void 0 : original.write;
          return {
            abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
            write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type
          };
        }
        function convertUnderlyingSinkAbortCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSinkCloseCallback(fn, original, context) {
          assertFunction(fn, context);
          return () => promiseCall(fn, original, []);
        }
        function convertUnderlyingSinkStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertUnderlyingSinkWriteCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        function assertWritableStream(x2, context) {
          if (!IsWritableStream(x2)) {
            throw new TypeError(`${context} is not a WritableStream.`);
          }
        }
        function isAbortSignal2(value) {
          if (typeof value !== "object" || value === null) {
            return false;
          }
          try {
            return typeof value.aborted === "boolean";
          } catch (_a4) {
            return false;
          }
        }
        const supportsAbortController = typeof AbortController === "function";
        function createAbortController() {
          if (supportsAbortController) {
            return new AbortController();
          }
          return void 0;
        }
        class WritableStream {
          constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            const type = underlyingSink.type;
            if (type !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          get locked() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("locked");
            }
            return IsWritableStreamLocked(this);
          }
          abort(reason = void 0) {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          }
          close() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          }
          getWriter() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          }
        }
        Object.defineProperties(WritableStream.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          getWriter: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
          });
        }
        function AcquireWritableStreamDefaultWriter(stream) {
          return new WritableStreamDefaultWriter(stream);
        }
        function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(WritableStream.prototype);
          InitializeWritableStream(stream);
          const controller = Object.create(WritableStreamDefaultController.prototype);
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function InitializeWritableStream(stream) {
          stream._state = "writable";
          stream._storedError = void 0;
          stream._writer = void 0;
          stream._writableStreamController = void 0;
          stream._writeRequests = new SimpleQueue();
          stream._inFlightWriteRequest = void 0;
          stream._closeRequest = void 0;
          stream._inFlightCloseRequest = void 0;
          stream._pendingAbortRequest = void 0;
          stream._backpressure = false;
        }
        function IsWritableStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_writableStreamController")) {
            return false;
          }
          return x2 instanceof WritableStream;
        }
        function IsWritableStreamLocked(stream) {
          if (stream._writer === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamAbort(stream, reason) {
          var _a4;
          if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(void 0);
          }
          stream._writableStreamController._abortReason = reason;
          (_a4 = stream._writableStreamController._abortController) === null || _a4 === void 0 ? void 0 : _a4.abort();
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseResolvedWith(void 0);
          }
          if (stream._pendingAbortRequest !== void 0) {
            return stream._pendingAbortRequest._promise;
          }
          let wasAlreadyErroring = false;
          if (state === "erroring") {
            wasAlreadyErroring = true;
            reason = void 0;
          }
          const promise = newPromise((resolve, reject) => {
            stream._pendingAbortRequest = {
              _promise: void 0,
              _resolve: resolve,
              _reject: reject,
              _reason: reason,
              _wasAlreadyErroring: wasAlreadyErroring
            };
          });
          stream._pendingAbortRequest._promise = promise;
          if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
          }
          return promise;
        }
        function WritableStreamClose(stream) {
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
          }
          const promise = newPromise((resolve, reject) => {
            const closeRequest = {
              _resolve: resolve,
              _reject: reject
            };
            stream._closeRequest = closeRequest;
          });
          const writer = stream._writer;
          if (writer !== void 0 && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
          }
          WritableStreamDefaultControllerClose(stream._writableStreamController);
          return promise;
        }
        function WritableStreamAddWriteRequest(stream) {
          const promise = newPromise((resolve, reject) => {
            const writeRequest = {
              _resolve: resolve,
              _reject: reject
            };
            stream._writeRequests.push(writeRequest);
          });
          return promise;
        }
        function WritableStreamDealWithRejection(stream, error) {
          const state = stream._state;
          if (state === "writable") {
            WritableStreamStartErroring(stream, error);
            return;
          }
          WritableStreamFinishErroring(stream);
        }
        function WritableStreamStartErroring(stream, reason) {
          const controller = stream._writableStreamController;
          stream._state = "erroring";
          stream._storedError = reason;
          const writer = stream._writer;
          if (writer !== void 0) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
          }
          if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
          }
        }
        function WritableStreamFinishErroring(stream) {
          stream._state = "errored";
          stream._writableStreamController[ErrorSteps]();
          const storedError = stream._storedError;
          stream._writeRequests.forEach((writeRequest) => {
            writeRequest._reject(storedError);
          });
          stream._writeRequests = new SimpleQueue();
          if (stream._pendingAbortRequest === void 0) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const abortRequest = stream._pendingAbortRequest;
          stream._pendingAbortRequest = void 0;
          if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
          uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          });
        }
        function WritableStreamFinishInFlightWrite(stream) {
          stream._inFlightWriteRequest._resolve(void 0);
          stream._inFlightWriteRequest = void 0;
        }
        function WritableStreamFinishInFlightWriteWithError(stream, error) {
          stream._inFlightWriteRequest._reject(error);
          stream._inFlightWriteRequest = void 0;
          WritableStreamDealWithRejection(stream, error);
        }
        function WritableStreamFinishInFlightClose(stream) {
          stream._inFlightCloseRequest._resolve(void 0);
          stream._inFlightCloseRequest = void 0;
          const state = stream._state;
          if (state === "erroring") {
            stream._storedError = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._resolve();
              stream._pendingAbortRequest = void 0;
            }
          }
          stream._state = "closed";
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseResolve(writer);
          }
        }
        function WritableStreamFinishInFlightCloseWithError(stream, error) {
          stream._inFlightCloseRequest._reject(error);
          stream._inFlightCloseRequest = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._reject(error);
            stream._pendingAbortRequest = void 0;
          }
          WritableStreamDealWithRejection(stream, error);
        }
        function WritableStreamCloseQueuedOrInFlight(stream) {
          if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamHasOperationMarkedInFlight(stream) {
          if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamMarkCloseRequestInFlight(stream) {
          stream._inFlightCloseRequest = stream._closeRequest;
          stream._closeRequest = void 0;
        }
        function WritableStreamMarkFirstWriteRequestInFlight(stream) {
          stream._inFlightWriteRequest = stream._writeRequests.shift();
        }
        function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
          if (stream._closeRequest !== void 0) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = void 0;
          }
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
          }
        }
        function WritableStreamUpdateBackpressure(stream, backpressure) {
          const writer = stream._writer;
          if (writer !== void 0 && backpressure !== stream._backpressure) {
            if (backpressure) {
              defaultWriterReadyPromiseReset(writer);
            } else {
              defaultWriterReadyPromiseResolve(writer);
            }
          }
          stream._backpressure = backpressure;
        }
        class WritableStreamDefaultWriter {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              const storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("desiredSize");
            }
            if (this._ownerWritableStream === void 0) {
              throw defaultWriterLockException("desiredSize");
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
          }
          get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            }
            return this._readyPromise;
          }
          abort(reason = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          }
          close() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          }
          releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          }
          write(chunk = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          }
        }
        Object.defineProperties(WritableStreamDefaultWriter.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          releaseLock: { enumerable: true },
          write: { enumerable: true },
          closed: { enumerable: true },
          desiredSize: { enumerable: true },
          ready: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
          });
        }
        function IsWritableStreamDefaultWriter(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream")) {
            return false;
          }
          return x2 instanceof WritableStreamDefaultWriter;
        }
        function WritableStreamDefaultWriterAbort(writer, reason) {
          const stream = writer._ownerWritableStream;
          return WritableStreamAbort(stream, reason);
        }
        function WritableStreamDefaultWriterClose(writer) {
          const stream = writer._ownerWritableStream;
          return WritableStreamClose(stream);
        }
        function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          return WritableStreamDefaultWriterClose(writer);
        }
        function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
          if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error);
          } else {
            defaultWriterClosedPromiseResetToRejected(writer, error);
          }
        }
        function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
          if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error);
          } else {
            defaultWriterReadyPromiseResetToRejected(writer, error);
          }
        }
        function WritableStreamDefaultWriterGetDesiredSize(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (state === "errored" || state === "erroring") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
        }
        function WritableStreamDefaultWriterRelease(writer) {
          const stream = writer._ownerWritableStream;
          const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
          WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
          stream._writer = void 0;
          writer._ownerWritableStream = void 0;
        }
        function WritableStreamDefaultWriterWrite(writer, chunk) {
          const stream = writer._ownerWritableStream;
          const controller = stream._writableStreamController;
          const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
          if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          const state = stream._state;
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
          }
          if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
          }
          const promise = WritableStreamAddWriteRequest(stream);
          WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
          return promise;
        }
        const closeSentinel = {};
        class WritableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("abortReason");
            }
            return this._abortReason;
          }
          get signal() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("signal");
            }
            if (this._abortController === void 0) {
              throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            }
            return this._abortController.signal;
          }
          error(e2 = void 0) {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            const state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e2);
          }
          [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [ErrorSteps]() {
            ResetQueue(this);
          }
        }
        Object.defineProperties(WritableStreamDefaultController.prototype, {
          abortReason: { enumerable: true },
          signal: { enumerable: true },
          error: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
          });
        }
        function IsWritableStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream")) {
            return false;
          }
          return x2 instanceof WritableStreamDefaultController;
        }
        function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledWritableStream = stream;
          stream._writableStreamController = controller;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._abortReason = void 0;
          controller._abortController = createAbortController();
          controller._started = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._writeAlgorithm = writeAlgorithm;
          controller._closeAlgorithm = closeAlgorithm;
          controller._abortAlgorithm = abortAlgorithm;
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
          const startResult = startAlgorithm();
          const startPromise = promiseResolvedWith(startResult);
          uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (r2) => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r2);
          });
        }
        function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(WritableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let writeAlgorithm = () => promiseResolvedWith(void 0);
          let closeAlgorithm = () => promiseResolvedWith(void 0);
          let abortAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSink.start !== void 0) {
            startAlgorithm = () => underlyingSink.start(controller);
          }
          if (underlyingSink.write !== void 0) {
            writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
          }
          if (underlyingSink.close !== void 0) {
            closeAlgorithm = () => underlyingSink.close();
          }
          if (underlyingSink.abort !== void 0) {
            abortAlgorithm = (reason) => underlyingSink.abort(reason);
          }
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function WritableStreamDefaultControllerClearAlgorithms(controller) {
          controller._writeAlgorithm = void 0;
          controller._closeAlgorithm = void 0;
          controller._abortAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function WritableStreamDefaultControllerClose(controller) {
          EnqueueValueWithSize(controller, closeSentinel, 0);
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
          try {
            return controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
          }
        }
        function WritableStreamDefaultControllerGetDesiredSize(controller) {
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
          }
          const stream = controller._controlledWritableStream;
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
          const stream = controller._controlledWritableStream;
          if (!controller._started) {
            return;
          }
          if (stream._inFlightWriteRequest !== void 0) {
            return;
          }
          const state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length === 0) {
            return;
          }
          const value = PeekQueueValue(controller);
          if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
          } else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
        function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
          if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error);
          }
        }
        function WritableStreamDefaultControllerProcessClose(controller) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkCloseRequestInFlight(stream);
          DequeueValue(controller);
          const sinkClosePromise = controller._closeAlgorithm();
          WritableStreamDefaultControllerClearAlgorithms(controller);
          uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
          }, (reason) => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkFirstWriteRequestInFlight(stream);
          const sinkWritePromise = controller._writeAlgorithm(chunk);
          uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
              const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (reason) => {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerGetBackpressure(controller) {
          const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
          return desiredSize <= 0;
        }
        function WritableStreamDefaultControllerError(controller, error) {
          const stream = controller._controlledWritableStream;
          WritableStreamDefaultControllerClearAlgorithms(controller);
          WritableStreamStartErroring(stream, error);
        }
        function streamBrandCheckException$2(name) {
          return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
        }
        function defaultControllerBrandCheckException$2(name) {
          return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
        }
        function defaultWriterBrandCheckException(name) {
          return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
        }
        function defaultWriterLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released writer");
        }
        function defaultWriterClosedPromiseInitialize(writer) {
          writer._closedPromise = newPromise((resolve, reject) => {
            writer._closedPromise_resolve = resolve;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = "pending";
          });
        }
        function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseReject(writer, reason);
        }
        function defaultWriterClosedPromiseInitializeAsResolved(writer) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseResolve(writer);
        }
        function defaultWriterClosedPromiseReject(writer, reason) {
          if (writer._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._closedPromise);
          writer._closedPromise_reject(reason);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "rejected";
        }
        function defaultWriterClosedPromiseResetToRejected(writer, reason) {
          defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterClosedPromiseResolve(writer) {
          if (writer._closedPromise_resolve === void 0) {
            return;
          }
          writer._closedPromise_resolve(void 0);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "resolved";
        }
        function defaultWriterReadyPromiseInitialize(writer) {
          writer._readyPromise = newPromise((resolve, reject) => {
            writer._readyPromise_resolve = resolve;
            writer._readyPromise_reject = reject;
          });
          writer._readyPromiseState = "pending";
        }
        function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseReject(writer, reason);
        }
        function defaultWriterReadyPromiseInitializeAsResolved(writer) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseResolve(writer);
        }
        function defaultWriterReadyPromiseReject(writer, reason) {
          if (writer._readyPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._readyPromise);
          writer._readyPromise_reject(reason);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "rejected";
        }
        function defaultWriterReadyPromiseReset(writer) {
          defaultWriterReadyPromiseInitialize(writer);
        }
        function defaultWriterReadyPromiseResetToRejected(writer, reason) {
          defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterReadyPromiseResolve(writer) {
          if (writer._readyPromise_resolve === void 0) {
            return;
          }
          writer._readyPromise_resolve(void 0);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "fulfilled";
        }
        const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
        function isDOMExceptionConstructor(ctor) {
          if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
          }
          try {
            new ctor();
            return true;
          } catch (_a4) {
            return false;
          }
        }
        function createDOMExceptionPolyfill() {
          const ctor = function DOMException2(message, name) {
            this.message = message || "";
            this.name = name || "Error";
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          };
          ctor.prototype = Object.create(Error.prototype);
          Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
          return ctor;
        }
        const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
        function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
          const reader = AcquireReadableStreamDefaultReader(source);
          const writer = AcquireWritableStreamDefaultWriter(dest);
          source._disturbed = true;
          let shuttingDown = false;
          let currentWrite = promiseResolvedWith(void 0);
          return newPromise((resolve, reject) => {
            let abortAlgorithm;
            if (signal !== void 0) {
              abortAlgorithm = () => {
                const error = new DOMException$1("Aborted", "AbortError");
                const actions = [];
                if (!preventAbort) {
                  actions.push(() => {
                    if (dest._state === "writable") {
                      return WritableStreamAbort(dest, error);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                if (!preventCancel) {
                  actions.push(() => {
                    if (source._state === "readable") {
                      return ReadableStreamCancel(source, error);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error);
              };
              if (signal.aborted) {
                abortAlgorithm();
                return;
              }
              signal.addEventListener("abort", abortAlgorithm);
            }
            function pipeLoop() {
              return newPromise((resolveLoop, rejectLoop) => {
                function next(done) {
                  if (done) {
                    resolveLoop();
                  } else {
                    PerformPromiseThen(pipeStep(), next, rejectLoop);
                  }
                }
                next(false);
              });
            }
            function pipeStep() {
              if (shuttingDown) {
                return promiseResolvedWith(true);
              }
              return PerformPromiseThen(writer._readyPromise, () => {
                return newPromise((resolveRead, rejectRead) => {
                  ReadableStreamDefaultReaderRead(reader, {
                    _chunkSteps: (chunk) => {
                      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop);
                      resolveRead(false);
                    },
                    _closeSteps: () => resolveRead(true),
                    _errorSteps: rejectRead
                  });
                });
              });
            }
            isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
              if (!preventAbort) {
                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesClosed(source, reader._closedPromise, () => {
              if (!preventClose) {
                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
              } else {
                shutdown();
              }
            });
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
              const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
              } else {
                shutdown(true, destClosed);
              }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
              const oldCurrentWrite = currentWrite;
              return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
            }
            function isOrBecomesErrored(stream, promise, action) {
              if (stream._state === "errored") {
                action(stream._storedError);
              } else {
                uponRejection(promise, action);
              }
            }
            function isOrBecomesClosed(stream, promise, action) {
              if (stream._state === "closed") {
                action();
              } else {
                uponFulfillment(promise, action);
              }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), doTheRest);
              } else {
                doTheRest();
              }
              function doTheRest() {
                uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              }
            }
            function shutdown(isError, error) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
              } else {
                finalize(isError, error);
              }
            }
            function finalize(isError, error) {
              WritableStreamDefaultWriterRelease(writer);
              ReadableStreamReaderGenericRelease(reader);
              if (signal !== void 0) {
                signal.removeEventListener("abort", abortAlgorithm);
              }
              if (isError) {
                reject(error);
              } else {
                resolve(void 0);
              }
            }
          });
        }
        class ReadableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("desiredSize");
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          }
          enqueue(chunk = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }
          error(e2 = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e2);
          }
          [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              const chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          }
        }
        Object.defineProperties(ReadableStreamDefaultController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
          });
        }
        function IsReadableStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream")) {
            return false;
          }
          return x2 instanceof ReadableStreamDefaultController;
        }
        function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
          }, (e2) => {
            ReadableStreamDefaultControllerError(controller, e2);
          });
        }
        function ReadableStreamDefaultControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableStream;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableStreamDefaultControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function ReadableStreamDefaultControllerClose(controller) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          controller._closeRequested = true;
          if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
        }
        function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
          } else {
            let chunkSize;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              ReadableStreamDefaultControllerError(controller, chunkSizeE);
              throw chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              ReadableStreamDefaultControllerError(controller, enqueueE);
              throw enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        function ReadableStreamDefaultControllerError(controller, e2) {
          const stream = controller._controlledReadableStream;
          if (stream._state !== "readable") {
            return;
          }
          ResetQueue(controller);
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e2);
        }
        function ReadableStreamDefaultControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableStreamDefaultControllerHasBackpressure(controller) {
          if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
          }
          return true;
        }
        function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
          const state = controller._controlledReadableStream._state;
          if (!controller._closeRequested && state === "readable") {
            return true;
          }
          return false;
        }
        function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledReadableStream = stream;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._started = false;
          controller._closeRequested = false;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }, (r2) => {
            ReadableStreamDefaultControllerError(controller, r2);
          });
        }
        function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSource.start !== void 0) {
            startAlgorithm = () => underlyingSource.start(controller);
          }
          if (underlyingSource.pull !== void 0) {
            pullAlgorithm = () => underlyingSource.pull(controller);
          }
          if (underlyingSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
          }
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function defaultControllerBrandCheckException$1(name) {
          return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
        }
        function ReadableStreamTee(stream, cloneForBranch2) {
          if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
          }
          return ReadableStreamDefaultTee(stream);
        }
        function ReadableStreamDefaultTee(stream, cloneForBranch2) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgain = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve) => {
            resolveCancelPromise = resolve;
          });
          function pullAlgorithm() {
            if (reading) {
              readAgain = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgain = false;
                  const chunk1 = chunk;
                  const chunk2 = chunk;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgain) {
                    pullAlgorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
          }
          branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
          branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
          uponRejection(reader._closedPromise, (r2) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
          return [branch1, branch2];
        }
        function ReadableByteStreamTee(stream) {
          let reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgainForBranch1 = false;
          let readAgainForBranch2 = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve) => {
            resolveCancelPromise = resolve;
          });
          function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, (r2) => {
              if (thisReader !== reader) {
                return;
              }
              ReadableByteStreamControllerError(branch1._readableStreamController, r2);
              ReadableByteStreamControllerError(branch2._readableStreamController, r2);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
          }
          function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamDefaultReader(stream);
              forwardReaderError(reader);
            }
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const chunk1 = chunk;
                  let chunk2 = chunk;
                  if (!canceled1 && !canceled2) {
                    try {
                      chunk2 = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                  }
                  if (!canceled1) {
                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableByteStreamControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerClose(branch2._readableStreamController);
                }
                if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                }
                if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
          }
          function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamBYOBReader(stream);
              forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const byobCanceled = forBranch2 ? canceled2 : canceled1;
                  const otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!otherCanceled) {
                    let clonedChunk;
                    try {
                      clonedChunk = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                  } else if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: (chunk) => {
                reading = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!byobCanceled) {
                  ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                }
                if (!otherCanceled) {
                  ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                }
                if (chunk !== void 0) {
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                  }
                }
                if (!byobCanceled || !otherCanceled) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
          }
          function pull1Algorithm() {
            if (reading) {
              readAgainForBranch1 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(void 0);
          }
          function pull2Algorithm() {
            if (reading) {
              readAgainForBranch2 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
            return;
          }
          branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
          branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
          forwardReaderError(reader);
          return [branch1, branch2];
        }
        function convertUnderlyingDefaultOrByteSource(source, context) {
          assertDictionary(source, context);
          const original = source;
          const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
          const cancel = original === null || original === void 0 ? void 0 : original.cancel;
          const pull = original === null || original === void 0 ? void 0 : original.pull;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          return {
            autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
            type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
          };
        }
        function convertUnderlyingSourceCancelCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSourcePullCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertUnderlyingSourceStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertReadableStreamType(type, context) {
          type = `${type}`;
          if (type !== "bytes") {
            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
          }
          return type;
        }
        function convertReaderOptions(options, context) {
          assertDictionary(options, context);
          const mode = options === null || options === void 0 ? void 0 : options.mode;
          return {
            mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
          };
        }
        function convertReadableStreamReaderMode(mode, context) {
          mode = `${mode}`;
          if (mode !== "byob") {
            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
          }
          return mode;
        }
        function convertIteratorOptions(options, context) {
          assertDictionary(options, context);
          const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
          return { preventCancel: Boolean(preventCancel) };
        }
        function convertPipeOptions(options, context) {
          assertDictionary(options, context);
          const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
          const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
          const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
          const signal = options === null || options === void 0 ? void 0 : options.signal;
          if (signal !== void 0) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
          }
          return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
          };
        }
        function assertAbortSignal(signal, context) {
          if (!isAbortSignal2(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
          }
        }
        function convertReadableWritablePair(pair, context) {
          assertDictionary(pair, context);
          const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
          assertRequiredField(readable, "readable", "ReadableWritablePair");
          assertReadableStream(readable, `${context} has member 'readable' that`);
          const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
          assertRequiredField(writable, "writable", "ReadableWritablePair");
          assertWritableStream(writable, `${context} has member 'writable' that`);
          return { readable, writable };
        }
        class ReadableStream2 {
          constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              const highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              const highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          get locked() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("locked");
            }
            return IsReadableStreamLocked(this);
          }
          cancel(reason = void 0) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          }
          getReader(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            const options = convertReaderOptions(rawOptions, "First parameter");
            if (options.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          }
          pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            const transform = convertReadableWritablePair(rawTransform, "First parameter");
            const options = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
          }
          pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options;
            try {
              options = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e2) {
              return promiseRejectedWith(e2);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          }
          tee() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }
          values(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            const options = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
          }
        }
        Object.defineProperties(ReadableStream2.prototype, {
          cancel: { enumerable: true },
          getReader: { enumerable: true },
          pipeThrough: { enumerable: true },
          pipeTo: { enumerable: true },
          tee: { enumerable: true },
          values: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
          });
        }
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream2.prototype.values,
            writable: true,
            configurable: true
          });
        }
        function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableByteStreamController.prototype);
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
          return stream;
        }
        function InitializeReadableStream(stream) {
          stream._state = "readable";
          stream._reader = void 0;
          stream._storedError = void 0;
          stream._disturbed = false;
        }
        function IsReadableStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readableStreamController")) {
            return false;
          }
          return x2 instanceof ReadableStream2;
        }
        function IsReadableStreamLocked(stream) {
          if (stream._reader === void 0) {
            return false;
          }
          return true;
        }
        function ReadableStreamCancel(stream, reason) {
          stream._disturbed = true;
          if (stream._state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          ReadableStreamClose(stream);
          const reader = stream._reader;
          if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._closeSteps(void 0);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
          const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
          return transformPromiseWith(sourceCancelPromise, noop);
        }
        function ReadableStreamClose(stream) {
          stream._state = "closed";
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseResolve(reader);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
          }
        }
        function ReadableStreamError(stream, e2) {
          stream._state = "errored";
          stream._storedError = e2;
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseReject(reader, e2);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._errorSteps(e2);
            });
            reader._readRequests = new SimpleQueue();
          } else {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._errorSteps(e2);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
        }
        function streamBrandCheckException$1(name) {
          return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
        }
        function convertQueuingStrategyInit(init3, context) {
          assertDictionary(init3, context);
          const highWaterMark = init3 === null || init3 === void 0 ? void 0 : init3.highWaterMark;
          assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
          return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
          };
        }
        const byteLengthSizeFunction = (chunk) => {
          return chunk.byteLength;
        };
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class ByteLengthQueuingStrategy {
          constructor(options) {
            assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("highWaterMark");
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("size");
            }
            return byteLengthSizeFunction;
          }
        }
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
          });
        }
        function byteLengthBrandCheckException(name) {
          return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
        }
        function IsByteLengthQueuingStrategy(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x2 instanceof ByteLengthQueuingStrategy;
        }
        const countSizeFunction = () => {
          return 1;
        };
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class CountQueuingStrategy {
          constructor(options) {
            assertRequiredArgument(options, 1, "CountQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._countQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("highWaterMark");
            }
            return this._countQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("size");
            }
            return countSizeFunction;
          }
        }
        Object.defineProperties(CountQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
          });
        }
        function countBrandCheckException(name) {
          return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
        }
        function IsCountQueuingStrategy(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x2 instanceof CountQueuingStrategy;
        }
        function convertTransformer(original, context) {
          assertDictionary(original, context);
          const flush = original === null || original === void 0 ? void 0 : original.flush;
          const readableType = original === null || original === void 0 ? void 0 : original.readableType;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const transform = original === null || original === void 0 ? void 0 : original.transform;
          const writableType = original === null || original === void 0 ? void 0 : original.writableType;
          return {
            flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
            readableType,
            start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
            transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
            writableType
          };
        }
        function convertTransformerFlushCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertTransformerStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertTransformerTransformCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        class TransformStream {
          constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            const transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise((resolve) => {
              startPromise_resolve = resolve;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== void 0) {
              startPromise_resolve(transformer.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          get readable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("readable");
            }
            return this._readable;
          }
          get writable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("writable");
            }
            return this._writable;
          }
        }
        Object.defineProperties(TransformStream.prototype, {
          readable: { enumerable: true },
          writable: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
          });
        }
        function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
          function startAlgorithm() {
            return startPromise;
          }
          function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
          }
          function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
          }
          function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
          }
          stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
          function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
          }
          function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(void 0);
          }
          stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          stream._backpressure = void 0;
          stream._backpressureChangePromise = void 0;
          stream._backpressureChangePromise_resolve = void 0;
          TransformStreamSetBackpressure(stream, true);
          stream._transformStreamController = void 0;
        }
        function IsTransformStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_transformStreamController")) {
            return false;
          }
          return x2 instanceof TransformStream;
        }
        function TransformStreamError(stream, e2) {
          ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);
          TransformStreamErrorWritableAndUnblockWrite(stream, e2);
        }
        function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
          TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
          WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);
          if (stream._backpressure) {
            TransformStreamSetBackpressure(stream, false);
          }
        }
        function TransformStreamSetBackpressure(stream, backpressure) {
          if (stream._backpressureChangePromise !== void 0) {
            stream._backpressureChangePromise_resolve();
          }
          stream._backpressureChangePromise = newPromise((resolve) => {
            stream._backpressureChangePromise_resolve = resolve;
          });
          stream._backpressure = backpressure;
        }
        class TransformStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("desiredSize");
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
          }
          enqueue(chunk = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }
          error(reason = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          }
          terminate() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          }
        }
        Object.defineProperties(TransformStreamDefaultController.prototype, {
          enqueue: { enumerable: true },
          error: { enumerable: true },
          terminate: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
          });
        }
        function IsTransformStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream")) {
            return false;
          }
          return x2 instanceof TransformStreamDefaultController;
        }
        function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
          controller._controlledTransformStream = stream;
          stream._transformStreamController = controller;
          controller._transformAlgorithm = transformAlgorithm;
          controller._flushAlgorithm = flushAlgorithm;
        }
        function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
          const controller = Object.create(TransformStreamDefaultController.prototype);
          let transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
          let flushAlgorithm = () => promiseResolvedWith(void 0);
          if (transformer.transform !== void 0) {
            transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
          }
          if (transformer.flush !== void 0) {
            flushAlgorithm = () => transformer.flush(controller);
          }
          SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
        }
        function TransformStreamDefaultControllerClearAlgorithms(controller) {
          controller._transformAlgorithm = void 0;
          controller._flushAlgorithm = void 0;
        }
        function TransformStreamDefaultControllerEnqueue(controller, chunk) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
          }
          try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
          } catch (e2) {
            TransformStreamErrorWritableAndUnblockWrite(stream, e2);
            throw stream._readable._storedError;
          }
          const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
          if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
          }
        }
        function TransformStreamDefaultControllerError(controller, e2) {
          TransformStreamError(controller._controlledTransformStream, e2);
        }
        function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
          const transformPromise = controller._transformAlgorithm(chunk);
          return transformPromiseWith(transformPromise, void 0, (r2) => {
            TransformStreamError(controller._controlledTransformStream, r2);
            throw r2;
          });
        }
        function TransformStreamDefaultControllerTerminate(controller) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          ReadableStreamDefaultControllerClose(readableController);
          const error = new TypeError("TransformStream terminated");
          TransformStreamErrorWritableAndUnblockWrite(stream, error);
        }
        function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
          const controller = stream._transformStreamController;
          if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
              const writable = stream._writable;
              const state = writable._state;
              if (state === "erroring") {
                throw writable._storedError;
              }
              return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }
        function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
          TransformStreamError(stream, reason);
          return promiseResolvedWith(void 0);
        }
        function TransformStreamDefaultSinkCloseAlgorithm(stream) {
          const readable = stream._readable;
          const controller = stream._transformStreamController;
          const flushPromise = controller._flushAlgorithm();
          TransformStreamDefaultControllerClearAlgorithms(controller);
          return transformPromiseWith(flushPromise, () => {
            if (readable._state === "errored") {
              throw readable._storedError;
            }
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
          }, (r2) => {
            TransformStreamError(stream, r2);
            throw readable._storedError;
          });
        }
        function TransformStreamDefaultSourcePullAlgorithm(stream) {
          TransformStreamSetBackpressure(stream, false);
          return stream._backpressureChangePromise;
        }
        function defaultControllerBrandCheckException(name) {
          return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
        }
        function streamBrandCheckException(name) {
          return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
        }
        exports4.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
        exports4.CountQueuingStrategy = CountQueuingStrategy;
        exports4.ReadableByteStreamController = ReadableByteStreamController;
        exports4.ReadableStream = ReadableStream2;
        exports4.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
        exports4.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
        exports4.ReadableStreamDefaultController = ReadableStreamDefaultController;
        exports4.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
        exports4.TransformStream = TransformStream;
        exports4.TransformStreamDefaultController = TransformStreamDefaultController;
        exports4.WritableStream = WritableStream;
        exports4.WritableStreamDefaultController = WritableStreamDefaultController;
        exports4.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
        Object.defineProperty(exports4, "__esModule", { value: true });
      });
    })(ponyfill_es2018, ponyfill_es2018.exports);
    var POOL_SIZE$1 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = require("process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, require("stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error) {
          process2.emitWarning = emitWarning;
          throw error;
        }
      } catch (error) {
        Object.assign(globalThis, ponyfill_es2018.exports);
      }
    }
    try {
      const { Blob: Blob2 } = require("buffer");
      if (Blob2 && !Blob2.prototype.stream) {
        Blob2.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error) {
    }
    var POOL_SIZE = 65536;
    async function* toIterator(parts, clone2 = true) {
      for (const part of parts) {
        if ("stream" in part) {
          yield* part.stream();
        } else if (ArrayBuffer.isView(part)) {
          if (clone2) {
            let position = part.byteOffset;
            const end = part.byteOffset + part.byteLength;
            while (position !== end) {
              const size = Math.min(end - position, POOL_SIZE);
              const chunk = part.buffer.slice(position, position + size);
              position += chunk.byteLength;
              yield new Uint8Array(chunk);
            }
          } else {
            yield part;
          }
        } else {
          let position = 0;
          while (position !== part.size) {
            const chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));
            const buffer = await chunk.arrayBuffer();
            position += buffer.byteLength;
            yield new Uint8Array(buffer);
          }
        }
      }
    }
    var _parts, _type, _size, _a;
    var _Blob = (_a = class {
      constructor(blobParts = [], options = {}) {
        __privateAdd(this, _parts, []);
        __privateAdd(this, _type, "");
        __privateAdd(this, _size, 0);
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && typeof options !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options === null)
          options = {};
        const encoder = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof _a) {
            part = element;
          } else {
            part = encoder.encode(element);
          }
          __privateSet(this, _size, __privateGet(this, _size) + (ArrayBuffer.isView(part) ? part.byteLength : part.size));
          __privateGet(this, _parts).push(part);
        }
        const type = options.type === void 0 ? "" : String(options.type);
        __privateSet(this, _type, /^[\x20-\x7E]*$/.test(type) ? type : "");
      }
      get size() {
        return __privateGet(this, _size);
      }
      get type() {
        return __privateGet(this, _type);
      }
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(__privateGet(this, _parts), false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(__privateGet(this, _parts), false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(__privateGet(this, _parts), true);
        return new globalThis.ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = __privateGet(this, _parts);
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new _a([], { type: String(type).toLowerCase() });
        __privateSet(blob, _size, span);
        __privateSet(blob, _parts, blobParts);
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    }, _parts = new WeakMap(), _type = new WeakMap(), _size = new WeakMap(), _a);
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    var Blob = _Blob;
    var Blob$1 = Blob;
    var _lastModified, _name, _a2;
    var _File = (_a2 = class extends Blob$1 {
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options);
        __privateAdd(this, _lastModified, 0);
        __privateAdd(this, _name, "");
        if (options === null)
          options = {};
        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          __privateSet(this, _lastModified, lastModified);
        }
        __privateSet(this, _name, String(fileName));
      }
      get name() {
        return __privateGet(this, _name);
      }
      get lastModified() {
        return __privateGet(this, _lastModified);
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    }, _lastModified = new WeakMap(), _name = new WeakMap(), _a2);
    var File = _File;
    var { toStringTag: t, iterator: i, hasInstance: h } = Symbol;
    var r = Math.random;
    var m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    var f = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new File([b], c, b) : b] : [a, b + ""]);
    var e = (c, f2) => (f2 ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    var x = (n, a, e2) => {
      if (a.length < e2) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
      }
    };
    var _d, _a3;
    var FormData = (_a3 = class {
      constructor(...a) {
        __privateAdd(this, _d, []);
        if (a.length)
          throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o === "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
      }
      append(...a) {
        x("append", arguments, 2);
        __privateGet(this, _d).push(f(...a));
      }
      delete(a) {
        x("delete", arguments, 1);
        a += "";
        __privateSet(this, _d, __privateGet(this, _d).filter(([b]) => b !== a));
      }
      get(a) {
        x("get", arguments, 1);
        a += "";
        for (var b = __privateGet(this, _d), l = b.length, c = 0; c < l; c++)
          if (b[c][0] === a)
            return b[c][1];
        return null;
      }
      getAll(a, b) {
        x("getAll", arguments, 1);
        b = [];
        a += "";
        __privateGet(this, _d).forEach((c) => c[0] === a && b.push(c[1]));
        return b;
      }
      has(a) {
        x("has", arguments, 1);
        a += "";
        return __privateGet(this, _d).some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this)
          a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [], c = true;
        a = f(...a);
        __privateGet(this, _d).forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        });
        c && b.push(a);
        __privateSet(this, _d, b);
      }
      *entries() {
        yield* __privateGet(this, _d);
      }
      *keys() {
        for (var [a] of this)
          yield a;
      }
      *values() {
        for (var [, a] of this)
          yield a;
      }
    }, _d = new WeakMap(), _a3);
    function formDataToBlob(F, B = Blob$1) {
      var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
      F.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, "\r\n"));
      c.push(`--${b}--`);
      return new B(c, { type: "multipart/form-data; boundary=" + b });
    }
    var FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    var FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    var NAME = Symbol.toStringTag;
    var isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    var isBlob = (object) => {
      return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    var isAbortSignal = (object) => {
      return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
    };
    var INTERNALS$2 = Symbol("Body internals");
    var Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (node_util.types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof Stream__default["default"])
          ;
        else if (body instanceof FormData) {
          body = formDataToBlob(body);
          boundary = body.type.split("=")[1];
        } else {
          body = Buffer.from(String(body));
        }
        let stream = body;
        if (Buffer.isBuffer(body)) {
          stream = Stream__default["default"].Readable.from(body);
        } else if (isBlob(body)) {
          stream = Stream__default["default"].Readable.from(body.stream());
        }
        this[INTERNALS$2] = {
          body,
          stream,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof Stream__default["default"]) {
          body.on("error", (error_) => {
            const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS$2].error = error;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].stream;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async formData() {
        const ct = this.headers.get("content-type");
        if (ct.startsWith("application/x-www-form-urlencoded")) {
          const formData = new FormData();
          const parameters = new URLSearchParams(await this.text());
          for (const [name, value] of parameters) {
            formData.append(name, value);
          }
          return formData;
        }
        const { toFormData } = await Promise.resolve().then(function() {
          return require_multipart_parser_e24c3004();
        });
        return toFormData(this.body, ct);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Body.prototype.buffer = node_util.deprecate(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    async function consumeBody(data) {
      if (data[INTERNALS$2].disturbed) {
        throw new TypeError(`body used already for: ${data.url}`);
      }
      data[INTERNALS$2].disturbed = true;
      if (data[INTERNALS$2].error) {
        throw data[INTERNALS$2].error;
      }
      const { body } = data;
      if (body === null) {
        return Buffer.alloc(0);
      }
      if (!(body instanceof Stream__default["default"])) {
        return Buffer.alloc(0);
      }
      const accum = [];
      let accumBytes = 0;
      try {
        for await (const chunk of body) {
          if (data.size > 0 && accumBytes + chunk.length > data.size) {
            const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
            body.destroy(error);
            throw error;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        }
      } catch (error) {
        const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, "system", error);
        throw error_;
      }
      if (body.readableEnded === true || body._readableState.ended === true) {
        try {
          if (accum.every((c) => typeof c === "string")) {
            return Buffer.from(accum.join(""));
          }
          return Buffer.concat(accum, accumBytes);
        } catch (error) {
          throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, "system", error);
        }
      } else {
        throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
      }
    }
    var clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance[INTERNALS$2];
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream__default["default"] && typeof body.getBoundary !== "function") {
        p1 = new Stream.PassThrough({ highWaterMark });
        p2 = new Stream.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].stream = p1;
        body = p2;
      }
      return body;
    };
    var getNonSpecFormDataBoundary = node_util.deprecate((body) => body.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167");
    var extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body instanceof FormData) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
      }
      if (body instanceof Stream__default["default"]) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    var getTotalBytes = (request) => {
      const { body } = request[INTERNALS$2];
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      return null;
    };
    var writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    var validateHeaderName = typeof http__default["default"].validateHeaderName === "function" ? http__default["default"].validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(error, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error;
      }
    };
    var validateHeaderValue = typeof http__default["default"].validateHeaderValue === "function" ? http__default["default"].validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(error, "code", { value: "ERR_INVALID_CHAR" });
        throw error;
      }
    };
    var Headers2 = class extends URLSearchParams {
      constructor(init3) {
        let result = [];
        if (init3 instanceof Headers2) {
          const raw = init3.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init3 == null)
          ;
        else if (typeof init3 === "object" && !node_util.types.isBoxedPrimitive(init3)) {
          const method = init3[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init3));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init3].map((pair) => {
              if (typeof pair !== "object" || node_util.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback, thisArg = void 0) {
        for (const name of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers2.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    function fromRawHeaders(headers = []) {
      return new Headers2(headers.reduce((result, value, index, array) => {
        if (index % 2 === 0) {
          result.push(array.slice(index, index + 2));
        }
        return result;
      }, []).filter(([name, value]) => {
        try {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return true;
        } catch {
          return false;
        }
      }));
    }
    var redirectStatus = new Set([301, 302, 303, 307, 308]);
    var isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    var INTERNALS$1 = Symbol("Response internals");
    var Response2 = class extends Body {
      constructor(body = null, options = {}) {
        super(body, options);
        const status = options.status != null ? options.status : 200;
        const headers = new Headers2(options.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          type: "default",
          url: options.url,
          status,
          statusText: options.statusText || "",
          headers,
          counter: options.counter,
          highWaterMark: options.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS$1].type;
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response2(clone(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size,
          highWaterMark: this.highWaterMark
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response2(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      static error() {
        const response = new Response2(null, { status: 0, statusText: "" });
        response[INTERNALS$1].type = "error";
        return response;
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response2.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    var getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
    };
    function stripURLForUseAsAReferrer(url, originOnly = false) {
      if (url == null) {
        return "no-referrer";
      }
      url = new URL(url);
      if (/^(about|blob|data):$/.test(url.protocol)) {
        return "no-referrer";
      }
      url.username = "";
      url.password = "";
      url.hash = "";
      if (originOnly) {
        url.pathname = "";
        url.search = "";
      }
      return url;
    }
    var ReferrerPolicy = new Set([
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]);
    var DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
    function validateReferrerPolicy(referrerPolicy) {
      if (!ReferrerPolicy.has(referrerPolicy)) {
        throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
      }
      return referrerPolicy;
    }
    function isOriginPotentiallyTrustworthy(url) {
      if (/^(http|ws)s:$/.test(url.protocol)) {
        return true;
      }
      const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
      const hostIPVersion = net.isIP(hostIp);
      if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
        return true;
      }
      if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
        return true;
      }
      if (/^(.+\.)*localhost$/.test(url.host)) {
        return false;
      }
      if (url.protocol === "file:") {
        return true;
      }
      return false;
    }
    function isUrlPotentiallyTrustworthy(url) {
      if (/^about:(blank|srcdoc)$/.test(url)) {
        return true;
      }
      if (url.protocol === "data:") {
        return true;
      }
      if (/^(blob|filesystem):$/.test(url.protocol)) {
        return true;
      }
      return isOriginPotentiallyTrustworthy(url);
    }
    function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
      if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
        return null;
      }
      const policy = request.referrerPolicy;
      if (request.referrer === "about:client") {
        return "no-referrer";
      }
      const referrerSource = request.referrer;
      let referrerURL = stripURLForUseAsAReferrer(referrerSource);
      let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      if (referrerURLCallback) {
        referrerURL = referrerURLCallback(referrerURL);
      }
      if (referrerOriginCallback) {
        referrerOrigin = referrerOriginCallback(referrerOrigin);
      }
      const currentURL = new URL(request.url);
      switch (policy) {
        case "no-referrer":
          return "no-referrer";
        case "origin":
          return referrerOrigin;
        case "unsafe-url":
          return referrerURL;
        case "strict-origin":
          if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin.toString();
        case "strict-origin-when-cross-origin":
          if (referrerURL.origin === currentURL.origin) {
            return referrerURL;
          }
          if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        case "same-origin":
          if (referrerURL.origin === currentURL.origin) {
            return referrerURL;
          }
          return "no-referrer";
        case "origin-when-cross-origin":
          if (referrerURL.origin === currentURL.origin) {
            return referrerURL;
          }
          return referrerOrigin;
        case "no-referrer-when-downgrade":
          if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerURL;
        default:
          throw new TypeError(`Invalid referrerPolicy: ${policy}`);
      }
    }
    function parseReferrerPolicyFromHeader(headers) {
      const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
      let policy = "";
      for (const token of policyTokens) {
        if (token && ReferrerPolicy.has(token)) {
          policy = token;
        }
      }
      return policy;
    }
    var INTERNALS = Symbol("Request internals");
    var isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    var Request2 = class extends Body {
      constructor(input, init3 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        if (parsedURL.username !== "" || parsedURL.password !== "") {
          throw new TypeError(`${parsedURL} is an url with embedded credentails.`);
        }
        let method = init3.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init3.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init3.body ? init3.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init3.size || input.size || 0
        });
        const headers = new Headers2(init3.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.set("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init3) {
          signal = init3.signal;
        }
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        let referrer = init3.referrer == null ? input.referrer : init3.referrer;
        if (referrer === "") {
          referrer = "no-referrer";
        } else if (referrer) {
          const parsedReferrer = new URL(referrer);
          referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
        } else {
          referrer = void 0;
        }
        this[INTERNALS] = {
          method,
          redirect: init3.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal,
          referrer
        };
        this.follow = init3.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init3.follow;
        this.compress = init3.compress === void 0 ? input.compress === void 0 ? true : input.compress : init3.compress;
        this.counter = init3.counter || input.counter || 0;
        this.agent = init3.agent || input.agent;
        this.highWaterMark = init3.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init3.insecureHTTPParser || input.insecureHTTPParser || false;
        this.referrerPolicy = init3.referrerPolicy || input.referrerPolicy || "";
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return node_url.format(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      get referrer() {
        if (this[INTERNALS].referrer === "no-referrer") {
          return "";
        }
        if (this[INTERNALS].referrer === "client") {
          return "about:client";
        }
        if (this[INTERNALS].referrer) {
          return this[INTERNALS].referrer.toString();
        }
        return void 0;
      }
      get referrerPolicy() {
        return this[INTERNALS].referrerPolicy;
      }
      set referrerPolicy(referrerPolicy) {
        this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);
      }
      clone() {
        return new Request2(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true },
      referrer: { enumerable: true },
      referrerPolicy: { enumerable: true }
    });
    var getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers2(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = DEFAULT_REFERRER_POLICY;
      }
      if (request.referrer && request.referrer !== "no-referrer") {
        request[INTERNALS].referrer = determineRequestsReferrer(request);
      } else {
        request[INTERNALS].referrer = "no-referrer";
      }
      if (request[INTERNALS].referrer instanceof URL) {
        headers.set("Referer", request.referrer);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const options = {
        path: parsedURL.pathname + search,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return {
        parsedURL,
        options
      };
    };
    var AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    var supportedSchemas = new Set(["data:", "http:", "https:"]);
    async function fetch2(url, options_) {
      return new Promise((resolve, reject) => {
        const request = new Request2(url, options_);
        const { parsedURL, options } = getNodeRequestOptions(request);
        if (!supportedSchemas.has(parsedURL.protocol)) {
          throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
        }
        if (parsedURL.protocol === "data:") {
          const data = dataUriToBuffer(request.url);
          const response2 = new Response2(data, { headers: { "Content-Type": data.typeFull } });
          resolve(response2);
          return;
        }
        const send = (parsedURL.protocol === "https:" ? https__default["default"] : http__default["default"]).request;
        const { signal } = request;
        let response = null;
        const abort = () => {
          const error = new AbortError("The operation was aborted.");
          reject(error);
          if (request.body && request.body instanceof Stream__default["default"].Readable) {
            request.body.destroy(error);
          }
          if (!response || !response.body) {
            return;
          }
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = () => {
          abort();
          finalize();
        };
        const request_ = send(parsedURL, options);
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        const finalize = () => {
          request_.abort();
          if (signal) {
            signal.removeEventListener("abort", abortAndFinalize);
          }
        };
        request_.on("error", (error) => {
          reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, "system", error));
          finalize();
        });
        fixResponseChunkedTransferBadEnding(request_, (error) => {
          response.body.destroy(error);
        });
        if (process.version < "v14") {
          request_.on("socket", (s) => {
            let endedWithEventsCount;
            s.prependListener("end", () => {
              endedWithEventsCount = s._eventsCount;
            });
            s.prependListener("close", (hadError) => {
              if (response && endedWithEventsCount < s._eventsCount && !hadError) {
                const error = new Error("Premature close");
                error.code = "ERR_STREAM_PREMATURE_CLOSE";
                response.body.emit("error", error);
              }
            });
          });
        }
        request_.on("response", (response_) => {
          request_.setTimeout(0);
          const headers = fromRawHeaders(response_.rawHeaders);
          if (isRedirect(response_.statusCode)) {
            const location = headers.get("Location");
            const locationURL = location === null ? null : new URL(location, request.url);
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  headers.set("Location", locationURL);
                }
                break;
              case "follow": {
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOptions = {
                  headers: new Headers2(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: clone(request),
                  signal: request.signal,
                  size: request.size,
                  referrer: request.referrer,
                  referrerPolicy: request.referrerPolicy
                };
                if (response_.statusCode !== 303 && request.body && options_.body instanceof Stream__default["default"].Readable) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
                  requestOptions.method = "GET";
                  requestOptions.body = void 0;
                  requestOptions.headers.delete("content-length");
                }
                const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
                if (responseReferrerPolicy) {
                  requestOptions.referrerPolicy = responseReferrerPolicy;
                }
                resolve(fetch2(new Request2(locationURL, requestOptions)));
                finalize();
                return;
              }
              default:
                return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
            }
          }
          if (signal) {
            response_.once("end", () => {
              signal.removeEventListener("abort", abortAndFinalize);
            });
          }
          let body = Stream.pipeline(response_, new Stream.PassThrough(), reject);
          if (process.version < "v12.10") {
            response_.on("aborted", abortAndFinalize);
          }
          const responseOptions = {
            url: request.url,
            status: response_.statusCode,
            statusText: response_.statusMessage,
            headers,
            size: request.size,
            counter: request.counter,
            highWaterMark: request.highWaterMark
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
            response = new Response2(body, responseOptions);
            resolve(response);
            return;
          }
          const zlibOptions = {
            flush: zlib__default["default"].Z_SYNC_FLUSH,
            finishFlush: zlib__default["default"].Z_SYNC_FLUSH
          };
          if (codings === "gzip" || codings === "x-gzip") {
            body = Stream.pipeline(body, zlib__default["default"].createGunzip(zlibOptions), reject);
            response = new Response2(body, responseOptions);
            resolve(response);
            return;
          }
          if (codings === "deflate" || codings === "x-deflate") {
            const raw = Stream.pipeline(response_, new Stream.PassThrough(), reject);
            raw.once("data", (chunk) => {
              body = (chunk[0] & 15) === 8 ? Stream.pipeline(body, zlib__default["default"].createInflate(), reject) : Stream.pipeline(body, zlib__default["default"].createInflateRaw(), reject);
              response = new Response2(body, responseOptions);
              resolve(response);
            });
            return;
          }
          if (codings === "br") {
            body = Stream.pipeline(body, zlib__default["default"].createBrotliDecompress(), reject);
            response = new Response2(body, responseOptions);
            resolve(response);
            return;
          }
          response = new Response2(body, responseOptions);
          resolve(response);
        });
        writeToStream(request_, request);
      });
    }
    function fixResponseChunkedTransferBadEnding(request, errorCallback) {
      const LAST_CHUNK = Buffer.from("0\r\n\r\n");
      let isChunkedTransfer = false;
      let properLastChunkReceived = false;
      let previousChunk;
      request.on("response", (response) => {
        const { headers } = response;
        isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
      });
      request.on("socket", (socket) => {
        const onSocketClose = () => {
          if (isChunkedTransfer && !properLastChunkReceived) {
            const error = new Error("Premature close");
            error.code = "ERR_STREAM_PREMATURE_CLOSE";
            errorCallback(error);
          }
        };
        socket.prependListener("close", onSocketClose);
        request.on("abort", () => {
          socket.removeListener("close", onSocketClose);
        });
        socket.on("data", (buf) => {
          properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
          if (!properLastChunkReceived && previousChunk) {
            properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
          }
          previousChunk = buf;
        });
      });
    }
    function __fetch_polyfill() {
      Object.defineProperties(globalThis, {
        fetch: {
          enumerable: true,
          value: fetch2
        },
        Response: {
          enumerable: true,
          value: Response2
        },
        Request: {
          enumerable: true,
          value: Request2
        },
        Headers: {
          enumerable: true,
          value: Headers2
        }
      });
    }
    __fetch_polyfill();
    function init2(manifest) {
      const app = new app_js.App(manifest);
      return async (event) => {
        const { httpMethod, headers, rawUrl, body, isBase64Encoded } = event;
        const encoding = isBase64Encoded ? "base64" : "utf-8";
        const rawBody = typeof body === "string" ? Buffer.from(body, encoding) : body;
        const rendered = await app.render({
          url: rawUrl,
          method: httpMethod,
          headers,
          rawBody
        });
        if (!rendered) {
          return {
            statusCode: 404,
            body: "Not found"
          };
        }
        const partial_response = __spreadValues({
          statusCode: rendered.status
        }, split_headers(rendered.headers));
        if (rendered.body instanceof Uint8Array) {
          return __spreadProps(__spreadValues({}, partial_response), {
            isBase64Encoded: true,
            body: Buffer.from(rendered.body).toString("base64")
          });
        }
        return __spreadProps(__spreadValues({}, partial_response), {
          body: rendered.body
        });
      };
    }
    function split_headers(headers) {
      const h2 = {};
      const m2 = {};
      for (const key in headers) {
        const value = headers[key];
        const target = Array.isArray(value) ? m2 : h2;
        target[key] = value;
      }
      return {
        headers: h2,
        multiValueHeaders: m2
      };
    }
    exports2.File = File;
    exports2.FormData = FormData;
    exports2.init = init2;
  }
});

// .netlify/handler.js
var require_handler = __commonJS({
  ".netlify/handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var handler = require_handler_a3623ede();
    require_app();
    require("http");
    require("https");
    require("zlib");
    require("stream");
    require("util");
    require("url");
    require("net");
    exports2.init = handler.init;
  }
});

// .netlify/server/chunks/load_user_data-ba355a80.js
var require_load_user_data_ba355a80 = __commonJS({
  ".netlify/server/chunks/load_user_data-ba355a80.js"(exports2) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
    var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues2 = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp2.call(b, prop))
          __defNormalProp2(a, prop, b[prop]);
      if (__getOwnPropSymbols2)
        for (var prop of __getOwnPropSymbols2(b)) {
          if (__propIsEnum2.call(b, prop))
            __defNormalProp2(a, prop, b[prop]);
        }
      return a;
    };
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    __export(exports2, {
      l: () => load_user_data
    });
    function load_user_data(session, file_location) {
      console.log(`Loading session from ${file_location}: ` + JSON.stringify(session, null, 2));
      if (session !== void 0) {
        return {
          props: __spreadValues2({}, session.data)
        };
      } else {
        return {
          props: {
            user: null,
            ably_token: null
          }
        };
      }
    }
  }
});

// .netlify/server/entries/pages/__layout.svelte.js
var require_layout_svelte = __commonJS({
  ".netlify/server/entries/pages/__layout.svelte.js"(exports2) {
    var __create = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __reExport = (target, module22, desc) => {
      if (module22 && typeof module22 === "object" || typeof module22 === "function") {
        for (let key of __getOwnPropNames(module22))
          if (!__hasOwnProp2.call(target, key) && key !== "default")
            __defProp2(target, key, { get: () => module22[key], enumerable: !(desc = __getOwnPropDesc(module22, key)) || desc.enumerable });
      }
      return target;
    };
    var __toModule = (module22) => {
      return __reExport(__markAsModule(__defProp2(module22 != null ? __create(__getProtoOf(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? { get: () => module22.default, enumerable: true } : { value: module22, enumerable: true })), module22);
    };
    __export(exports2, {
      default: () => _layout,
      load: () => load
    });
    var import_index_08869495 = __toModule(require_index_08869495());
    var import_load_user_data_ba355a80 = __toModule(require_load_user_data_ba355a80());
    var Login_header = (0, import_index_08869495.c)(($$result, $$props, $$bindings, slots) => {
      let { user } = $$props;
      if ($$props.user === void 0 && $$bindings.user && user !== void 0)
        $$bindings.user(user);
      return `<div class="${"navbar-item navbar-end"}"><div class="${"buttons"}">${user ? `<a class="${"button is-light is-outlined is-fullwidth"}" rel="${"external"}" href="${"/logout"}"><span class="${"icon"}"><i class="${"fa fa-sign-out"}"></i></span>
				<span>Logout</span></a>` : ``}

		${!user ? `<a class="${"button is-primary is-outlined"}" rel="${"external"}" href="${"/login"}"><span class="${"icon"}"><i class="${"fa fa-sign-in"}"></i></span>
				<span>Login</span></a>
			<a class="${"button is-warning is-outlined"}" rel="${"external"}" href="${"/login?screen_hint=signup"}"><span class="${"icon"}"><i class="${"fa fa-user-plus"}"></i></span>
				<span>Register</span></a>` : ``}</div></div>`;
    });
    var css = { code: "@import '../app.css';", map: null };
    async function load({ session }) {
      return (0, import_load_user_data_ba355a80.l)(session, "__layout.svelte");
    }
    var _layout = (0, import_index_08869495.c)(($$result, $$props, $$bindings, slots) => {
      let { user } = $$props;
      if ($$props.user === void 0 && $$bindings.user && user !== void 0)
        $$bindings.user(user);
      $$result.css.add(css);
      return `<nav class="${"navbar is-info"}" aria-label="${"main navigation"}"><div class="${"navbar-brand"}"><a href="${"/"}" class="${"icon is-large has-text-primary"}"><i class="${"fas fa-2x fa-code-branch"}"></i></a></div>

	<div class="${"navbar-end"}">

		
    ${user ? `<div class="${"navbar-item"}"><button class="${"button is-warning is-fullwidth is-outlined"}" href="${"/account"}"><span class="${"icon-text"}"><span class="${"icon"}"><i class="${"fas fa-user"}"></i></span>
					<span>Account</span></span></button></div>` : ``}
		${(0, import_index_08869495.v)(Login_header, "LoginHeader").$$render($$result, { user }, {}, {})}</div></nav>

${slots.default ? slots.default({}) : ``}`;
    });
  }
});

// .netlify/server/nodes/0.js
var require__ = __commonJS({
  ".netlify/server/nodes/0.js"(exports2) {
    var __create = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __reExport = (target, module32, desc) => {
      if (module32 && typeof module32 === "object" || typeof module32 === "function") {
        for (let key of __getOwnPropNames(module32))
          if (!__hasOwnProp2.call(target, key) && key !== "default")
            __defProp2(target, key, { get: () => module32[key], enumerable: !(desc = __getOwnPropDesc(module32, key)) || desc.enumerable });
      }
      return target;
    };
    var __toModule = (module32) => {
      return __reExport(__markAsModule(__defProp2(module32 != null ? __create(__getProtoOf(module32)) : {}, "default", module32 && module32.__esModule && "default" in module32 ? { get: () => module32.default, enumerable: true } : { value: module32, enumerable: true })), module32);
    };
    __export(exports2, {
      css: () => css,
      entry: () => entry,
      js: () => js,
      module: () => module2
    });
    var module2 = __toModule(require_layout_svelte());
    var entry = "pages/__layout.svelte-57e6f933.js";
    var js = ["pages/__layout.svelte-57e6f933.js", "chunks/vendor-1860a60a.js", "chunks/load_user_data-ba355a80.js", "chunks/singletons-a42a5e91.js"];
    var css = ["assets/pages/__layout.svelte-7c9d89d8.css"];
  }
});

// .netlify/server/entries/pages/error.svelte.js
var require_error_svelte = __commonJS({
  ".netlify/server/entries/pages/error.svelte.js"(exports2) {
    var __create = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __reExport = (target, module22, desc) => {
      if (module22 && typeof module22 === "object" || typeof module22 === "function") {
        for (let key of __getOwnPropNames(module22))
          if (!__hasOwnProp2.call(target, key) && key !== "default")
            __defProp2(target, key, { get: () => module22[key], enumerable: !(desc = __getOwnPropDesc(module22, key)) || desc.enumerable });
      }
      return target;
    };
    var __toModule = (module22) => {
      return __reExport(__markAsModule(__defProp2(module22 != null ? __create(__getProtoOf(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? { get: () => module22.default, enumerable: true } : { value: module22, enumerable: true })), module22);
    };
    __export(exports2, {
      default: () => Error2,
      load: () => load
    });
    var import_index_08869495 = __toModule(require_index_08869495());
    function load({ error, status }) {
      return { props: { error, status } };
    }
    var Error2 = (0, import_index_08869495.c)(($$result, $$props, $$bindings, slots) => {
      let { status } = $$props;
      let { error } = $$props;
      if ($$props.status === void 0 && $$bindings.status && status !== void 0)
        $$bindings.status(status);
      if ($$props.error === void 0 && $$bindings.error && error !== void 0)
        $$bindings.error(error);
      return `<h1>${(0, import_index_08869495.e)(status)}</h1>

<pre>${(0, import_index_08869495.e)(error.message)}</pre>



${error.frame ? `<pre>${(0, import_index_08869495.e)(error.frame)}</pre>` : ``}
${error.stack ? `<pre>${(0, import_index_08869495.e)(error.stack)}</pre>` : ``}`;
    });
  }
});

// .netlify/server/nodes/1.js
var require__2 = __commonJS({
  ".netlify/server/nodes/1.js"(exports2) {
    var __create = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __reExport = (target, module32, desc) => {
      if (module32 && typeof module32 === "object" || typeof module32 === "function") {
        for (let key of __getOwnPropNames(module32))
          if (!__hasOwnProp2.call(target, key) && key !== "default")
            __defProp2(target, key, { get: () => module32[key], enumerable: !(desc = __getOwnPropDesc(module32, key)) || desc.enumerable });
      }
      return target;
    };
    var __toModule = (module32) => {
      return __reExport(__markAsModule(__defProp2(module32 != null ? __create(__getProtoOf(module32)) : {}, "default", module32 && module32.__esModule && "default" in module32 ? { get: () => module32.default, enumerable: true } : { value: module32, enumerable: true })), module32);
    };
    __export(exports2, {
      css: () => css,
      entry: () => entry,
      js: () => js,
      module: () => module2
    });
    var module2 = __toModule(require_error_svelte());
    var entry = "error.svelte-d6011770.js";
    var js = ["error.svelte-d6011770.js", "chunks/vendor-1860a60a.js"];
    var css = [];
  }
});

// node_modules/@sindresorhus/is/dist/index.js
var require_dist = __commonJS({
  "node_modules/@sindresorhus/is/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typedArrayTypeNames = [
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
    function isTypedArrayName(name) {
      return typedArrayTypeNames.includes(name);
    }
    var objectTypeNames = [
      "Function",
      "Generator",
      "AsyncGenerator",
      "GeneratorFunction",
      "AsyncGeneratorFunction",
      "AsyncFunction",
      "Observable",
      "Array",
      "Buffer",
      "Object",
      "RegExp",
      "Date",
      "Error",
      "Map",
      "Set",
      "WeakMap",
      "WeakSet",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "DataView",
      "Promise",
      "URL",
      "FormData",
      "URLSearchParams",
      "HTMLElement",
      ...typedArrayTypeNames
    ];
    function isObjectTypeName(name) {
      return objectTypeNames.includes(name);
    }
    var primitiveTypeNames = [
      "null",
      "undefined",
      "string",
      "number",
      "bigint",
      "boolean",
      "symbol"
    ];
    function isPrimitiveTypeName(name) {
      return primitiveTypeNames.includes(name);
    }
    function isOfType(type) {
      return (value) => typeof value === type;
    }
    var { toString } = Object.prototype;
    var getObjectType = (value) => {
      const objectTypeName = toString.call(value).slice(8, -1);
      if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value)) {
        return "HTMLElement";
      }
      if (isObjectTypeName(objectTypeName)) {
        return objectTypeName;
      }
      return void 0;
    };
    var isObjectOfType = (type) => (value) => getObjectType(value) === type;
    function is(value) {
      if (value === null) {
        return "null";
      }
      switch (typeof value) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return "number";
        case "boolean":
          return "boolean";
        case "function":
          return "Function";
        case "bigint":
          return "bigint";
        case "symbol":
          return "symbol";
        default:
      }
      if (is.observable(value)) {
        return "Observable";
      }
      if (is.array(value)) {
        return "Array";
      }
      if (is.buffer(value)) {
        return "Buffer";
      }
      const tagType = getObjectType(value);
      if (tagType) {
        return tagType;
      }
      if (value instanceof String || value instanceof Boolean || value instanceof Number) {
        throw new TypeError("Please don't use object wrappers for primitive types");
      }
      return "Object";
    }
    is.undefined = isOfType("undefined");
    is.string = isOfType("string");
    var isNumberType = isOfType("number");
    is.number = (value) => isNumberType(value) && !is.nan(value);
    is.bigint = isOfType("bigint");
    is.function_ = isOfType("function");
    is.null_ = (value) => value === null;
    is.class_ = (value) => is.function_(value) && value.toString().startsWith("class ");
    is.boolean = (value) => value === true || value === false;
    is.symbol = isOfType("symbol");
    is.numericString = (value) => is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
    is.array = (value, assertion) => {
      if (!Array.isArray(value)) {
        return false;
      }
      if (!is.function_(assertion)) {
        return true;
      }
      return value.every(assertion);
    };
    is.buffer = (value) => {
      var _a, _b, _c, _d;
      return (_d = (_c = (_b = (_a = value) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.isBuffer) === null || _c === void 0 ? void 0 : _c.call(_b, value)) !== null && _d !== void 0 ? _d : false;
    };
    is.nullOrUndefined = (value) => is.null_(value) || is.undefined(value);
    is.object = (value) => !is.null_(value) && (typeof value === "object" || is.function_(value));
    is.iterable = (value) => {
      var _a;
      return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.iterator]);
    };
    is.asyncIterable = (value) => {
      var _a;
      return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.asyncIterator]);
    };
    is.generator = (value) => {
      var _a, _b;
      return is.iterable(value) && is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.next) && is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.throw);
    };
    is.asyncGenerator = (value) => is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
    is.nativePromise = (value) => isObjectOfType("Promise")(value);
    var hasPromiseAPI = (value) => {
      var _a, _b;
      return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.then) && is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.catch);
    };
    is.promise = (value) => is.nativePromise(value) || hasPromiseAPI(value);
    is.generatorFunction = isObjectOfType("GeneratorFunction");
    is.asyncGeneratorFunction = (value) => getObjectType(value) === "AsyncGeneratorFunction";
    is.asyncFunction = (value) => getObjectType(value) === "AsyncFunction";
    is.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty("prototype");
    is.regExp = isObjectOfType("RegExp");
    is.date = isObjectOfType("Date");
    is.error = isObjectOfType("Error");
    is.map = (value) => isObjectOfType("Map")(value);
    is.set = (value) => isObjectOfType("Set")(value);
    is.weakMap = (value) => isObjectOfType("WeakMap")(value);
    is.weakSet = (value) => isObjectOfType("WeakSet")(value);
    is.int8Array = isObjectOfType("Int8Array");
    is.uint8Array = isObjectOfType("Uint8Array");
    is.uint8ClampedArray = isObjectOfType("Uint8ClampedArray");
    is.int16Array = isObjectOfType("Int16Array");
    is.uint16Array = isObjectOfType("Uint16Array");
    is.int32Array = isObjectOfType("Int32Array");
    is.uint32Array = isObjectOfType("Uint32Array");
    is.float32Array = isObjectOfType("Float32Array");
    is.float64Array = isObjectOfType("Float64Array");
    is.bigInt64Array = isObjectOfType("BigInt64Array");
    is.bigUint64Array = isObjectOfType("BigUint64Array");
    is.arrayBuffer = isObjectOfType("ArrayBuffer");
    is.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer");
    is.dataView = isObjectOfType("DataView");
    is.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
    is.urlInstance = (value) => isObjectOfType("URL")(value);
    is.urlString = (value) => {
      if (!is.string(value)) {
        return false;
      }
      try {
        new URL(value);
        return true;
      } catch (_a) {
        return false;
      }
    };
    is.truthy = (value) => Boolean(value);
    is.falsy = (value) => !value;
    is.nan = (value) => Number.isNaN(value);
    is.primitive = (value) => is.null_(value) || isPrimitiveTypeName(typeof value);
    is.integer = (value) => Number.isInteger(value);
    is.safeInteger = (value) => Number.isSafeInteger(value);
    is.plainObject = (value) => {
      if (toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.getPrototypeOf({});
    };
    is.typedArray = (value) => isTypedArrayName(getObjectType(value));
    var isValidLength = (value) => is.safeInteger(value) && value >= 0;
    is.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
    is.inRange = (value, range) => {
      if (is.number(range)) {
        return value >= Math.min(0, range) && value <= Math.max(range, 0);
      }
      if (is.array(range) && range.length === 2) {
        return value >= Math.min(...range) && value <= Math.max(...range);
      }
      throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
    };
    var NODE_TYPE_ELEMENT = 1;
    var DOM_PROPERTIES_TO_CHECK = [
      "innerHTML",
      "ownerDocument",
      "style",
      "attributes",
      "nodeValue"
    ];
    is.domElement = (value) => {
      return is.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is.string(value.nodeName) && !is.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every((property) => property in value);
    };
    is.observable = (value) => {
      var _a, _b, _c, _d;
      if (!value) {
        return false;
      }
      if (value === ((_b = (_a = value)[Symbol.observable]) === null || _b === void 0 ? void 0 : _b.call(_a))) {
        return true;
      }
      if (value === ((_d = (_c = value)["@@observable"]) === null || _d === void 0 ? void 0 : _d.call(_c))) {
        return true;
      }
      return false;
    };
    is.nodeStream = (value) => is.object(value) && is.function_(value.pipe) && !is.observable(value);
    is.infinite = (value) => value === Infinity || value === -Infinity;
    var isAbsoluteMod2 = (remainder) => (value) => is.integer(value) && Math.abs(value % 2) === remainder;
    is.evenInteger = isAbsoluteMod2(0);
    is.oddInteger = isAbsoluteMod2(1);
    is.emptyArray = (value) => is.array(value) && value.length === 0;
    is.nonEmptyArray = (value) => is.array(value) && value.length > 0;
    is.emptyString = (value) => is.string(value) && value.length === 0;
    is.nonEmptyString = (value) => is.string(value) && value.length > 0;
    var isWhiteSpaceString = (value) => is.string(value) && !/\S/.test(value);
    is.emptyStringOrWhitespace = (value) => is.emptyString(value) || isWhiteSpaceString(value);
    is.emptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
    is.nonEmptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
    is.emptySet = (value) => is.set(value) && value.size === 0;
    is.nonEmptySet = (value) => is.set(value) && value.size > 0;
    is.emptyMap = (value) => is.map(value) && value.size === 0;
    is.nonEmptyMap = (value) => is.map(value) && value.size > 0;
    is.propertyKey = (value) => is.any([is.string, is.number, is.symbol], value);
    is.formData = (value) => isObjectOfType("FormData")(value);
    is.urlSearchParams = (value) => isObjectOfType("URLSearchParams")(value);
    var predicateOnArray = (method, predicate, values) => {
      if (!is.function_(predicate)) {
        throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
      }
      if (values.length === 0) {
        throw new TypeError("Invalid number of values");
      }
      return method.call(values, predicate);
    };
    is.any = (predicate, ...values) => {
      const predicates = is.array(predicate) ? predicate : [predicate];
      return predicates.some((singlePredicate) => predicateOnArray(Array.prototype.some, singlePredicate, values));
    };
    is.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);
    var assertType = (condition, description, value, options = {}) => {
      if (!condition) {
        const { multipleValues } = options;
        const valuesMessage = multipleValues ? `received values of types ${[
          ...new Set(value.map((singleValue) => `\`${is(singleValue)}\``))
        ].join(", ")}` : `received value of type \`${is(value)}\``;
        throw new TypeError(`Expected value which is \`${description}\`, ${valuesMessage}.`);
      }
    };
    exports2.assert = {
      undefined: (value) => assertType(is.undefined(value), "undefined", value),
      string: (value) => assertType(is.string(value), "string", value),
      number: (value) => assertType(is.number(value), "number", value),
      bigint: (value) => assertType(is.bigint(value), "bigint", value),
      function_: (value) => assertType(is.function_(value), "Function", value),
      null_: (value) => assertType(is.null_(value), "null", value),
      class_: (value) => assertType(is.class_(value), "Class", value),
      boolean: (value) => assertType(is.boolean(value), "boolean", value),
      symbol: (value) => assertType(is.symbol(value), "symbol", value),
      numericString: (value) => assertType(is.numericString(value), "string with a number", value),
      array: (value, assertion) => {
        const assert = assertType;
        assert(is.array(value), "Array", value);
        if (assertion) {
          value.forEach(assertion);
        }
      },
      buffer: (value) => assertType(is.buffer(value), "Buffer", value),
      nullOrUndefined: (value) => assertType(is.nullOrUndefined(value), "null or undefined", value),
      object: (value) => assertType(is.object(value), "Object", value),
      iterable: (value) => assertType(is.iterable(value), "Iterable", value),
      asyncIterable: (value) => assertType(is.asyncIterable(value), "AsyncIterable", value),
      generator: (value) => assertType(is.generator(value), "Generator", value),
      asyncGenerator: (value) => assertType(is.asyncGenerator(value), "AsyncGenerator", value),
      nativePromise: (value) => assertType(is.nativePromise(value), "native Promise", value),
      promise: (value) => assertType(is.promise(value), "Promise", value),
      generatorFunction: (value) => assertType(is.generatorFunction(value), "GeneratorFunction", value),
      asyncGeneratorFunction: (value) => assertType(is.asyncGeneratorFunction(value), "AsyncGeneratorFunction", value),
      asyncFunction: (value) => assertType(is.asyncFunction(value), "AsyncFunction", value),
      boundFunction: (value) => assertType(is.boundFunction(value), "Function", value),
      regExp: (value) => assertType(is.regExp(value), "RegExp", value),
      date: (value) => assertType(is.date(value), "Date", value),
      error: (value) => assertType(is.error(value), "Error", value),
      map: (value) => assertType(is.map(value), "Map", value),
      set: (value) => assertType(is.set(value), "Set", value),
      weakMap: (value) => assertType(is.weakMap(value), "WeakMap", value),
      weakSet: (value) => assertType(is.weakSet(value), "WeakSet", value),
      int8Array: (value) => assertType(is.int8Array(value), "Int8Array", value),
      uint8Array: (value) => assertType(is.uint8Array(value), "Uint8Array", value),
      uint8ClampedArray: (value) => assertType(is.uint8ClampedArray(value), "Uint8ClampedArray", value),
      int16Array: (value) => assertType(is.int16Array(value), "Int16Array", value),
      uint16Array: (value) => assertType(is.uint16Array(value), "Uint16Array", value),
      int32Array: (value) => assertType(is.int32Array(value), "Int32Array", value),
      uint32Array: (value) => assertType(is.uint32Array(value), "Uint32Array", value),
      float32Array: (value) => assertType(is.float32Array(value), "Float32Array", value),
      float64Array: (value) => assertType(is.float64Array(value), "Float64Array", value),
      bigInt64Array: (value) => assertType(is.bigInt64Array(value), "BigInt64Array", value),
      bigUint64Array: (value) => assertType(is.bigUint64Array(value), "BigUint64Array", value),
      arrayBuffer: (value) => assertType(is.arrayBuffer(value), "ArrayBuffer", value),
      sharedArrayBuffer: (value) => assertType(is.sharedArrayBuffer(value), "SharedArrayBuffer", value),
      dataView: (value) => assertType(is.dataView(value), "DataView", value),
      urlInstance: (value) => assertType(is.urlInstance(value), "URL", value),
      urlString: (value) => assertType(is.urlString(value), "string with a URL", value),
      truthy: (value) => assertType(is.truthy(value), "truthy", value),
      falsy: (value) => assertType(is.falsy(value), "falsy", value),
      nan: (value) => assertType(is.nan(value), "NaN", value),
      primitive: (value) => assertType(is.primitive(value), "primitive", value),
      integer: (value) => assertType(is.integer(value), "integer", value),
      safeInteger: (value) => assertType(is.safeInteger(value), "integer", value),
      plainObject: (value) => assertType(is.plainObject(value), "plain object", value),
      typedArray: (value) => assertType(is.typedArray(value), "TypedArray", value),
      arrayLike: (value) => assertType(is.arrayLike(value), "array-like", value),
      domElement: (value) => assertType(is.domElement(value), "HTMLElement", value),
      observable: (value) => assertType(is.observable(value), "Observable", value),
      nodeStream: (value) => assertType(is.nodeStream(value), "Node.js Stream", value),
      infinite: (value) => assertType(is.infinite(value), "infinite number", value),
      emptyArray: (value) => assertType(is.emptyArray(value), "empty array", value),
      nonEmptyArray: (value) => assertType(is.nonEmptyArray(value), "non-empty array", value),
      emptyString: (value) => assertType(is.emptyString(value), "empty string", value),
      nonEmptyString: (value) => assertType(is.nonEmptyString(value), "non-empty string", value),
      emptyStringOrWhitespace: (value) => assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace", value),
      emptyObject: (value) => assertType(is.emptyObject(value), "empty object", value),
      nonEmptyObject: (value) => assertType(is.nonEmptyObject(value), "non-empty object", value),
      emptySet: (value) => assertType(is.emptySet(value), "empty set", value),
      nonEmptySet: (value) => assertType(is.nonEmptySet(value), "non-empty set", value),
      emptyMap: (value) => assertType(is.emptyMap(value), "empty map", value),
      nonEmptyMap: (value) => assertType(is.nonEmptyMap(value), "non-empty map", value),
      propertyKey: (value) => assertType(is.propertyKey(value), "PropertyKey", value),
      formData: (value) => assertType(is.formData(value), "FormData", value),
      urlSearchParams: (value) => assertType(is.urlSearchParams(value), "URLSearchParams", value),
      evenInteger: (value) => assertType(is.evenInteger(value), "even integer", value),
      oddInteger: (value) => assertType(is.oddInteger(value), "odd integer", value),
      directInstanceOf: (instance, class_) => assertType(is.directInstanceOf(instance, class_), "T", instance),
      inRange: (value, range) => assertType(is.inRange(value, range), "in range", value),
      any: (predicate, ...values) => {
        return assertType(is.any(predicate, ...values), "predicate returns truthy for any value", values, { multipleValues: true });
      },
      all: (predicate, ...values) => assertType(is.all(predicate, ...values), "predicate returns truthy for all values", values, { multipleValues: true })
    };
    Object.defineProperties(is, {
      class: {
        value: is.class_
      },
      function: {
        value: is.function_
      },
      null: {
        value: is.null_
      }
    });
    Object.defineProperties(exports2.assert, {
      class: {
        value: exports2.assert.class_
      },
      function: {
        value: exports2.assert.function_
      },
      null: {
        value: exports2.assert.null_
      }
    });
    exports2.default = is;
    module2.exports = is;
    module2.exports.default = is;
    module2.exports.assert = exports2.assert;
  }
});

// node_modules/p-cancelable/index.js
var require_p_cancelable = __commonJS({
  "node_modules/p-cancelable/index.js"(exports2, module2) {
    "use strict";
    var CancelError = class extends Error {
      constructor(reason) {
        super(reason || "Promise was canceled");
        this.name = "CancelError";
      }
      get isCanceled() {
        return true;
      }
    };
    var PCancelable = class {
      static fn(userFn) {
        return (...arguments_) => {
          return new PCancelable((resolve, reject, onCancel) => {
            arguments_.push(onCancel);
            userFn(...arguments_).then(resolve, reject);
          });
        };
      }
      constructor(executor) {
        this._cancelHandlers = [];
        this._isPending = true;
        this._isCanceled = false;
        this._rejectOnCancel = true;
        this._promise = new Promise((resolve, reject) => {
          this._reject = reject;
          const onResolve = (value) => {
            if (!this._isCanceled || !onCancel.shouldReject) {
              this._isPending = false;
              resolve(value);
            }
          };
          const onReject = (error) => {
            this._isPending = false;
            reject(error);
          };
          const onCancel = (handler) => {
            if (!this._isPending) {
              throw new Error("The `onCancel` handler was attached after the promise settled.");
            }
            this._cancelHandlers.push(handler);
          };
          Object.defineProperties(onCancel, {
            shouldReject: {
              get: () => this._rejectOnCancel,
              set: (boolean) => {
                this._rejectOnCancel = boolean;
              }
            }
          });
          return executor(onResolve, onReject, onCancel);
        });
      }
      then(onFulfilled, onRejected) {
        return this._promise.then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this._promise.catch(onRejected);
      }
      finally(onFinally) {
        return this._promise.finally(onFinally);
      }
      cancel(reason) {
        if (!this._isPending || this._isCanceled) {
          return;
        }
        this._isCanceled = true;
        if (this._cancelHandlers.length > 0) {
          try {
            for (const handler of this._cancelHandlers) {
              handler();
            }
          } catch (error) {
            this._reject(error);
            return;
          }
        }
        if (this._rejectOnCancel) {
          this._reject(new CancelError(reason));
        }
      }
      get isCanceled() {
        return this._isCanceled;
      }
    };
    Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);
    module2.exports = PCancelable;
    module2.exports.CancelError = CancelError;
  }
});

// node_modules/defer-to-connect/dist/source/index.js
var require_source = __commonJS({
  "node_modules/defer-to-connect/dist/source/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isTLSSocket(socket) {
      return socket.encrypted;
    }
    var deferToConnect = (socket, fn) => {
      let listeners;
      if (typeof fn === "function") {
        const connect = fn;
        listeners = { connect };
      } else {
        listeners = fn;
      }
      const hasConnectListener = typeof listeners.connect === "function";
      const hasSecureConnectListener = typeof listeners.secureConnect === "function";
      const hasCloseListener = typeof listeners.close === "function";
      const onConnect = () => {
        if (hasConnectListener) {
          listeners.connect();
        }
        if (isTLSSocket(socket) && hasSecureConnectListener) {
          if (socket.authorized) {
            listeners.secureConnect();
          } else if (!socket.authorizationError) {
            socket.once("secureConnect", listeners.secureConnect);
          }
        }
        if (hasCloseListener) {
          socket.once("close", listeners.close);
        }
      };
      if (socket.writable && !socket.connecting) {
        onConnect();
      } else if (socket.connecting) {
        socket.once("connect", onConnect);
      } else if (socket.destroyed && hasCloseListener) {
        listeners.close(socket._hadError);
      }
    };
    exports2.default = deferToConnect;
    module2.exports = deferToConnect;
    module2.exports.default = deferToConnect;
  }
});

// node_modules/@szmarczak/http-timer/dist/source/index.js
var require_source2 = __commonJS({
  "node_modules/@szmarczak/http-timer/dist/source/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var defer_to_connect_1 = require_source();
    var util_1 = require("util");
    var nodejsMajorVersion = Number(process.versions.node.split(".")[0]);
    var timer = (request) => {
      if (request.timings) {
        return request.timings;
      }
      const timings = {
        start: Date.now(),
        socket: void 0,
        lookup: void 0,
        connect: void 0,
        secureConnect: void 0,
        upload: void 0,
        response: void 0,
        end: void 0,
        error: void 0,
        abort: void 0,
        phases: {
          wait: void 0,
          dns: void 0,
          tcp: void 0,
          tls: void 0,
          request: void 0,
          firstByte: void 0,
          download: void 0,
          total: void 0
        }
      };
      request.timings = timings;
      const handleError = (origin) => {
        const emit = origin.emit.bind(origin);
        origin.emit = (event, ...args) => {
          if (event === "error") {
            timings.error = Date.now();
            timings.phases.total = timings.error - timings.start;
            origin.emit = emit;
          }
          return emit(event, ...args);
        };
      };
      handleError(request);
      const onAbort = () => {
        timings.abort = Date.now();
        if (!timings.response || nodejsMajorVersion >= 13) {
          timings.phases.total = Date.now() - timings.start;
        }
      };
      request.prependOnceListener("abort", onAbort);
      const onSocket = (socket) => {
        timings.socket = Date.now();
        timings.phases.wait = timings.socket - timings.start;
        if (util_1.types.isProxy(socket)) {
          return;
        }
        const lookupListener = () => {
          timings.lookup = Date.now();
          timings.phases.dns = timings.lookup - timings.socket;
        };
        socket.prependOnceListener("lookup", lookupListener);
        defer_to_connect_1.default(socket, {
          connect: () => {
            timings.connect = Date.now();
            if (timings.lookup === void 0) {
              socket.removeListener("lookup", lookupListener);
              timings.lookup = timings.connect;
              timings.phases.dns = timings.lookup - timings.socket;
            }
            timings.phases.tcp = timings.connect - timings.lookup;
          },
          secureConnect: () => {
            timings.secureConnect = Date.now();
            timings.phases.tls = timings.secureConnect - timings.connect;
          }
        });
      };
      if (request.socket) {
        onSocket(request.socket);
      } else {
        request.prependOnceListener("socket", onSocket);
      }
      const onUpload = () => {
        var _a;
        timings.upload = Date.now();
        timings.phases.request = timings.upload - ((_a = timings.secureConnect) !== null && _a !== void 0 ? _a : timings.connect);
      };
      const writableFinished = () => {
        if (typeof request.writableFinished === "boolean") {
          return request.writableFinished;
        }
        return request.finished && request.outputSize === 0 && (!request.socket || request.socket.writableLength === 0);
      };
      if (writableFinished()) {
        onUpload();
      } else {
        request.prependOnceListener("finish", onUpload);
      }
      request.prependOnceListener("response", (response) => {
        timings.response = Date.now();
        timings.phases.firstByte = timings.response - timings.upload;
        response.timings = timings;
        handleError(response);
        response.prependOnceListener("end", () => {
          timings.end = Date.now();
          timings.phases.download = timings.end - timings.response;
          timings.phases.total = timings.end - timings.start;
        });
        response.prependOnceListener("aborted", onAbort);
      });
      return timings;
    };
    exports2.default = timer;
    module2.exports = timer;
    module2.exports.default = timer;
  }
});

// node_modules/cacheable-lookup/source/index.js
var require_source3 = __commonJS({
  "node_modules/cacheable-lookup/source/index.js"(exports2, module2) {
    "use strict";
    var {
      V4MAPPED,
      ADDRCONFIG,
      ALL,
      promises: {
        Resolver: AsyncResolver
      },
      lookup: dnsLookup
    } = require("dns");
    var { promisify } = require("util");
    var os = require("os");
    var kCacheableLookupCreateConnection = Symbol("cacheableLookupCreateConnection");
    var kCacheableLookupInstance = Symbol("cacheableLookupInstance");
    var kExpires = Symbol("expires");
    var supportsALL = typeof ALL === "number";
    var verifyAgent = (agent) => {
      if (!(agent && typeof agent.createConnection === "function")) {
        throw new Error("Expected an Agent instance as the first argument");
      }
    };
    var map4to6 = (entries) => {
      for (const entry of entries) {
        if (entry.family === 6) {
          continue;
        }
        entry.address = `::ffff:${entry.address}`;
        entry.family = 6;
      }
    };
    var getIfaceInfo = () => {
      let has4 = false;
      let has6 = false;
      for (const device of Object.values(os.networkInterfaces())) {
        for (const iface of device) {
          if (iface.internal) {
            continue;
          }
          if (iface.family === "IPv6") {
            has6 = true;
          } else {
            has4 = true;
          }
          if (has4 && has6) {
            return { has4, has6 };
          }
        }
      }
      return { has4, has6 };
    };
    var isIterable = (map) => {
      return Symbol.iterator in map;
    };
    var ttl = { ttl: true };
    var all = { all: true };
    var CacheableLookup = class {
      constructor({
        cache = new Map(),
        maxTtl = Infinity,
        fallbackDuration = 3600,
        errorTtl = 0.15,
        resolver = new AsyncResolver(),
        lookup = dnsLookup
      } = {}) {
        this.maxTtl = maxTtl;
        this.errorTtl = errorTtl;
        this._cache = cache;
        this._resolver = resolver;
        this._dnsLookup = promisify(lookup);
        if (this._resolver instanceof AsyncResolver) {
          this._resolve4 = this._resolver.resolve4.bind(this._resolver);
          this._resolve6 = this._resolver.resolve6.bind(this._resolver);
        } else {
          this._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));
          this._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));
        }
        this._iface = getIfaceInfo();
        this._pending = {};
        this._nextRemovalTime = false;
        this._hostnamesToFallback = new Set();
        if (fallbackDuration < 1) {
          this._fallback = false;
        } else {
          this._fallback = true;
          const interval = setInterval(() => {
            this._hostnamesToFallback.clear();
          }, fallbackDuration * 1e3);
          if (interval.unref) {
            interval.unref();
          }
        }
        this.lookup = this.lookup.bind(this);
        this.lookupAsync = this.lookupAsync.bind(this);
      }
      set servers(servers) {
        this.clear();
        this._resolver.setServers(servers);
      }
      get servers() {
        return this._resolver.getServers();
      }
      lookup(hostname, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        } else if (typeof options === "number") {
          options = {
            family: options
          };
        }
        if (!callback) {
          throw new Error("Callback must be a function.");
        }
        this.lookupAsync(hostname, options).then((result) => {
          if (options.all) {
            callback(null, result);
          } else {
            callback(null, result.address, result.family, result.expires, result.ttl);
          }
        }, callback);
      }
      async lookupAsync(hostname, options = {}) {
        if (typeof options === "number") {
          options = {
            family: options
          };
        }
        let cached = await this.query(hostname);
        if (options.family === 6) {
          const filtered = cached.filter((entry) => entry.family === 6);
          if (options.hints & V4MAPPED) {
            if (supportsALL && options.hints & ALL || filtered.length === 0) {
              map4to6(cached);
            } else {
              cached = filtered;
            }
          } else {
            cached = filtered;
          }
        } else if (options.family === 4) {
          cached = cached.filter((entry) => entry.family === 4);
        }
        if (options.hints & ADDRCONFIG) {
          const { _iface } = this;
          cached = cached.filter((entry) => entry.family === 6 ? _iface.has6 : _iface.has4);
        }
        if (cached.length === 0) {
          const error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);
          error.code = "ENOTFOUND";
          error.hostname = hostname;
          throw error;
        }
        if (options.all) {
          return cached;
        }
        return cached[0];
      }
      async query(hostname) {
        let cached = await this._cache.get(hostname);
        if (!cached) {
          const pending = this._pending[hostname];
          if (pending) {
            cached = await pending;
          } else {
            const newPromise = this.queryAndCache(hostname);
            this._pending[hostname] = newPromise;
            try {
              cached = await newPromise;
            } finally {
              delete this._pending[hostname];
            }
          }
        }
        cached = cached.map((entry) => {
          return __spreadValues({}, entry);
        });
        return cached;
      }
      async _resolve(hostname) {
        const wrap = async (promise) => {
          try {
            return await promise;
          } catch (error) {
            if (error.code === "ENODATA" || error.code === "ENOTFOUND") {
              return [];
            }
            throw error;
          }
        };
        const [A, AAAA] = await Promise.all([
          this._resolve4(hostname, ttl),
          this._resolve6(hostname, ttl)
        ].map((promise) => wrap(promise)));
        let aTtl = 0;
        let aaaaTtl = 0;
        let cacheTtl = 0;
        const now = Date.now();
        for (const entry of A) {
          entry.family = 4;
          entry.expires = now + entry.ttl * 1e3;
          aTtl = Math.max(aTtl, entry.ttl);
        }
        for (const entry of AAAA) {
          entry.family = 6;
          entry.expires = now + entry.ttl * 1e3;
          aaaaTtl = Math.max(aaaaTtl, entry.ttl);
        }
        if (A.length > 0) {
          if (AAAA.length > 0) {
            cacheTtl = Math.min(aTtl, aaaaTtl);
          } else {
            cacheTtl = aTtl;
          }
        } else {
          cacheTtl = aaaaTtl;
        }
        return {
          entries: [
            ...A,
            ...AAAA
          ],
          cacheTtl
        };
      }
      async _lookup(hostname) {
        try {
          const entries = await this._dnsLookup(hostname, {
            all: true
          });
          return {
            entries,
            cacheTtl: 0
          };
        } catch (_) {
          return {
            entries: [],
            cacheTtl: 0
          };
        }
      }
      async _set(hostname, data, cacheTtl) {
        if (this.maxTtl > 0 && cacheTtl > 0) {
          cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1e3;
          data[kExpires] = Date.now() + cacheTtl;
          try {
            await this._cache.set(hostname, data, cacheTtl);
          } catch (error) {
            this.lookupAsync = async () => {
              const cacheError = new Error("Cache Error. Please recreate the CacheableLookup instance.");
              cacheError.cause = error;
              throw cacheError;
            };
          }
          if (isIterable(this._cache)) {
            this._tick(cacheTtl);
          }
        }
      }
      async queryAndCache(hostname) {
        if (this._hostnamesToFallback.has(hostname)) {
          return this._dnsLookup(hostname, all);
        }
        let query = await this._resolve(hostname);
        if (query.entries.length === 0 && this._fallback) {
          query = await this._lookup(hostname);
          if (query.entries.length !== 0) {
            this._hostnamesToFallback.add(hostname);
          }
        }
        const cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;
        await this._set(hostname, query.entries, cacheTtl);
        return query.entries;
      }
      _tick(ms) {
        const nextRemovalTime = this._nextRemovalTime;
        if (!nextRemovalTime || ms < nextRemovalTime) {
          clearTimeout(this._removalTimeout);
          this._nextRemovalTime = ms;
          this._removalTimeout = setTimeout(() => {
            this._nextRemovalTime = false;
            let nextExpiry = Infinity;
            const now = Date.now();
            for (const [hostname, entries] of this._cache) {
              const expires = entries[kExpires];
              if (now >= expires) {
                this._cache.delete(hostname);
              } else if (expires < nextExpiry) {
                nextExpiry = expires;
              }
            }
            if (nextExpiry !== Infinity) {
              this._tick(nextExpiry - now);
            }
          }, ms);
          if (this._removalTimeout.unref) {
            this._removalTimeout.unref();
          }
        }
      }
      install(agent) {
        verifyAgent(agent);
        if (kCacheableLookupCreateConnection in agent) {
          throw new Error("CacheableLookup has been already installed");
        }
        agent[kCacheableLookupCreateConnection] = agent.createConnection;
        agent[kCacheableLookupInstance] = this;
        agent.createConnection = (options, callback) => {
          if (!("lookup" in options)) {
            options.lookup = this.lookup;
          }
          return agent[kCacheableLookupCreateConnection](options, callback);
        };
      }
      uninstall(agent) {
        verifyAgent(agent);
        if (agent[kCacheableLookupCreateConnection]) {
          if (agent[kCacheableLookupInstance] !== this) {
            throw new Error("The agent is not owned by this CacheableLookup instance");
          }
          agent.createConnection = agent[kCacheableLookupCreateConnection];
          delete agent[kCacheableLookupCreateConnection];
          delete agent[kCacheableLookupInstance];
        }
      }
      updateInterfaceInfo() {
        const { _iface } = this;
        this._iface = getIfaceInfo();
        if (_iface.has4 && !this._iface.has4 || _iface.has6 && !this._iface.has6) {
          this._cache.clear();
        }
      }
      clear(hostname) {
        if (hostname) {
          this._cache.delete(hostname);
          return;
        }
        this._cache.clear();
      }
    };
    module2.exports = CacheableLookup;
    module2.exports.default = CacheableLookup;
  }
});

// node_modules/normalize-url/index.js
var require_normalize_url = __commonJS({
  "node_modules/normalize-url/index.js"(exports2, module2) {
    "use strict";
    var DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
    var DATA_URL_DEFAULT_CHARSET = "us-ascii";
    var testParameter = (name, filters) => {
      return filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);
    };
    var normalizeDataURL = (urlString, { stripHash }) => {
      const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);
      if (!match) {
        throw new Error(`Invalid URL: ${urlString}`);
      }
      let { type, data, hash } = match.groups;
      const mediaType = type.split(";");
      hash = stripHash ? "" : hash;
      let isBase64 = false;
      if (mediaType[mediaType.length - 1] === "base64") {
        mediaType.pop();
        isBase64 = true;
      }
      const mimeType = (mediaType.shift() || "").toLowerCase();
      const attributes = mediaType.map((attribute) => {
        let [key, value = ""] = attribute.split("=").map((string) => string.trim());
        if (key === "charset") {
          value = value.toLowerCase();
          if (value === DATA_URL_DEFAULT_CHARSET) {
            return "";
          }
        }
        return `${key}${value ? `=${value}` : ""}`;
      }).filter(Boolean);
      const normalizedMediaType = [
        ...attributes
      ];
      if (isBase64) {
        normalizedMediaType.push("base64");
      }
      if (normalizedMediaType.length !== 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
        normalizedMediaType.unshift(mimeType);
      }
      return `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ""}`;
    };
    var normalizeUrl = (urlString, options) => {
      options = __spreadValues({
        defaultProtocol: "http:",
        normalizeProtocol: true,
        forceHttp: false,
        forceHttps: false,
        stripAuthentication: true,
        stripHash: false,
        stripTextFragment: true,
        stripWWW: true,
        removeQueryParameters: [/^utm_\w+/i],
        removeTrailingSlash: true,
        removeSingleSlash: true,
        removeDirectoryIndex: false,
        sortQueryParameters: true
      }, options);
      urlString = urlString.trim();
      if (/^data:/i.test(urlString)) {
        return normalizeDataURL(urlString, options);
      }
      if (/^view-source:/i.test(urlString)) {
        throw new Error("`view-source:` is not supported as it is a non-standard protocol");
      }
      const hasRelativeProtocol = urlString.startsWith("//");
      const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);
      if (!isRelativeUrl) {
        urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
      }
      const urlObj = new URL(urlString);
      if (options.forceHttp && options.forceHttps) {
        throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
      }
      if (options.forceHttp && urlObj.protocol === "https:") {
        urlObj.protocol = "http:";
      }
      if (options.forceHttps && urlObj.protocol === "http:") {
        urlObj.protocol = "https:";
      }
      if (options.stripAuthentication) {
        urlObj.username = "";
        urlObj.password = "";
      }
      if (options.stripHash) {
        urlObj.hash = "";
      } else if (options.stripTextFragment) {
        urlObj.hash = urlObj.hash.replace(/#?:~:text.*?$/i, "");
      }
      if (urlObj.pathname) {
        urlObj.pathname = urlObj.pathname.replace(/(?<!\b(?:[a-z][a-z\d+\-.]{1,50}:))\/{2,}/g, "/");
      }
      if (urlObj.pathname) {
        try {
          urlObj.pathname = decodeURI(urlObj.pathname);
        } catch (_) {
        }
      }
      if (options.removeDirectoryIndex === true) {
        options.removeDirectoryIndex = [/^index\.[a-z]+$/];
      }
      if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
        let pathComponents = urlObj.pathname.split("/");
        const lastComponent = pathComponents[pathComponents.length - 1];
        if (testParameter(lastComponent, options.removeDirectoryIndex)) {
          pathComponents = pathComponents.slice(0, pathComponents.length - 1);
          urlObj.pathname = pathComponents.slice(1).join("/") + "/";
        }
      }
      if (urlObj.hostname) {
        urlObj.hostname = urlObj.hostname.replace(/\.$/, "");
        if (options.stripWWW && /^www\.(?!www\.)(?:[a-z\-\d]{1,63})\.(?:[a-z.\-\d]{2,63})$/.test(urlObj.hostname)) {
          urlObj.hostname = urlObj.hostname.replace(/^www\./, "");
        }
      }
      if (Array.isArray(options.removeQueryParameters)) {
        for (const key of [...urlObj.searchParams.keys()]) {
          if (testParameter(key, options.removeQueryParameters)) {
            urlObj.searchParams.delete(key);
          }
        }
      }
      if (options.removeQueryParameters === true) {
        urlObj.search = "";
      }
      if (options.sortQueryParameters) {
        urlObj.searchParams.sort();
      }
      if (options.removeTrailingSlash) {
        urlObj.pathname = urlObj.pathname.replace(/\/$/, "");
      }
      const oldUrlString = urlString;
      urlString = urlObj.toString();
      if (!options.removeSingleSlash && urlObj.pathname === "/" && !oldUrlString.endsWith("/") && urlObj.hash === "") {
        urlString = urlString.replace(/\/$/, "");
      }
      if ((options.removeTrailingSlash || urlObj.pathname === "/") && urlObj.hash === "" && options.removeSingleSlash) {
        urlString = urlString.replace(/\/$/, "");
      }
      if (hasRelativeProtocol && !options.normalizeProtocol) {
        urlString = urlString.replace(/^http:\/\//, "//");
      }
      if (options.stripProtocol) {
        urlString = urlString.replace(/^(?:https?:)?\/\//, "");
      }
      return urlString;
    };
    module2.exports = normalizeUrl;
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS({
  "node_modules/end-of-stream/index.js"(exports2, module2) {
    var once = require_once();
    var noop = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled)
          return;
        if (readable && !(rs && (rs.ended && !rs.destroyed)))
          return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed)))
          return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module2.exports = eos;
  }
});

// node_modules/pump/index.js
var require_pump = __commonJS({
  "node_modules/pump/index.js"(exports2, module2) {
    var once = require_once();
    var eos = require_end_of_stream();
    var fs = require("fs");
    var noop = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream) {
      if (!ancient)
        return false;
      if (!fs)
        return false;
      return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
    };
    var isRequest = function(stream) {
      return stream.setHeader && isFn(stream.abort);
    };
    var destroyer = function(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      eos(stream, { readable: reading, writable: writing }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isFS(stream))
          return stream.close(noop);
        if (isRequest(stream))
          return stream.abort();
        if (isFn(stream.destroy))
          return stream.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe = function(from, to) {
      return from.pipe(to);
    };
    var pump = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new Error("pump requires two streams per minimum");
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    };
    module2.exports = pump;
  }
});

// node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var { PassThrough: PassThroughStream } = require("stream");
    module2.exports = (options) => {
      options = __spreadValues({}, options);
      const { array } = options;
      let { encoding } = options;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream = new PassThroughStream({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream.getBufferedLength = () => length;
      return stream;
    };
  }
});

// node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var { constants: BufferConstants } = require("buffer");
    var pump = require_pump();
    var bufferStream = require_buffer_stream();
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream(inputStream, options) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      options = __spreadValues({
        maxBuffer: Infinity
      }, options);
      const { maxBuffer } = options;
      let stream;
      await new Promise((resolve, reject) => {
        const rejectPromise = (error) => {
          if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error.bufferedData = stream.getBufferedValue();
          }
          reject(error);
        };
        stream = pump(inputStream, bufferStream(options), (error) => {
          if (error) {
            rejectPromise(error);
            return;
          }
          resolve();
        });
        stream.on("data", () => {
          if (stream.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream.getBufferedValue();
    }
    module2.exports = getStream;
    module2.exports.default = getStream;
    module2.exports.buffer = (stream, options) => getStream(stream, __spreadProps(__spreadValues({}, options), { encoding: "buffer" }));
    module2.exports.array = (stream, options) => getStream(stream, __spreadProps(__spreadValues({}, options), { array: true }));
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// node_modules/http-cache-semantics/index.js
var require_http_cache_semantics = __commonJS({
  "node_modules/http-cache-semantics/index.js"(exports2, module2) {
    "use strict";
    var statusCodeCacheableByDefault = new Set([
      200,
      203,
      204,
      206,
      300,
      301,
      404,
      405,
      410,
      414,
      501
    ]);
    var understoodStatuses = new Set([
      200,
      203,
      204,
      300,
      301,
      302,
      303,
      307,
      308,
      404,
      405,
      410,
      414,
      501
    ]);
    var errorStatusCodes = new Set([
      500,
      502,
      503,
      504
    ]);
    var hopByHopHeaders = {
      date: true,
      connection: true,
      "keep-alive": true,
      "proxy-authenticate": true,
      "proxy-authorization": true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true
    };
    var excludedFromRevalidationUpdate = {
      "content-length": true,
      "content-encoding": true,
      "transfer-encoding": true,
      "content-range": true
    };
    function toNumberOrZero(s) {
      const n = parseInt(s, 10);
      return isFinite(n) ? n : 0;
    }
    function isErrorResponse(response) {
      if (!response) {
        return true;
      }
      return errorStatusCodes.has(response.status);
    }
    function parseCacheControl(header) {
      const cc = {};
      if (!header)
        return cc;
      const parts = header.trim().split(/\s*,\s*/);
      for (const part of parts) {
        const [k, v] = part.split(/\s*=\s*/, 2);
        cc[k] = v === void 0 ? true : v.replace(/^"|"$/g, "");
      }
      return cc;
    }
    function formatCacheControl(cc) {
      let parts = [];
      for (const k in cc) {
        const v = cc[k];
        parts.push(v === true ? k : k + "=" + v);
      }
      if (!parts.length) {
        return void 0;
      }
      return parts.join(", ");
    }
    module2.exports = class CachePolicy {
      constructor(req, res, {
        shared,
        cacheHeuristic,
        immutableMinTimeToLive,
        ignoreCargoCult,
        _fromObject
      } = {}) {
        if (_fromObject) {
          this._fromObject(_fromObject);
          return;
        }
        if (!res || !res.headers) {
          throw Error("Response headers missing");
        }
        this._assertRequestHasHeaders(req);
        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._cacheHeuristic = cacheHeuristic !== void 0 ? cacheHeuristic : 0.1;
        this._immutableMinTtl = immutableMinTimeToLive !== void 0 ? immutableMinTimeToLive : 24 * 3600 * 1e3;
        this._status = "status" in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = parseCacheControl(res.headers["cache-control"]);
        this._method = "method" in req ? req.method : "GET";
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null;
        this._reqcc = parseCacheControl(req.headers["cache-control"]);
        if (ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc) {
          delete this._rescc["pre-check"];
          delete this._rescc["post-check"];
          delete this._rescc["no-cache"];
          delete this._rescc["no-store"];
          delete this._rescc["must-revalidate"];
          this._resHeaders = Object.assign({}, this._resHeaders, {
            "cache-control": formatCacheControl(this._rescc)
          });
          delete this._resHeaders.expires;
          delete this._resHeaders.pragma;
        }
        if (res.headers["cache-control"] == null && /no-cache/.test(res.headers.pragma)) {
          this._rescc["no-cache"] = true;
        }
      }
      now() {
        return Date.now();
      }
      storable() {
        return !!(!this._reqcc["no-store"] && (this._method === "GET" || this._method === "HEAD" || this._method === "POST" && this._hasExplicitExpiration()) && understoodStatuses.has(this._status) && !this._rescc["no-store"] && (!this._isShared || !this._rescc.private) && (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && (this._resHeaders.expires || this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || statusCodeCacheableByDefault.has(this._status)));
      }
      _hasExplicitExpiration() {
        return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires;
      }
      _assertRequestHasHeaders(req) {
        if (!req || !req.headers) {
          throw Error("Request headers missing");
        }
      }
      satisfiesWithoutRevalidation(req) {
        this._assertRequestHasHeaders(req);
        const requestCC = parseCacheControl(req.headers["cache-control"]);
        if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) {
          return false;
        }
        if (requestCC["max-age"] && this.age() > requestCC["max-age"]) {
          return false;
        }
        if (requestCC["min-fresh"] && this.timeToLive() < 1e3 * requestCC["min-fresh"]) {
          return false;
        }
        if (this.stale()) {
          const allowsStale = requestCC["max-stale"] && !this._rescc["must-revalidate"] && (requestCC["max-stale"] === true || requestCC["max-stale"] > this.age() - this.maxAge());
          if (!allowsStale) {
            return false;
          }
        }
        return this._requestMatches(req, false);
      }
      _requestMatches(req, allowHeadMethod) {
        return (!this._url || this._url === req.url) && this._host === req.headers.host && (!req.method || this._method === req.method || allowHeadMethod && req.method === "HEAD") && this._varyMatches(req);
      }
      _allowsStoringAuthenticated() {
        return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"];
      }
      _varyMatches(req) {
        if (!this._resHeaders.vary) {
          return true;
        }
        if (this._resHeaders.vary === "*") {
          return false;
        }
        const fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
        for (const name of fields) {
          if (req.headers[name] !== this._reqHeaders[name])
            return false;
        }
        return true;
      }
      _copyWithoutHopByHopHeaders(inHeaders) {
        const headers = {};
        for (const name in inHeaders) {
          if (hopByHopHeaders[name])
            continue;
          headers[name] = inHeaders[name];
        }
        if (inHeaders.connection) {
          const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
          for (const name of tokens) {
            delete headers[name];
          }
        }
        if (headers.warning) {
          const warnings = headers.warning.split(/,/).filter((warning) => {
            return !/^\s*1[0-9][0-9]/.test(warning);
          });
          if (!warnings.length) {
            delete headers.warning;
          } else {
            headers.warning = warnings.join(",").trim();
          }
        }
        return headers;
      }
      responseHeaders() {
        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        const age = this.age();
        if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {
          headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"';
        }
        headers.age = `${Math.round(age)}`;
        headers.date = new Date(this.now()).toUTCString();
        return headers;
      }
      date() {
        const serverDate = Date.parse(this._resHeaders.date);
        if (isFinite(serverDate)) {
          return serverDate;
        }
        return this._responseTime;
      }
      age() {
        let age = this._ageValue();
        const residentTime = (this.now() - this._responseTime) / 1e3;
        return age + residentTime;
      }
      _ageValue() {
        return toNumberOrZero(this._resHeaders.age);
      }
      maxAge() {
        if (!this.storable() || this._rescc["no-cache"]) {
          return 0;
        }
        if (this._isShared && (this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable)) {
          return 0;
        }
        if (this._resHeaders.vary === "*") {
          return 0;
        }
        if (this._isShared) {
          if (this._rescc["proxy-revalidate"]) {
            return 0;
          }
          if (this._rescc["s-maxage"]) {
            return toNumberOrZero(this._rescc["s-maxage"]);
          }
        }
        if (this._rescc["max-age"]) {
          return toNumberOrZero(this._rescc["max-age"]);
        }
        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;
        const serverDate = this.date();
        if (this._resHeaders.expires) {
          const expires = Date.parse(this._resHeaders.expires);
          if (Number.isNaN(expires) || expires < serverDate) {
            return 0;
          }
          return Math.max(defaultMinTtl, (expires - serverDate) / 1e3);
        }
        if (this._resHeaders["last-modified"]) {
          const lastModified = Date.parse(this._resHeaders["last-modified"]);
          if (isFinite(lastModified) && serverDate > lastModified) {
            return Math.max(defaultMinTtl, (serverDate - lastModified) / 1e3 * this._cacheHeuristic);
          }
        }
        return defaultMinTtl;
      }
      timeToLive() {
        const age = this.maxAge() - this.age();
        const staleIfErrorAge = age + toNumberOrZero(this._rescc["stale-if-error"]);
        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc["stale-while-revalidate"]);
        return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1e3;
      }
      stale() {
        return this.maxAge() <= this.age();
      }
      _useStaleIfError() {
        return this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) > this.age();
      }
      useStaleWhileRevalidate() {
        return this.maxAge() + toNumberOrZero(this._rescc["stale-while-revalidate"]) > this.age();
      }
      static fromObject(obj) {
        return new this(void 0, void 0, { _fromObject: obj });
      }
      _fromObject(obj) {
        if (this._responseTime)
          throw Error("Reinitialized");
        if (!obj || obj.v !== 1)
          throw Error("Invalid serialization");
        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl = obj.imm !== void 0 ? obj.imm : 24 * 3600 * 1e3;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
      }
      toObject() {
        return {
          v: 1,
          t: this._responseTime,
          sh: this._isShared,
          ch: this._cacheHeuristic,
          imm: this._immutableMinTtl,
          st: this._status,
          resh: this._resHeaders,
          rescc: this._rescc,
          m: this._method,
          u: this._url,
          h: this._host,
          a: this._noAuthorization,
          reqh: this._reqHeaders,
          reqcc: this._reqcc
        };
      }
      revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
        delete headers["if-range"];
        if (!this._requestMatches(incomingReq, true) || !this.storable()) {
          delete headers["if-none-match"];
          delete headers["if-modified-since"];
          return headers;
        }
        if (this._resHeaders.etag) {
          headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag;
        }
        const forbidsWeakValidators = headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET";
        if (forbidsWeakValidators) {
          delete headers["if-modified-since"];
          if (headers["if-none-match"]) {
            const etags = headers["if-none-match"].split(/,/).filter((etag) => {
              return !/^\s*W\//.test(etag);
            });
            if (!etags.length) {
              delete headers["if-none-match"];
            } else {
              headers["if-none-match"] = etags.join(",").trim();
            }
          }
        } else if (this._resHeaders["last-modified"] && !headers["if-modified-since"]) {
          headers["if-modified-since"] = this._resHeaders["last-modified"];
        }
        return headers;
      }
      revalidatedPolicy(request, response) {
        this._assertRequestHasHeaders(request);
        if (this._useStaleIfError() && isErrorResponse(response)) {
          return {
            modified: false,
            matches: false,
            policy: this
          };
        }
        if (!response || !response.headers) {
          throw Error("Response headers missing");
        }
        let matches = false;
        if (response.status !== void 0 && response.status != 304) {
          matches = false;
        } else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) {
          matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag;
        } else if (this._resHeaders.etag && response.headers.etag) {
          matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "");
        } else if (this._resHeaders["last-modified"]) {
          matches = this._resHeaders["last-modified"] === response.headers["last-modified"];
        } else {
          if (!this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"]) {
            matches = true;
          }
        }
        if (!matches) {
          return {
            policy: new this.constructor(request, response),
            modified: response.status != 304,
            matches: false
          };
        }
        const headers = {};
        for (const k in this._resHeaders) {
          headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
        }
        const newResponse = Object.assign({}, response, {
          status: this._status,
          method: this._method,
          headers
        });
        return {
          policy: new this.constructor(request, newResponse, {
            shared: this._isShared,
            cacheHeuristic: this._cacheHeuristic,
            immutableMinTimeToLive: this._immutableMinTtl
          }),
          modified: false,
          matches: true
        };
      }
    };
  }
});

// node_modules/lowercase-keys/index.js
var require_lowercase_keys = __commonJS({
  "node_modules/lowercase-keys/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (object) => {
      const result = {};
      for (const [key, value] of Object.entries(object)) {
        result[key.toLowerCase()] = value;
      }
      return result;
    };
  }
});

// node_modules/responselike/src/index.js
var require_src = __commonJS({
  "node_modules/responselike/src/index.js"(exports2, module2) {
    "use strict";
    var Readable = require("stream").Readable;
    var lowercaseKeys = require_lowercase_keys();
    var Response2 = class extends Readable {
      constructor(statusCode, headers, body, url) {
        if (typeof statusCode !== "number") {
          throw new TypeError("Argument `statusCode` should be a number");
        }
        if (typeof headers !== "object") {
          throw new TypeError("Argument `headers` should be an object");
        }
        if (!(body instanceof Buffer)) {
          throw new TypeError("Argument `body` should be a buffer");
        }
        if (typeof url !== "string") {
          throw new TypeError("Argument `url` should be a string");
        }
        super();
        this.statusCode = statusCode;
        this.headers = lowercaseKeys(headers);
        this.body = body;
        this.url = url;
      }
      _read() {
        this.push(this.body);
        this.push(null);
      }
    };
    module2.exports = Response2;
  }
});

// node_modules/mimic-response/index.js
var require_mimic_response = __commonJS({
  "node_modules/mimic-response/index.js"(exports2, module2) {
    "use strict";
    var knownProps = [
      "destroy",
      "setTimeout",
      "socket",
      "headers",
      "trailers",
      "rawHeaders",
      "statusCode",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "rawTrailers",
      "statusMessage"
    ];
    module2.exports = (fromStream, toStream) => {
      const fromProps = new Set(Object.keys(fromStream).concat(knownProps));
      for (const prop of fromProps) {
        if (prop in toStream) {
          continue;
        }
        toStream[prop] = typeof fromStream[prop] === "function" ? fromStream[prop].bind(fromStream) : fromStream[prop];
      }
    };
  }
});

// node_modules/clone-response/src/index.js
var require_src2 = __commonJS({
  "node_modules/clone-response/src/index.js"(exports2, module2) {
    "use strict";
    var PassThrough = require("stream").PassThrough;
    var mimicResponse = require_mimic_response();
    var cloneResponse = (response) => {
      if (!(response && response.pipe)) {
        throw new TypeError("Parameter `response` must be a response stream.");
      }
      const clone = new PassThrough();
      mimicResponse(response, clone);
      return response.pipe(clone);
    };
    module2.exports = cloneResponse;
  }
});

// node_modules/json-buffer/index.js
var require_json_buffer = __commonJS({
  "node_modules/json-buffer/index.js"(exports2) {
    exports2.stringify = function stringify(o) {
      if (typeof o == "undefined")
        return o;
      if (o && Buffer.isBuffer(o))
        return JSON.stringify(":base64:" + o.toString("base64"));
      if (o && o.toJSON)
        o = o.toJSON();
      if (o && typeof o === "object") {
        var s = "";
        var array = Array.isArray(o);
        s = array ? "[" : "{";
        var first = true;
        for (var k in o) {
          var ignore = typeof o[k] == "function" || !array && typeof o[k] === "undefined";
          if (Object.hasOwnProperty.call(o, k) && !ignore) {
            if (!first)
              s += ",";
            first = false;
            if (array) {
              if (o[k] == void 0)
                s += "null";
              else
                s += stringify(o[k]);
            } else if (o[k] !== void 0) {
              s += stringify(k) + ":" + stringify(o[k]);
            }
          }
        }
        s += array ? "]" : "}";
        return s;
      } else if (typeof o === "string") {
        return JSON.stringify(/^:/.test(o) ? ":" + o : o);
      } else if (typeof o === "undefined") {
        return "null";
      } else
        return JSON.stringify(o);
    };
    exports2.parse = function(s) {
      return JSON.parse(s, function(key, value) {
        if (typeof value === "string") {
          if (/^:base64:/.test(value))
            return Buffer.from(value.substring(8), "base64");
          else
            return /^:/.test(value) ? value.substring(1) : value;
        }
        return value;
      });
    };
  }
});

// node_modules/keyv/src/index.js
var require_src3 = __commonJS({
  "node_modules/keyv/src/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var JSONB = require_json_buffer();
    var loadStore = (options) => {
      const adapters = {
        redis: "@keyv/redis",
        mongodb: "@keyv/mongo",
        mongo: "@keyv/mongo",
        sqlite: "@keyv/sqlite",
        postgresql: "@keyv/postgres",
        postgres: "@keyv/postgres",
        mysql: "@keyv/mysql"
      };
      if (options.adapter || options.uri) {
        const adapter = options.adapter || /^[^:]*/.exec(options.uri)[0];
        return new (require(adapters[adapter]))(options);
      }
      return new Map();
    };
    var Keyv = class extends EventEmitter {
      constructor(uri, options) {
        super();
        this.opts = Object.assign({
          namespace: "keyv",
          serialize: JSONB.stringify,
          deserialize: JSONB.parse
        }, typeof uri === "string" ? { uri } : uri, options);
        if (!this.opts.store) {
          const adapterOptions = Object.assign({}, this.opts);
          this.opts.store = loadStore(adapterOptions);
        }
        if (typeof this.opts.store.on === "function") {
          this.opts.store.on("error", (error) => this.emit("error", error));
        }
        this.opts.store.namespace = this.opts.namespace;
      }
      _getKeyPrefix(key) {
        return `${this.opts.namespace}:${key}`;
      }
      get(key, options) {
        const keyPrefixed = this._getKeyPrefix(key);
        const { store } = this.opts;
        return Promise.resolve().then(() => store.get(keyPrefixed)).then((data) => typeof data === "string" ? this.opts.deserialize(data) : data).then((data) => {
          if (data === void 0) {
            return void 0;
          }
          if (typeof data.expires === "number" && Date.now() > data.expires) {
            this.delete(key);
            return void 0;
          }
          return options && options.raw ? data : data.value;
        });
      }
      set(key, value, ttl) {
        const keyPrefixed = this._getKeyPrefix(key);
        if (typeof ttl === "undefined") {
          ttl = this.opts.ttl;
        }
        if (ttl === 0) {
          ttl = void 0;
        }
        const { store } = this.opts;
        return Promise.resolve().then(() => {
          const expires = typeof ttl === "number" ? Date.now() + ttl : null;
          value = { value, expires };
          return this.opts.serialize(value);
        }).then((value2) => store.set(keyPrefixed, value2, ttl)).then(() => true);
      }
      delete(key) {
        const keyPrefixed = this._getKeyPrefix(key);
        const { store } = this.opts;
        return Promise.resolve().then(() => store.delete(keyPrefixed));
      }
      clear() {
        const { store } = this.opts;
        return Promise.resolve().then(() => store.clear());
      }
    };
    module2.exports = Keyv;
  }
});

// node_modules/cacheable-request/src/index.js
var require_src4 = __commonJS({
  "node_modules/cacheable-request/src/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var urlLib = require("url");
    var normalizeUrl = require_normalize_url();
    var getStream = require_get_stream();
    var CachePolicy = require_http_cache_semantics();
    var Response2 = require_src();
    var lowercaseKeys = require_lowercase_keys();
    var cloneResponse = require_src2();
    var Keyv = require_src3();
    var CacheableRequest = class {
      constructor(request, cacheAdapter) {
        if (typeof request !== "function") {
          throw new TypeError("Parameter `request` must be a function");
        }
        this.cache = new Keyv({
          uri: typeof cacheAdapter === "string" && cacheAdapter,
          store: typeof cacheAdapter !== "string" && cacheAdapter,
          namespace: "cacheable-request"
        });
        return this.createCacheableRequest(request);
      }
      createCacheableRequest(request) {
        return (opts, cb) => {
          let url;
          if (typeof opts === "string") {
            url = normalizeUrlObject(urlLib.parse(opts));
            opts = {};
          } else if (opts instanceof urlLib.URL) {
            url = normalizeUrlObject(urlLib.parse(opts.toString()));
            opts = {};
          } else {
            const [pathname, ...searchParts] = (opts.path || "").split("?");
            const search = searchParts.length > 0 ? `?${searchParts.join("?")}` : "";
            url = normalizeUrlObject(__spreadProps(__spreadValues({}, opts), { pathname, search }));
          }
          opts = __spreadValues(__spreadValues({
            headers: {},
            method: "GET",
            cache: true,
            strictTtl: false,
            automaticFailover: false
          }, opts), urlObjectToRequestOptions(url));
          opts.headers = lowercaseKeys(opts.headers);
          const ee = new EventEmitter();
          const normalizedUrlString = normalizeUrl(urlLib.format(url), {
            stripWWW: false,
            removeTrailingSlash: false,
            stripAuthentication: false
          });
          const key = `${opts.method}:${normalizedUrlString}`;
          let revalidate = false;
          let madeRequest = false;
          const makeRequest = (opts2) => {
            madeRequest = true;
            let requestErrored = false;
            let requestErrorCallback;
            const requestErrorPromise = new Promise((resolve) => {
              requestErrorCallback = () => {
                if (!requestErrored) {
                  requestErrored = true;
                  resolve();
                }
              };
            });
            const handler = (response) => {
              if (revalidate && !opts2.forceRefresh) {
                response.status = response.statusCode;
                const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts2, response);
                if (!revalidatedPolicy.modified) {
                  const headers = revalidatedPolicy.policy.responseHeaders();
                  response = new Response2(revalidate.statusCode, headers, revalidate.body, revalidate.url);
                  response.cachePolicy = revalidatedPolicy.policy;
                  response.fromCache = true;
                }
              }
              if (!response.fromCache) {
                response.cachePolicy = new CachePolicy(opts2, response, opts2);
                response.fromCache = false;
              }
              let clonedResponse;
              if (opts2.cache && response.cachePolicy.storable()) {
                clonedResponse = cloneResponse(response);
                (async () => {
                  try {
                    const bodyPromise = getStream.buffer(response);
                    await Promise.race([
                      requestErrorPromise,
                      new Promise((resolve) => response.once("end", resolve))
                    ]);
                    if (requestErrored) {
                      return;
                    }
                    const body = await bodyPromise;
                    const value = {
                      cachePolicy: response.cachePolicy.toObject(),
                      url: response.url,
                      statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                      body
                    };
                    let ttl = opts2.strictTtl ? response.cachePolicy.timeToLive() : void 0;
                    if (opts2.maxTtl) {
                      ttl = ttl ? Math.min(ttl, opts2.maxTtl) : opts2.maxTtl;
                    }
                    await this.cache.set(key, value, ttl);
                  } catch (error) {
                    ee.emit("error", new CacheableRequest.CacheError(error));
                  }
                })();
              } else if (opts2.cache && revalidate) {
                (async () => {
                  try {
                    await this.cache.delete(key);
                  } catch (error) {
                    ee.emit("error", new CacheableRequest.CacheError(error));
                  }
                })();
              }
              ee.emit("response", clonedResponse || response);
              if (typeof cb === "function") {
                cb(clonedResponse || response);
              }
            };
            try {
              const req = request(opts2, handler);
              req.once("error", requestErrorCallback);
              req.once("abort", requestErrorCallback);
              ee.emit("request", req);
            } catch (error) {
              ee.emit("error", new CacheableRequest.RequestError(error));
            }
          };
          (async () => {
            const get = async (opts2) => {
              await Promise.resolve();
              const cacheEntry = opts2.cache ? await this.cache.get(key) : void 0;
              if (typeof cacheEntry === "undefined") {
                return makeRequest(opts2);
              }
              const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);
              if (policy.satisfiesWithoutRevalidation(opts2) && !opts2.forceRefresh) {
                const headers = policy.responseHeaders();
                const response = new Response2(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
                response.cachePolicy = policy;
                response.fromCache = true;
                ee.emit("response", response);
                if (typeof cb === "function") {
                  cb(response);
                }
              } else {
                revalidate = cacheEntry;
                opts2.headers = policy.revalidationHeaders(opts2);
                makeRequest(opts2);
              }
            };
            const errorHandler = (error) => ee.emit("error", new CacheableRequest.CacheError(error));
            this.cache.once("error", errorHandler);
            ee.on("response", () => this.cache.removeListener("error", errorHandler));
            try {
              await get(opts);
            } catch (error) {
              if (opts.automaticFailover && !madeRequest) {
                makeRequest(opts);
              }
              ee.emit("error", new CacheableRequest.CacheError(error));
            }
          })();
          return ee;
        };
      }
    };
    function urlObjectToRequestOptions(url) {
      const options = __spreadValues({}, url);
      options.path = `${url.pathname || "/"}${url.search || ""}`;
      delete options.pathname;
      delete options.search;
      return options;
    }
    function normalizeUrlObject(url) {
      return {
        protocol: url.protocol,
        auth: url.auth,
        hostname: url.hostname || url.host || "localhost",
        port: url.port,
        pathname: url.pathname,
        search: url.search
      };
    }
    CacheableRequest.RequestError = class extends Error {
      constructor(error) {
        super(error.message);
        this.name = "RequestError";
        Object.assign(this, error);
      }
    };
    CacheableRequest.CacheError = class extends Error {
      constructor(error) {
        super(error.message);
        this.name = "CacheError";
        Object.assign(this, error);
      }
    };
    module2.exports = CacheableRequest;
  }
});

// node_modules/decompress-response/node_modules/mimic-response/index.js
var require_mimic_response2 = __commonJS({
  "node_modules/decompress-response/node_modules/mimic-response/index.js"(exports2, module2) {
    "use strict";
    var knownProperties = [
      "aborted",
      "complete",
      "headers",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "method",
      "rawHeaders",
      "rawTrailers",
      "setTimeout",
      "socket",
      "statusCode",
      "statusMessage",
      "trailers",
      "url"
    ];
    module2.exports = (fromStream, toStream) => {
      if (toStream._readableState.autoDestroy) {
        throw new Error("The second stream must have the `autoDestroy` option set to `false`");
      }
      const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));
      const properties = {};
      for (const property of fromProperties) {
        if (property in toStream) {
          continue;
        }
        properties[property] = {
          get() {
            const value = fromStream[property];
            const isFunction = typeof value === "function";
            return isFunction ? value.bind(fromStream) : value;
          },
          set(value) {
            fromStream[property] = value;
          },
          enumerable: true,
          configurable: false
        };
      }
      Object.defineProperties(toStream, properties);
      fromStream.once("aborted", () => {
        toStream.destroy();
        toStream.emit("aborted");
      });
      fromStream.once("close", () => {
        if (fromStream.complete) {
          if (toStream.readable) {
            toStream.once("end", () => {
              toStream.emit("close");
            });
          } else {
            toStream.emit("close");
          }
        } else {
          toStream.emit("close");
        }
      });
      return toStream;
    };
  }
});

// node_modules/decompress-response/index.js
var require_decompress_response = __commonJS({
  "node_modules/decompress-response/index.js"(exports2, module2) {
    "use strict";
    var { Transform, PassThrough } = require("stream");
    var zlib = require("zlib");
    var mimicResponse = require_mimic_response2();
    module2.exports = (response) => {
      const contentEncoding = (response.headers["content-encoding"] || "").toLowerCase();
      if (!["gzip", "deflate", "br"].includes(contentEncoding)) {
        return response;
      }
      const isBrotli = contentEncoding === "br";
      if (isBrotli && typeof zlib.createBrotliDecompress !== "function") {
        response.destroy(new Error("Brotli is not supported on Node.js < 12"));
        return response;
      }
      let isEmpty = true;
      const checker = new Transform({
        transform(data, _encoding, callback) {
          isEmpty = false;
          callback(null, data);
        },
        flush(callback) {
          callback();
        }
      });
      const finalStream = new PassThrough({
        autoDestroy: false,
        destroy(error, callback) {
          response.destroy();
          callback(error);
        }
      });
      const decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();
      decompressStream.once("error", (error) => {
        if (isEmpty && !response.readable) {
          finalStream.end();
          return;
        }
        finalStream.destroy(error);
      });
      mimicResponse(response, finalStream);
      response.pipe(checker).pipe(decompressStream).pipe(finalStream);
      return finalStream;
    };
  }
});

// node_modules/quick-lru/index.js
var require_quick_lru = __commonJS({
  "node_modules/quick-lru/index.js"(exports2, module2) {
    "use strict";
    var QuickLRU = class {
      constructor(options = {}) {
        if (!(options.maxSize && options.maxSize > 0)) {
          throw new TypeError("`maxSize` must be a number greater than 0");
        }
        this.maxSize = options.maxSize;
        this.onEviction = options.onEviction;
        this.cache = new Map();
        this.oldCache = new Map();
        this._size = 0;
      }
      _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
          this._size = 0;
          if (typeof this.onEviction === "function") {
            for (const [key2, value2] of this.oldCache.entries()) {
              this.onEviction(key2, value2);
            }
          }
          this.oldCache = this.cache;
          this.cache = new Map();
        }
      }
      get(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          const value = this.oldCache.get(key);
          this.oldCache.delete(key);
          this._set(key, value);
          return value;
        }
      }
      set(key, value) {
        if (this.cache.has(key)) {
          this.cache.set(key, value);
        } else {
          this._set(key, value);
        }
        return this;
      }
      has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
      }
      peek(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          return this.oldCache.get(key);
        }
      }
      delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
          this._size--;
        }
        return this.oldCache.delete(key) || deleted;
      }
      clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
      }
      *keys() {
        for (const [key] of this) {
          yield key;
        }
      }
      *values() {
        for (const [, value] of this) {
          yield value;
        }
      }
      *[Symbol.iterator]() {
        for (const item of this.cache) {
          yield item;
        }
        for (const item of this.oldCache) {
          const [key] = item;
          if (!this.cache.has(key)) {
            yield item;
          }
        }
      }
      get size() {
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()) {
          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
        return Math.min(this._size + oldCacheSize, this.maxSize);
      }
    };
    module2.exports = QuickLRU;
  }
});

// node_modules/http2-wrapper/source/agent.js
var require_agent = __commonJS({
  "node_modules/http2-wrapper/source/agent.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var tls = require("tls");
    var http2 = require("http2");
    var QuickLRU = require_quick_lru();
    var kCurrentStreamsCount = Symbol("currentStreamsCount");
    var kRequest = Symbol("request");
    var kOriginSet = Symbol("cachedOriginSet");
    var kGracefullyClosing = Symbol("gracefullyClosing");
    var nameKeys = [
      "maxDeflateDynamicTableSize",
      "maxSessionMemory",
      "maxHeaderListPairs",
      "maxOutstandingPings",
      "maxReservedRemoteStreams",
      "maxSendHeaderBlockLength",
      "paddingStrategy",
      "localAddress",
      "path",
      "rejectUnauthorized",
      "minDHSize",
      "ca",
      "cert",
      "clientCertEngine",
      "ciphers",
      "key",
      "pfx",
      "servername",
      "minVersion",
      "maxVersion",
      "secureProtocol",
      "crl",
      "honorCipherOrder",
      "ecdhCurve",
      "dhparam",
      "secureOptions",
      "sessionIdContext"
    ];
    var getSortedIndex = (array, value, compare) => {
      let low = 0;
      let high = array.length;
      while (low < high) {
        const mid = low + high >>> 1;
        if (compare(array[mid], value)) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return low;
    };
    var compareSessions = (a, b) => {
      return a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;
    };
    var closeCoveredSessions = (where, session) => {
      for (const coveredSession of where) {
        if (coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {
          gracefullyClose(coveredSession);
        }
      }
    };
    var closeSessionIfCovered = (where, coveredSession) => {
      for (const session of where) {
        if (coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {
          gracefullyClose(coveredSession);
        }
      }
    };
    var getSessions = ({ agent, isFree }) => {
      const result = {};
      for (const normalizedOptions in agent.sessions) {
        const sessions = agent.sessions[normalizedOptions];
        const filtered = sessions.filter((session) => {
          const result2 = session[Agent.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;
          return isFree ? result2 : !result2;
        });
        if (filtered.length !== 0) {
          result[normalizedOptions] = filtered;
        }
      }
      return result;
    };
    var gracefullyClose = (session) => {
      session[kGracefullyClosing] = true;
      if (session[kCurrentStreamsCount] === 0) {
        session.close();
      }
    };
    var Agent = class extends EventEmitter {
      constructor({ timeout = 6e4, maxSessions = Infinity, maxFreeSessions = 10, maxCachedTlsSessions = 100 } = {}) {
        super();
        this.sessions = {};
        this.queue = {};
        this.timeout = timeout;
        this.maxSessions = maxSessions;
        this.maxFreeSessions = maxFreeSessions;
        this._freeSessionsCount = 0;
        this._sessionsCount = 0;
        this.settings = {
          enablePush: false
        };
        this.tlsSessionCache = new QuickLRU({ maxSize: maxCachedTlsSessions });
      }
      static normalizeOrigin(url, servername) {
        if (typeof url === "string") {
          url = new URL(url);
        }
        if (servername && url.hostname !== servername) {
          url.hostname = servername;
        }
        return url.origin;
      }
      normalizeOptions(options) {
        let normalized = "";
        if (options) {
          for (const key of nameKeys) {
            if (options[key]) {
              normalized += `:${options[key]}`;
            }
          }
        }
        return normalized;
      }
      _tryToCreateNewSession(normalizedOptions, normalizedOrigin) {
        if (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {
          return;
        }
        const item = this.queue[normalizedOptions][normalizedOrigin];
        if (this._sessionsCount < this.maxSessions && !item.completed) {
          item.completed = true;
          item();
        }
      }
      getSession(origin, options, listeners) {
        return new Promise((resolve, reject) => {
          if (Array.isArray(listeners)) {
            listeners = [...listeners];
            resolve();
          } else {
            listeners = [{ resolve, reject }];
          }
          const normalizedOptions = this.normalizeOptions(options);
          const normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);
          if (normalizedOrigin === void 0) {
            for (const { reject: reject2 } of listeners) {
              reject2(new TypeError("The `origin` argument needs to be a string or an URL object"));
            }
            return;
          }
          if (normalizedOptions in this.sessions) {
            const sessions = this.sessions[normalizedOptions];
            let maxConcurrentStreams = -1;
            let currentStreamsCount = -1;
            let optimalSession;
            for (const session of sessions) {
              const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;
              if (sessionMaxConcurrentStreams < maxConcurrentStreams) {
                break;
              }
              if (session[kOriginSet].includes(normalizedOrigin)) {
                const sessionCurrentStreamsCount = session[kCurrentStreamsCount];
                if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] || session.destroyed) {
                  continue;
                }
                if (!optimalSession) {
                  maxConcurrentStreams = sessionMaxConcurrentStreams;
                }
                if (sessionCurrentStreamsCount > currentStreamsCount) {
                  optimalSession = session;
                  currentStreamsCount = sessionCurrentStreamsCount;
                }
              }
            }
            if (optimalSession) {
              if (listeners.length !== 1) {
                for (const { reject: reject2 } of listeners) {
                  const error = new Error(`Expected the length of listeners to be 1, got ${listeners.length}.
Please report this to https://github.com/szmarczak/http2-wrapper/`);
                  reject2(error);
                }
                return;
              }
              listeners[0].resolve(optimalSession);
              return;
            }
          }
          if (normalizedOptions in this.queue) {
            if (normalizedOrigin in this.queue[normalizedOptions]) {
              this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);
              this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
              return;
            }
          } else {
            this.queue[normalizedOptions] = {};
          }
          const removeFromQueue = () => {
            if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {
              delete this.queue[normalizedOptions][normalizedOrigin];
              if (Object.keys(this.queue[normalizedOptions]).length === 0) {
                delete this.queue[normalizedOptions];
              }
            }
          };
          const entry = () => {
            const name = `${normalizedOrigin}:${normalizedOptions}`;
            let receivedSettings = false;
            try {
              const session = http2.connect(origin, __spreadValues({
                createConnection: this.createConnection,
                settings: this.settings,
                session: this.tlsSessionCache.get(name)
              }, options));
              session[kCurrentStreamsCount] = 0;
              session[kGracefullyClosing] = false;
              const isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;
              let wasFree = true;
              session.socket.once("session", (tlsSession) => {
                this.tlsSessionCache.set(name, tlsSession);
              });
              session.once("error", (error) => {
                for (const { reject: reject2 } of listeners) {
                  reject2(error);
                }
                this.tlsSessionCache.delete(name);
              });
              session.setTimeout(this.timeout, () => {
                session.destroy();
              });
              session.once("close", () => {
                if (receivedSettings) {
                  if (wasFree) {
                    this._freeSessionsCount--;
                  }
                  this._sessionsCount--;
                  const where = this.sessions[normalizedOptions];
                  where.splice(where.indexOf(session), 1);
                  if (where.length === 0) {
                    delete this.sessions[normalizedOptions];
                  }
                } else {
                  const error = new Error("Session closed without receiving a SETTINGS frame");
                  error.code = "HTTP2WRAPPER_NOSETTINGS";
                  for (const { reject: reject2 } of listeners) {
                    reject2(error);
                  }
                  removeFromQueue();
                }
                this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
              });
              const processListeners = () => {
                if (!(normalizedOptions in this.queue) || !isFree()) {
                  return;
                }
                for (const origin2 of session[kOriginSet]) {
                  if (origin2 in this.queue[normalizedOptions]) {
                    const { listeners: listeners2 } = this.queue[normalizedOptions][origin2];
                    while (listeners2.length !== 0 && isFree()) {
                      listeners2.shift().resolve(session);
                    }
                    const where = this.queue[normalizedOptions];
                    if (where[origin2].listeners.length === 0) {
                      delete where[origin2];
                      if (Object.keys(where).length === 0) {
                        delete this.queue[normalizedOptions];
                        break;
                      }
                    }
                    if (!isFree()) {
                      break;
                    }
                  }
                }
              };
              session.on("origin", () => {
                session[kOriginSet] = session.originSet;
                if (!isFree()) {
                  return;
                }
                processListeners();
                closeCoveredSessions(this.sessions[normalizedOptions], session);
              });
              session.once("remoteSettings", () => {
                session.ref();
                session.unref();
                this._sessionsCount++;
                if (entry.destroyed) {
                  const error = new Error("Agent has been destroyed");
                  for (const listener of listeners) {
                    listener.reject(error);
                  }
                  session.destroy();
                  return;
                }
                session[kOriginSet] = session.originSet;
                {
                  const where = this.sessions;
                  if (normalizedOptions in where) {
                    const sessions = where[normalizedOptions];
                    sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);
                  } else {
                    where[normalizedOptions] = [session];
                  }
                }
                this._freeSessionsCount += 1;
                receivedSettings = true;
                this.emit("session", session);
                processListeners();
                removeFromQueue();
                if (session[kCurrentStreamsCount] === 0 && this._freeSessionsCount > this.maxFreeSessions) {
                  session.close();
                }
                if (listeners.length !== 0) {
                  this.getSession(normalizedOrigin, options, listeners);
                  listeners.length = 0;
                }
                session.on("remoteSettings", () => {
                  processListeners();
                  closeCoveredSessions(this.sessions[normalizedOptions], session);
                });
              });
              session[kRequest] = session.request;
              session.request = (headers, streamOptions) => {
                if (session[kGracefullyClosing]) {
                  throw new Error("The session is gracefully closing. No new streams are allowed.");
                }
                const stream = session[kRequest](headers, streamOptions);
                session.ref();
                ++session[kCurrentStreamsCount];
                if (session[kCurrentStreamsCount] === session.remoteSettings.maxConcurrentStreams) {
                  this._freeSessionsCount--;
                }
                stream.once("close", () => {
                  wasFree = isFree();
                  --session[kCurrentStreamsCount];
                  if (!session.destroyed && !session.closed) {
                    closeSessionIfCovered(this.sessions[normalizedOptions], session);
                    if (isFree() && !session.closed) {
                      if (!wasFree) {
                        this._freeSessionsCount++;
                        wasFree = true;
                      }
                      const isEmpty = session[kCurrentStreamsCount] === 0;
                      if (isEmpty) {
                        session.unref();
                      }
                      if (isEmpty && (this._freeSessionsCount > this.maxFreeSessions || session[kGracefullyClosing])) {
                        session.close();
                      } else {
                        closeCoveredSessions(this.sessions[normalizedOptions], session);
                        processListeners();
                      }
                    }
                  }
                });
                return stream;
              };
            } catch (error) {
              for (const listener of listeners) {
                listener.reject(error);
              }
              removeFromQueue();
            }
          };
          entry.listeners = listeners;
          entry.completed = false;
          entry.destroyed = false;
          this.queue[normalizedOptions][normalizedOrigin] = entry;
          this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
        });
      }
      request(origin, options, headers, streamOptions) {
        return new Promise((resolve, reject) => {
          this.getSession(origin, options, [{
            reject,
            resolve: (session) => {
              try {
                resolve(session.request(headers, streamOptions));
              } catch (error) {
                reject(error);
              }
            }
          }]);
        });
      }
      createConnection(origin, options) {
        return Agent.connect(origin, options);
      }
      static connect(origin, options) {
        options.ALPNProtocols = ["h2"];
        const port = origin.port || 443;
        const host = origin.hostname || origin.host;
        if (typeof options.servername === "undefined") {
          options.servername = host;
        }
        return tls.connect(port, host, options);
      }
      closeFreeSessions() {
        for (const sessions of Object.values(this.sessions)) {
          for (const session of sessions) {
            if (session[kCurrentStreamsCount] === 0) {
              session.close();
            }
          }
        }
      }
      destroy(reason) {
        for (const sessions of Object.values(this.sessions)) {
          for (const session of sessions) {
            session.destroy(reason);
          }
        }
        for (const entriesOfAuthority of Object.values(this.queue)) {
          for (const entry of Object.values(entriesOfAuthority)) {
            entry.destroyed = true;
          }
        }
        this.queue = {};
      }
      get freeSessions() {
        return getSessions({ agent: this, isFree: true });
      }
      get busySessions() {
        return getSessions({ agent: this, isFree: false });
      }
    };
    Agent.kCurrentStreamsCount = kCurrentStreamsCount;
    Agent.kGracefullyClosing = kGracefullyClosing;
    module2.exports = {
      Agent,
      globalAgent: new Agent()
    };
  }
});

// node_modules/http2-wrapper/source/incoming-message.js
var require_incoming_message = __commonJS({
  "node_modules/http2-wrapper/source/incoming-message.js"(exports2, module2) {
    "use strict";
    var { Readable } = require("stream");
    var IncomingMessage = class extends Readable {
      constructor(socket, highWaterMark) {
        super({
          highWaterMark,
          autoDestroy: false
        });
        this.statusCode = null;
        this.statusMessage = "";
        this.httpVersion = "2.0";
        this.httpVersionMajor = 2;
        this.httpVersionMinor = 0;
        this.headers = {};
        this.trailers = {};
        this.req = null;
        this.aborted = false;
        this.complete = false;
        this.upgrade = null;
        this.rawHeaders = [];
        this.rawTrailers = [];
        this.socket = socket;
        this.connection = socket;
        this._dumped = false;
      }
      _destroy(error) {
        this.req._request.destroy(error);
      }
      setTimeout(ms, callback) {
        this.req.setTimeout(ms, callback);
        return this;
      }
      _dump() {
        if (!this._dumped) {
          this._dumped = true;
          this.removeAllListeners("data");
          this.resume();
        }
      }
      _read() {
        if (this.req) {
          this.req._request.resume();
        }
      }
    };
    module2.exports = IncomingMessage;
  }
});

// node_modules/http2-wrapper/source/utils/url-to-options.js
var require_url_to_options = __commonJS({
  "node_modules/http2-wrapper/source/utils/url-to-options.js"(exports2, module2) {
    "use strict";
    module2.exports = (url) => {
      const options = {
        protocol: url.protocol,
        hostname: typeof url.hostname === "string" && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
        host: url.host,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        href: url.href,
        path: `${url.pathname || ""}${url.search || ""}`
      };
      if (typeof url.port === "string" && url.port.length !== 0) {
        options.port = Number(url.port);
      }
      if (url.username || url.password) {
        options.auth = `${url.username || ""}:${url.password || ""}`;
      }
      return options;
    };
  }
});

// node_modules/http2-wrapper/source/utils/proxy-events.js
var require_proxy_events = __commonJS({
  "node_modules/http2-wrapper/source/utils/proxy-events.js"(exports2, module2) {
    "use strict";
    module2.exports = (from, to, events) => {
      for (const event of events) {
        from.on(event, (...args) => to.emit(event, ...args));
      }
    };
  }
});

// node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js
var require_is_request_pseudo_header = __commonJS({
  "node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js"(exports2, module2) {
    "use strict";
    module2.exports = (header) => {
      switch (header) {
        case ":method":
        case ":scheme":
        case ":authority":
        case ":path":
          return true;
        default:
          return false;
      }
    };
  }
});

// node_modules/http2-wrapper/source/utils/errors.js
var require_errors = __commonJS({
  "node_modules/http2-wrapper/source/utils/errors.js"(exports2, module2) {
    "use strict";
    var makeError = (Base, key, getMessage) => {
      module2.exports[key] = class NodeError extends Base {
        constructor(...args) {
          super(typeof getMessage === "string" ? getMessage : getMessage(args));
          this.name = `${super.name} [${key}]`;
          this.code = key;
        }
      };
    };
    makeError(TypeError, "ERR_INVALID_ARG_TYPE", (args) => {
      const type = args[0].includes(".") ? "property" : "argument";
      let valid = args[1];
      const isManyTypes = Array.isArray(valid);
      if (isManyTypes) {
        valid = `${valid.slice(0, -1).join(", ")} or ${valid.slice(-1)}`;
      }
      return `The "${args[0]}" ${type} must be ${isManyTypes ? "one of" : "of"} type ${valid}. Received ${typeof args[2]}`;
    });
    makeError(TypeError, "ERR_INVALID_PROTOCOL", (args) => {
      return `Protocol "${args[0]}" not supported. Expected "${args[1]}"`;
    });
    makeError(Error, "ERR_HTTP_HEADERS_SENT", (args) => {
      return `Cannot ${args[0]} headers after they are sent to the client`;
    });
    makeError(TypeError, "ERR_INVALID_HTTP_TOKEN", (args) => {
      return `${args[0]} must be a valid HTTP token [${args[1]}]`;
    });
    makeError(TypeError, "ERR_HTTP_INVALID_HEADER_VALUE", (args) => {
      return `Invalid value "${args[0]} for header "${args[1]}"`;
    });
    makeError(TypeError, "ERR_INVALID_CHAR", (args) => {
      return `Invalid character in ${args[0]} [${args[1]}]`;
    });
  }
});

// node_modules/http2-wrapper/source/client-request.js
var require_client_request = __commonJS({
  "node_modules/http2-wrapper/source/client-request.js"(exports2, module2) {
    "use strict";
    var http2 = require("http2");
    var { Writable } = require("stream");
    var { Agent, globalAgent } = require_agent();
    var IncomingMessage = require_incoming_message();
    var urlToOptions = require_url_to_options();
    var proxyEvents = require_proxy_events();
    var isRequestPseudoHeader = require_is_request_pseudo_header();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_INVALID_PROTOCOL,
      ERR_HTTP_HEADERS_SENT,
      ERR_INVALID_HTTP_TOKEN,
      ERR_HTTP_INVALID_HEADER_VALUE,
      ERR_INVALID_CHAR
    } = require_errors();
    var {
      HTTP2_HEADER_STATUS,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_METHOD_CONNECT
    } = http2.constants;
    var kHeaders = Symbol("headers");
    var kOrigin = Symbol("origin");
    var kSession = Symbol("session");
    var kOptions = Symbol("options");
    var kFlushedHeaders = Symbol("flushedHeaders");
    var kJobs = Symbol("jobs");
    var isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
    var isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;
    var ClientRequest = class extends Writable {
      constructor(input, options, callback) {
        super({
          autoDestroy: false
        });
        const hasInput = typeof input === "string" || input instanceof URL;
        if (hasInput) {
          input = urlToOptions(input instanceof URL ? input : new URL(input));
        }
        if (typeof options === "function" || options === void 0) {
          callback = options;
          options = hasInput ? input : __spreadValues({}, input);
        } else {
          options = __spreadValues(__spreadValues({}, input), options);
        }
        if (options.h2session) {
          this[kSession] = options.h2session;
        } else if (options.agent === false) {
          this.agent = new Agent({ maxFreeSessions: 0 });
        } else if (typeof options.agent === "undefined" || options.agent === null) {
          if (typeof options.createConnection === "function") {
            this.agent = new Agent({ maxFreeSessions: 0 });
            this.agent.createConnection = options.createConnection;
          } else {
            this.agent = globalAgent;
          }
        } else if (typeof options.agent.request === "function") {
          this.agent = options.agent;
        } else {
          throw new ERR_INVALID_ARG_TYPE("options.agent", ["Agent-like Object", "undefined", "false"], options.agent);
        }
        if (options.protocol && options.protocol !== "https:") {
          throw new ERR_INVALID_PROTOCOL(options.protocol, "https:");
        }
        const port = options.port || options.defaultPort || this.agent && this.agent.defaultPort || 443;
        const host = options.hostname || options.host || "localhost";
        delete options.hostname;
        delete options.host;
        delete options.port;
        const { timeout } = options;
        options.timeout = void 0;
        this[kHeaders] = Object.create(null);
        this[kJobs] = [];
        this.socket = null;
        this.connection = null;
        this.method = options.method || "GET";
        this.path = options.path;
        this.res = null;
        this.aborted = false;
        this.reusedSocket = false;
        if (options.headers) {
          for (const [header, value] of Object.entries(options.headers)) {
            this.setHeader(header, value);
          }
        }
        if (options.auth && !("authorization" in this[kHeaders])) {
          this[kHeaders].authorization = "Basic " + Buffer.from(options.auth).toString("base64");
        }
        options.session = options.tlsSession;
        options.path = options.socketPath;
        this[kOptions] = options;
        if (port === 443) {
          this[kOrigin] = `https://${host}`;
          if (!(":authority" in this[kHeaders])) {
            this[kHeaders][":authority"] = host;
          }
        } else {
          this[kOrigin] = `https://${host}:${port}`;
          if (!(":authority" in this[kHeaders])) {
            this[kHeaders][":authority"] = `${host}:${port}`;
          }
        }
        if (timeout) {
          this.setTimeout(timeout);
        }
        if (callback) {
          this.once("response", callback);
        }
        this[kFlushedHeaders] = false;
      }
      get method() {
        return this[kHeaders][HTTP2_HEADER_METHOD];
      }
      set method(value) {
        if (value) {
          this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();
        }
      }
      get path() {
        return this[kHeaders][HTTP2_HEADER_PATH];
      }
      set path(value) {
        if (value) {
          this[kHeaders][HTTP2_HEADER_PATH] = value;
        }
      }
      get _mustNotHaveABody() {
        return this.method === "GET" || this.method === "HEAD" || this.method === "DELETE";
      }
      _write(chunk, encoding, callback) {
        if (this._mustNotHaveABody) {
          callback(new Error("The GET, HEAD and DELETE methods must NOT have a body"));
          return;
        }
        this.flushHeaders();
        const callWrite = () => this._request.write(chunk, encoding, callback);
        if (this._request) {
          callWrite();
        } else {
          this[kJobs].push(callWrite);
        }
      }
      _final(callback) {
        if (this.destroyed) {
          return;
        }
        this.flushHeaders();
        const callEnd = () => {
          if (this._mustNotHaveABody) {
            callback();
            return;
          }
          this._request.end(callback);
        };
        if (this._request) {
          callEnd();
        } else {
          this[kJobs].push(callEnd);
        }
      }
      abort() {
        if (this.res && this.res.complete) {
          return;
        }
        if (!this.aborted) {
          process.nextTick(() => this.emit("abort"));
        }
        this.aborted = true;
        this.destroy();
      }
      _destroy(error, callback) {
        if (this.res) {
          this.res._dump();
        }
        if (this._request) {
          this._request.destroy();
        }
        callback(error);
      }
      async flushHeaders() {
        if (this[kFlushedHeaders] || this.destroyed) {
          return;
        }
        this[kFlushedHeaders] = true;
        const isConnectMethod = this.method === HTTP2_METHOD_CONNECT;
        const onStream = (stream) => {
          this._request = stream;
          if (this.destroyed) {
            stream.destroy();
            return;
          }
          if (!isConnectMethod) {
            proxyEvents(stream, this, ["timeout", "continue", "close", "error"]);
          }
          const waitForEnd = (fn) => {
            return (...args) => {
              if (!this.writable && !this.destroyed) {
                fn(...args);
              } else {
                this.once("finish", () => {
                  fn(...args);
                });
              }
            };
          };
          stream.once("response", waitForEnd((headers, flags, rawHeaders) => {
            const response = new IncomingMessage(this.socket, stream.readableHighWaterMark);
            this.res = response;
            response.req = this;
            response.statusCode = headers[HTTP2_HEADER_STATUS];
            response.headers = headers;
            response.rawHeaders = rawHeaders;
            response.once("end", () => {
              if (this.aborted) {
                response.aborted = true;
                response.emit("aborted");
              } else {
                response.complete = true;
                response.socket = null;
                response.connection = null;
              }
            });
            if (isConnectMethod) {
              response.upgrade = true;
              if (this.emit("connect", response, stream, Buffer.alloc(0))) {
                this.emit("close");
              } else {
                stream.destroy();
              }
            } else {
              stream.on("data", (chunk) => {
                if (!response._dumped && !response.push(chunk)) {
                  stream.pause();
                }
              });
              stream.once("end", () => {
                response.push(null);
              });
              if (!this.emit("response", response)) {
                response._dump();
              }
            }
          }));
          stream.once("headers", waitForEnd((headers) => this.emit("information", { statusCode: headers[HTTP2_HEADER_STATUS] })));
          stream.once("trailers", waitForEnd((trailers, flags, rawTrailers) => {
            const { res } = this;
            res.trailers = trailers;
            res.rawTrailers = rawTrailers;
          }));
          const { socket } = stream.session;
          this.socket = socket;
          this.connection = socket;
          for (const job of this[kJobs]) {
            job();
          }
          this.emit("socket", this.socket);
        };
        if (this[kSession]) {
          try {
            onStream(this[kSession].request(this[kHeaders]));
          } catch (error) {
            this.emit("error", error);
          }
        } else {
          this.reusedSocket = true;
          try {
            onStream(await this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]));
          } catch (error) {
            this.emit("error", error);
          }
        }
      }
      getHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        return this[kHeaders][name.toLowerCase()];
      }
      get headersSent() {
        return this[kFlushedHeaders];
      }
      removeHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        if (this.headersSent) {
          throw new ERR_HTTP_HEADERS_SENT("remove");
        }
        delete this[kHeaders][name.toLowerCase()];
      }
      setHeader(name, value) {
        if (this.headersSent) {
          throw new ERR_HTTP_HEADERS_SENT("set");
        }
        if (typeof name !== "string" || !isValidHttpToken.test(name) && !isRequestPseudoHeader(name)) {
          throw new ERR_INVALID_HTTP_TOKEN("Header name", name);
        }
        if (typeof value === "undefined") {
          throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
        }
        if (isInvalidHeaderValue.test(value)) {
          throw new ERR_INVALID_CHAR("header content", name);
        }
        this[kHeaders][name.toLowerCase()] = value;
      }
      setNoDelay() {
      }
      setSocketKeepAlive() {
      }
      setTimeout(ms, callback) {
        const applyTimeout = () => this._request.setTimeout(ms, callback);
        if (this._request) {
          applyTimeout();
        } else {
          this[kJobs].push(applyTimeout);
        }
        return this;
      }
      get maxHeadersCount() {
        if (!this.destroyed && this._request) {
          return this._request.session.localSettings.maxHeaderListSize;
        }
        return void 0;
      }
      set maxHeadersCount(_value) {
      }
    };
    module2.exports = ClientRequest;
  }
});

// node_modules/resolve-alpn/index.js
var require_resolve_alpn = __commonJS({
  "node_modules/resolve-alpn/index.js"(exports2, module2) {
    "use strict";
    var tls = require("tls");
    module2.exports = (options = {}, connect = tls.connect) => new Promise((resolve, reject) => {
      let timeout = false;
      let socket;
      const callback = async () => {
        await socketPromise;
        socket.off("timeout", onTimeout);
        socket.off("error", reject);
        if (options.resolveSocket) {
          resolve({ alpnProtocol: socket.alpnProtocol, socket, timeout });
          if (timeout) {
            await Promise.resolve();
            socket.emit("timeout");
          }
        } else {
          socket.destroy();
          resolve({ alpnProtocol: socket.alpnProtocol, timeout });
        }
      };
      const onTimeout = async () => {
        timeout = true;
        callback();
      };
      const socketPromise = (async () => {
        try {
          socket = await connect(options, callback);
          socket.on("error", reject);
          socket.once("timeout", onTimeout);
        } catch (error) {
          reject(error);
        }
      })();
    });
  }
});

// node_modules/http2-wrapper/source/utils/calculate-server-name.js
var require_calculate_server_name = __commonJS({
  "node_modules/http2-wrapper/source/utils/calculate-server-name.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    module2.exports = (options) => {
      let servername = options.host;
      const hostHeader = options.headers && options.headers.host;
      if (hostHeader) {
        if (hostHeader.startsWith("[")) {
          const index = hostHeader.indexOf("]");
          if (index === -1) {
            servername = hostHeader;
          } else {
            servername = hostHeader.slice(1, -1);
          }
        } else {
          servername = hostHeader.split(":", 1)[0];
        }
      }
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    };
  }
});

// node_modules/http2-wrapper/source/auto.js
var require_auto = __commonJS({
  "node_modules/http2-wrapper/source/auto.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var resolveALPN = require_resolve_alpn();
    var QuickLRU = require_quick_lru();
    var Http2ClientRequest = require_client_request();
    var calculateServerName = require_calculate_server_name();
    var urlToOptions = require_url_to_options();
    var cache = new QuickLRU({ maxSize: 100 });
    var queue = new Map();
    var installSocket = (agent, socket, options) => {
      socket._httpMessage = { shouldKeepAlive: true };
      const onFree = () => {
        agent.emit("free", socket, options);
      };
      socket.on("free", onFree);
      const onClose = () => {
        agent.removeSocket(socket, options);
      };
      socket.on("close", onClose);
      const onRemove = () => {
        agent.removeSocket(socket, options);
        socket.off("close", onClose);
        socket.off("free", onFree);
        socket.off("agentRemove", onRemove);
      };
      socket.on("agentRemove", onRemove);
      agent.emit("free", socket, options);
    };
    var resolveProtocol = async (options) => {
      const name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;
      if (!cache.has(name)) {
        if (queue.has(name)) {
          const result = await queue.get(name);
          return result.alpnProtocol;
        }
        const { path, agent } = options;
        options.path = options.socketPath;
        const resultPromise = resolveALPN(options);
        queue.set(name, resultPromise);
        try {
          const { socket, alpnProtocol } = await resultPromise;
          cache.set(name, alpnProtocol);
          options.path = path;
          if (alpnProtocol === "h2") {
            socket.destroy();
          } else {
            const { globalAgent } = https;
            const defaultCreateConnection = https.Agent.prototype.createConnection;
            if (agent) {
              if (agent.createConnection === defaultCreateConnection) {
                installSocket(agent, socket, options);
              } else {
                socket.destroy();
              }
            } else if (globalAgent.createConnection === defaultCreateConnection) {
              installSocket(globalAgent, socket, options);
            } else {
              socket.destroy();
            }
          }
          queue.delete(name);
          return alpnProtocol;
        } catch (error) {
          queue.delete(name);
          throw error;
        }
      }
      return cache.get(name);
    };
    module2.exports = async (input, options, callback) => {
      if (typeof input === "string" || input instanceof URL) {
        input = urlToOptions(new URL(input));
      }
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      options = __spreadProps(__spreadValues(__spreadValues({
        ALPNProtocols: ["h2", "http/1.1"]
      }, input), options), {
        resolveSocket: true
      });
      if (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) {
        throw new Error("The `ALPNProtocols` option must be an Array with at least one entry");
      }
      options.protocol = options.protocol || "https:";
      const isHttps = options.protocol === "https:";
      options.host = options.hostname || options.host || "localhost";
      options.session = options.tlsSession;
      options.servername = options.servername || calculateServerName(options);
      options.port = options.port || (isHttps ? 443 : 80);
      options._defaultAgent = isHttps ? https.globalAgent : http.globalAgent;
      const agents = options.agent;
      if (agents) {
        if (agents.addRequest) {
          throw new Error("The `options.agent` object can contain only `http`, `https` or `http2` properties");
        }
        options.agent = agents[isHttps ? "https" : "http"];
      }
      if (isHttps) {
        const protocol = await resolveProtocol(options);
        if (protocol === "h2") {
          if (agents) {
            options.agent = agents.http2;
          }
          return new Http2ClientRequest(options, callback);
        }
      }
      return http.request(options, callback);
    };
    module2.exports.protocolCache = cache;
  }
});

// node_modules/http2-wrapper/source/index.js
var require_source4 = __commonJS({
  "node_modules/http2-wrapper/source/index.js"(exports2, module2) {
    "use strict";
    var http2 = require("http2");
    var agent = require_agent();
    var ClientRequest = require_client_request();
    var IncomingMessage = require_incoming_message();
    var auto = require_auto();
    var request = (url, options, callback) => {
      return new ClientRequest(url, options, callback);
    };
    var get = (url, options, callback) => {
      const req = new ClientRequest(url, options, callback);
      req.end();
      return req;
    };
    module2.exports = __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, http2), {
      ClientRequest,
      IncomingMessage
    }), agent), {
      request,
      get,
      auto
    });
  }
});

// node_modules/got/dist/source/core/utils/is-form-data.js
var require_is_form_data = __commonJS({
  "node_modules/got/dist/source/core/utils/is-form-data.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var is_1 = require_dist();
    exports2.default = (body) => is_1.default.nodeStream(body) && is_1.default.function_(body.getBoundary);
  }
});

// node_modules/got/dist/source/core/utils/get-body-size.js
var require_get_body_size = __commonJS({
  "node_modules/got/dist/source/core/utils/get-body-size.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fs_1 = require("fs");
    var util_1 = require("util");
    var is_1 = require_dist();
    var is_form_data_1 = require_is_form_data();
    var statAsync = util_1.promisify(fs_1.stat);
    exports2.default = async (body, headers) => {
      if (headers && "content-length" in headers) {
        return Number(headers["content-length"]);
      }
      if (!body) {
        return 0;
      }
      if (is_1.default.string(body)) {
        return Buffer.byteLength(body);
      }
      if (is_1.default.buffer(body)) {
        return body.length;
      }
      if (is_form_data_1.default(body)) {
        return util_1.promisify(body.getLength.bind(body))();
      }
      if (body instanceof fs_1.ReadStream) {
        const { size } = await statAsync(body.path);
        if (size === 0) {
          return void 0;
        }
        return size;
      }
      return void 0;
    };
  }
});

// node_modules/got/dist/source/core/utils/proxy-events.js
var require_proxy_events2 = __commonJS({
  "node_modules/got/dist/source/core/utils/proxy-events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function default_1(from, to, events) {
      const fns = {};
      for (const event of events) {
        fns[event] = (...args) => {
          to.emit(event, ...args);
        };
        from.on(event, fns[event]);
      }
      return () => {
        for (const event of events) {
          from.off(event, fns[event]);
        }
      };
    }
    exports2.default = default_1;
  }
});

// node_modules/got/dist/source/core/utils/unhandle.js
var require_unhandle = __commonJS({
  "node_modules/got/dist/source/core/utils/unhandle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = () => {
      const handlers = [];
      return {
        once(origin, event, fn) {
          origin.once(event, fn);
          handlers.push({ origin, event, fn });
        },
        unhandleAll() {
          for (const handler of handlers) {
            const { origin, event, fn } = handler;
            origin.removeListener(event, fn);
          }
          handlers.length = 0;
        }
      };
    };
  }
});

// node_modules/got/dist/source/core/utils/timed-out.js
var require_timed_out = __commonJS({
  "node_modules/got/dist/source/core/utils/timed-out.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimeoutError = void 0;
    var net = require("net");
    var unhandle_1 = require_unhandle();
    var reentry = Symbol("reentry");
    var noop = () => {
    };
    var TimeoutError = class extends Error {
      constructor(threshold, event) {
        super(`Timeout awaiting '${event}' for ${threshold}ms`);
        this.event = event;
        this.name = "TimeoutError";
        this.code = "ETIMEDOUT";
      }
    };
    exports2.TimeoutError = TimeoutError;
    exports2.default = (request, delays, options) => {
      if (reentry in request) {
        return noop;
      }
      request[reentry] = true;
      const cancelers = [];
      const { once, unhandleAll } = unhandle_1.default();
      const addTimeout = (delay, callback, event) => {
        var _a;
        const timeout = setTimeout(callback, delay, delay, event);
        (_a = timeout.unref) === null || _a === void 0 ? void 0 : _a.call(timeout);
        const cancel = () => {
          clearTimeout(timeout);
        };
        cancelers.push(cancel);
        return cancel;
      };
      const { host, hostname } = options;
      const timeoutHandler = (delay, event) => {
        request.destroy(new TimeoutError(delay, event));
      };
      const cancelTimeouts = () => {
        for (const cancel of cancelers) {
          cancel();
        }
        unhandleAll();
      };
      request.once("error", (error) => {
        cancelTimeouts();
        if (request.listenerCount("error") === 0) {
          throw error;
        }
      });
      request.once("close", cancelTimeouts);
      once(request, "response", (response) => {
        once(response, "end", cancelTimeouts);
      });
      if (typeof delays.request !== "undefined") {
        addTimeout(delays.request, timeoutHandler, "request");
      }
      if (typeof delays.socket !== "undefined") {
        const socketTimeoutHandler = () => {
          timeoutHandler(delays.socket, "socket");
        };
        request.setTimeout(delays.socket, socketTimeoutHandler);
        cancelers.push(() => {
          request.removeListener("timeout", socketTimeoutHandler);
        });
      }
      once(request, "socket", (socket) => {
        var _a;
        const { socketPath } = request;
        if (socket.connecting) {
          const hasPath = Boolean(socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a = hostname !== null && hostname !== void 0 ? hostname : host) !== null && _a !== void 0 ? _a : "") !== 0);
          if (typeof delays.lookup !== "undefined" && !hasPath && typeof socket.address().address === "undefined") {
            const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, "lookup");
            once(socket, "lookup", cancelTimeout);
          }
          if (typeof delays.connect !== "undefined") {
            const timeConnect = () => addTimeout(delays.connect, timeoutHandler, "connect");
            if (hasPath) {
              once(socket, "connect", timeConnect());
            } else {
              once(socket, "lookup", (error) => {
                if (error === null) {
                  once(socket, "connect", timeConnect());
                }
              });
            }
          }
          if (typeof delays.secureConnect !== "undefined" && options.protocol === "https:") {
            once(socket, "connect", () => {
              const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, "secureConnect");
              once(socket, "secureConnect", cancelTimeout);
            });
          }
        }
        if (typeof delays.send !== "undefined") {
          const timeRequest = () => addTimeout(delays.send, timeoutHandler, "send");
          if (socket.connecting) {
            once(socket, "connect", () => {
              once(request, "upload-complete", timeRequest());
            });
          } else {
            once(request, "upload-complete", timeRequest());
          }
        }
      });
      if (typeof delays.response !== "undefined") {
        once(request, "upload-complete", () => {
          const cancelTimeout = addTimeout(delays.response, timeoutHandler, "response");
          once(request, "response", cancelTimeout);
        });
      }
      return cancelTimeouts;
    };
  }
});

// node_modules/got/dist/source/core/utils/url-to-options.js
var require_url_to_options2 = __commonJS({
  "node_modules/got/dist/source/core/utils/url-to-options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var is_1 = require_dist();
    exports2.default = (url) => {
      url = url;
      const options = {
        protocol: url.protocol,
        hostname: is_1.default.string(url.hostname) && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
        host: url.host,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        href: url.href,
        path: `${url.pathname || ""}${url.search || ""}`
      };
      if (is_1.default.string(url.port) && url.port.length > 0) {
        options.port = Number(url.port);
      }
      if (url.username || url.password) {
        options.auth = `${url.username || ""}:${url.password || ""}`;
      }
      return options;
    };
  }
});

// node_modules/got/dist/source/core/utils/options-to-url.js
var require_options_to_url = __commonJS({
  "node_modules/got/dist/source/core/utils/options-to-url.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var url_1 = require("url");
    var keys = [
      "protocol",
      "host",
      "hostname",
      "port",
      "pathname",
      "search"
    ];
    exports2.default = (origin, options) => {
      var _a, _b;
      if (options.path) {
        if (options.pathname) {
          throw new TypeError("Parameters `path` and `pathname` are mutually exclusive.");
        }
        if (options.search) {
          throw new TypeError("Parameters `path` and `search` are mutually exclusive.");
        }
        if (options.searchParams) {
          throw new TypeError("Parameters `path` and `searchParams` are mutually exclusive.");
        }
      }
      if (options.search && options.searchParams) {
        throw new TypeError("Parameters `search` and `searchParams` are mutually exclusive.");
      }
      if (!origin) {
        if (!options.protocol) {
          throw new TypeError("No URL protocol specified");
        }
        origin = `${options.protocol}//${(_b = (_a = options.hostname) !== null && _a !== void 0 ? _a : options.host) !== null && _b !== void 0 ? _b : ""}`;
      }
      const url = new url_1.URL(origin);
      if (options.path) {
        const searchIndex = options.path.indexOf("?");
        if (searchIndex === -1) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.slice(0, searchIndex);
          options.search = options.path.slice(searchIndex + 1);
        }
        delete options.path;
      }
      for (const key of keys) {
        if (options[key]) {
          url[key] = options[key].toString();
        }
      }
      return url;
    };
  }
});

// node_modules/got/dist/source/core/utils/weakable-map.js
var require_weakable_map = __commonJS({
  "node_modules/got/dist/source/core/utils/weakable-map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var WeakableMap = class {
      constructor() {
        this.weakMap = new WeakMap();
        this.map = new Map();
      }
      set(key, value) {
        if (typeof key === "object") {
          this.weakMap.set(key, value);
        } else {
          this.map.set(key, value);
        }
      }
      get(key) {
        if (typeof key === "object") {
          return this.weakMap.get(key);
        }
        return this.map.get(key);
      }
      has(key) {
        if (typeof key === "object") {
          return this.weakMap.has(key);
        }
        return this.map.has(key);
      }
    };
    exports2.default = WeakableMap;
  }
});

// node_modules/got/dist/source/core/utils/get-buffer.js
var require_get_buffer = __commonJS({
  "node_modules/got/dist/source/core/utils/get-buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var getBuffer = async (stream) => {
      const chunks = [];
      let length = 0;
      for await (const chunk of stream) {
        chunks.push(chunk);
        length += Buffer.byteLength(chunk);
      }
      if (Buffer.isBuffer(chunks[0])) {
        return Buffer.concat(chunks, length);
      }
      return Buffer.from(chunks.join(""));
    };
    exports2.default = getBuffer;
  }
});

// node_modules/got/dist/source/core/utils/dns-ip-version.js
var require_dns_ip_version = __commonJS({
  "node_modules/got/dist/source/core/utils/dns-ip-version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dnsLookupIpVersionToFamily = exports2.isDnsLookupIpVersion = void 0;
    var conversionTable = {
      auto: 0,
      ipv4: 4,
      ipv6: 6
    };
    exports2.isDnsLookupIpVersion = (value) => {
      return value in conversionTable;
    };
    exports2.dnsLookupIpVersionToFamily = (dnsLookupIpVersion) => {
      if (exports2.isDnsLookupIpVersion(dnsLookupIpVersion)) {
        return conversionTable[dnsLookupIpVersion];
      }
      throw new Error("Invalid DNS lookup IP version");
    };
  }
});

// node_modules/got/dist/source/core/utils/is-response-ok.js
var require_is_response_ok = __commonJS({
  "node_modules/got/dist/source/core/utils/is-response-ok.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isResponseOk = void 0;
    exports2.isResponseOk = (response) => {
      const { statusCode } = response;
      const limitStatusCode = response.request.options.followRedirect ? 299 : 399;
      return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;
    };
  }
});

// node_modules/got/dist/source/utils/deprecation-warning.js
var require_deprecation_warning = __commonJS({
  "node_modules/got/dist/source/utils/deprecation-warning.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var alreadyWarned = new Set();
    exports2.default = (message) => {
      if (alreadyWarned.has(message)) {
        return;
      }
      alreadyWarned.add(message);
      process.emitWarning(`Got: ${message}`, {
        type: "DeprecationWarning"
      });
    };
  }
});

// node_modules/got/dist/source/as-promise/normalize-arguments.js
var require_normalize_arguments = __commonJS({
  "node_modules/got/dist/source/as-promise/normalize-arguments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var is_1 = require_dist();
    var normalizeArguments = (options, defaults) => {
      if (is_1.default.null_(options.encoding)) {
        throw new TypeError("To get a Buffer, set `options.responseType` to `buffer` instead");
      }
      is_1.assert.any([is_1.default.string, is_1.default.undefined], options.encoding);
      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.resolveBodyOnly);
      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.methodRewriting);
      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.isStream);
      is_1.assert.any([is_1.default.string, is_1.default.undefined], options.responseType);
      if (options.responseType === void 0) {
        options.responseType = "text";
      }
      const { retry } = options;
      if (defaults) {
        options.retry = __spreadValues({}, defaults.retry);
      } else {
        options.retry = {
          calculateDelay: (retryObject) => retryObject.computedValue,
          limit: 0,
          methods: [],
          statusCodes: [],
          errorCodes: [],
          maxRetryAfter: void 0
        };
      }
      if (is_1.default.object(retry)) {
        options.retry = __spreadValues(__spreadValues({}, options.retry), retry);
        options.retry.methods = [...new Set(options.retry.methods.map((method) => method.toUpperCase()))];
        options.retry.statusCodes = [...new Set(options.retry.statusCodes)];
        options.retry.errorCodes = [...new Set(options.retry.errorCodes)];
      } else if (is_1.default.number(retry)) {
        options.retry.limit = retry;
      }
      if (is_1.default.undefined(options.retry.maxRetryAfter)) {
        options.retry.maxRetryAfter = Math.min(...[options.timeout.request, options.timeout.connect].filter(is_1.default.number));
      }
      if (is_1.default.object(options.pagination)) {
        if (defaults) {
          options.pagination = __spreadValues(__spreadValues({}, defaults.pagination), options.pagination);
        }
        const { pagination } = options;
        if (!is_1.default.function_(pagination.transform)) {
          throw new Error("`options.pagination.transform` must be implemented");
        }
        if (!is_1.default.function_(pagination.shouldContinue)) {
          throw new Error("`options.pagination.shouldContinue` must be implemented");
        }
        if (!is_1.default.function_(pagination.filter)) {
          throw new TypeError("`options.pagination.filter` must be implemented");
        }
        if (!is_1.default.function_(pagination.paginate)) {
          throw new Error("`options.pagination.paginate` must be implemented");
        }
      }
      if (options.responseType === "json" && options.headers.accept === void 0) {
        options.headers.accept = "application/json";
      }
      return options;
    };
    exports2.default = normalizeArguments;
  }
});

// node_modules/got/dist/source/core/calculate-retry-delay.js
var require_calculate_retry_delay = __commonJS({
  "node_modules/got/dist/source/core/calculate-retry-delay.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.retryAfterStatusCodes = void 0;
    exports2.retryAfterStatusCodes = new Set([413, 429, 503]);
    var calculateRetryDelay = ({ attemptCount, retryOptions, error, retryAfter }) => {
      if (attemptCount > retryOptions.limit) {
        return 0;
      }
      const hasMethod = retryOptions.methods.includes(error.options.method);
      const hasErrorCode = retryOptions.errorCodes.includes(error.code);
      const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);
      if (!hasMethod || !hasErrorCode && !hasStatusCode) {
        return 0;
      }
      if (error.response) {
        if (retryAfter) {
          if (retryOptions.maxRetryAfter === void 0 || retryAfter > retryOptions.maxRetryAfter) {
            return 0;
          }
          return retryAfter;
        }
        if (error.response.statusCode === 413) {
          return 0;
        }
      }
      const noise = Math.random() * 100;
      return 2 ** (attemptCount - 1) * 1e3 + noise;
    };
    exports2.default = calculateRetryDelay;
  }
});

// node_modules/got/dist/source/core/index.js
var require_core = __commonJS({
  "node_modules/got/dist/source/core/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnsupportedProtocolError = exports2.ReadError = exports2.TimeoutError = exports2.UploadError = exports2.CacheError = exports2.HTTPError = exports2.MaxRedirectsError = exports2.RequestError = exports2.setNonEnumerableProperties = exports2.knownHookEvents = exports2.withoutBody = exports2.kIsNormalizedAlready = void 0;
    var util_1 = require("util");
    var stream_1 = require("stream");
    var fs_1 = require("fs");
    var url_1 = require("url");
    var http = require("http");
    var http_1 = require("http");
    var https = require("https");
    var http_timer_1 = require_source2();
    var cacheable_lookup_1 = require_source3();
    var CacheableRequest = require_src4();
    var decompressResponse = require_decompress_response();
    var http2wrapper = require_source4();
    var lowercaseKeys = require_lowercase_keys();
    var is_1 = require_dist();
    var get_body_size_1 = require_get_body_size();
    var is_form_data_1 = require_is_form_data();
    var proxy_events_1 = require_proxy_events2();
    var timed_out_1 = require_timed_out();
    var url_to_options_1 = require_url_to_options2();
    var options_to_url_1 = require_options_to_url();
    var weakable_map_1 = require_weakable_map();
    var get_buffer_1 = require_get_buffer();
    var dns_ip_version_1 = require_dns_ip_version();
    var is_response_ok_1 = require_is_response_ok();
    var deprecation_warning_1 = require_deprecation_warning();
    var normalize_arguments_1 = require_normalize_arguments();
    var calculate_retry_delay_1 = require_calculate_retry_delay();
    var globalDnsCache;
    var kRequest = Symbol("request");
    var kResponse = Symbol("response");
    var kResponseSize = Symbol("responseSize");
    var kDownloadedSize = Symbol("downloadedSize");
    var kBodySize = Symbol("bodySize");
    var kUploadedSize = Symbol("uploadedSize");
    var kServerResponsesPiped = Symbol("serverResponsesPiped");
    var kUnproxyEvents = Symbol("unproxyEvents");
    var kIsFromCache = Symbol("isFromCache");
    var kCancelTimeouts = Symbol("cancelTimeouts");
    var kStartedReading = Symbol("startedReading");
    var kStopReading = Symbol("stopReading");
    var kTriggerRead = Symbol("triggerRead");
    var kBody = Symbol("body");
    var kJobs = Symbol("jobs");
    var kOriginalResponse = Symbol("originalResponse");
    var kRetryTimeout = Symbol("retryTimeout");
    exports2.kIsNormalizedAlready = Symbol("isNormalizedAlready");
    var supportsBrotli = is_1.default.string(process.versions.brotli);
    exports2.withoutBody = new Set(["GET", "HEAD"]);
    exports2.knownHookEvents = [
      "init",
      "beforeRequest",
      "beforeRedirect",
      "beforeError",
      "beforeRetry",
      "afterResponse"
    ];
    function validateSearchParameters(searchParameters) {
      for (const key in searchParameters) {
        const value = searchParameters[key];
        if (!is_1.default.string(value) && !is_1.default.number(value) && !is_1.default.boolean(value) && !is_1.default.null_(value) && !is_1.default.undefined(value)) {
          throw new TypeError(`The \`searchParams\` value '${String(value)}' must be a string, number, boolean or null`);
        }
      }
    }
    function isClientRequest(clientRequest) {
      return is_1.default.object(clientRequest) && !("statusCode" in clientRequest);
    }
    var cacheableStore = new weakable_map_1.default();
    var waitForOpenFile = async (file) => new Promise((resolve, reject) => {
      const onError = (error) => {
        reject(error);
      };
      if (!file.pending) {
        resolve();
      }
      file.once("error", onError);
      file.once("ready", () => {
        file.off("error", onError);
        resolve();
      });
    });
    var redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);
    var nonEnumerableProperties = [
      "context",
      "body",
      "json",
      "form"
    ];
    exports2.setNonEnumerableProperties = (sources, to) => {
      const properties = {};
      for (const source of sources) {
        if (!source) {
          continue;
        }
        for (const name of nonEnumerableProperties) {
          if (!(name in source)) {
            continue;
          }
          properties[name] = {
            writable: true,
            configurable: true,
            enumerable: false,
            value: source[name]
          };
        }
      }
      Object.defineProperties(to, properties);
    };
    var RequestError = class extends Error {
      constructor(message, error, self2) {
        var _a, _b;
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = "RequestError";
        this.code = (_a = error.code) !== null && _a !== void 0 ? _a : "ERR_GOT_REQUEST_ERROR";
        if (self2 instanceof Request2) {
          Object.defineProperty(this, "request", {
            enumerable: false,
            value: self2
          });
          Object.defineProperty(this, "response", {
            enumerable: false,
            value: self2[kResponse]
          });
          Object.defineProperty(this, "options", {
            enumerable: false,
            value: self2.options
          });
        } else {
          Object.defineProperty(this, "options", {
            enumerable: false,
            value: self2
          });
        }
        this.timings = (_b = this.request) === null || _b === void 0 ? void 0 : _b.timings;
        if (is_1.default.string(error.stack) && is_1.default.string(this.stack)) {
          const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
          const thisStackTrace = this.stack.slice(indexOfMessage).split("\n").reverse();
          const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split("\n").reverse();
          while (errorStackTrace.length !== 0 && errorStackTrace[0] === thisStackTrace[0]) {
            thisStackTrace.shift();
          }
          this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join("\n")}${errorStackTrace.reverse().join("\n")}`;
        }
      }
    };
    exports2.RequestError = RequestError;
    var MaxRedirectsError = class extends RequestError {
      constructor(request) {
        super(`Redirected ${request.options.maxRedirects} times. Aborting.`, {}, request);
        this.name = "MaxRedirectsError";
        this.code = "ERR_TOO_MANY_REDIRECTS";
      }
    };
    exports2.MaxRedirectsError = MaxRedirectsError;
    var HTTPError = class extends RequestError {
      constructor(response) {
        super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);
        this.name = "HTTPError";
        this.code = "ERR_NON_2XX_3XX_RESPONSE";
      }
    };
    exports2.HTTPError = HTTPError;
    var CacheError = class extends RequestError {
      constructor(error, request) {
        super(error.message, error, request);
        this.name = "CacheError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_CACHE_ACCESS" : this.code;
      }
    };
    exports2.CacheError = CacheError;
    var UploadError = class extends RequestError {
      constructor(error, request) {
        super(error.message, error, request);
        this.name = "UploadError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_UPLOAD" : this.code;
      }
    };
    exports2.UploadError = UploadError;
    var TimeoutError = class extends RequestError {
      constructor(error, timings, request) {
        super(error.message, error, request);
        this.name = "TimeoutError";
        this.event = error.event;
        this.timings = timings;
      }
    };
    exports2.TimeoutError = TimeoutError;
    var ReadError = class extends RequestError {
      constructor(error, request) {
        super(error.message, error, request);
        this.name = "ReadError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_READING_RESPONSE_STREAM" : this.code;
      }
    };
    exports2.ReadError = ReadError;
    var UnsupportedProtocolError = class extends RequestError {
      constructor(options) {
        super(`Unsupported protocol "${options.url.protocol}"`, {}, options);
        this.name = "UnsupportedProtocolError";
        this.code = "ERR_UNSUPPORTED_PROTOCOL";
      }
    };
    exports2.UnsupportedProtocolError = UnsupportedProtocolError;
    var proxiedRequestEvents = [
      "socket",
      "connect",
      "continue",
      "information",
      "upgrade",
      "timeout"
    ];
    var Request2 = class extends stream_1.Duplex {
      constructor(url, options = {}, defaults) {
        super({
          autoDestroy: false,
          highWaterMark: 0
        });
        this[kDownloadedSize] = 0;
        this[kUploadedSize] = 0;
        this.requestInitialized = false;
        this[kServerResponsesPiped] = new Set();
        this.redirects = [];
        this[kStopReading] = false;
        this[kTriggerRead] = false;
        this[kJobs] = [];
        this.retryCount = 0;
        this._progressCallbacks = [];
        const unlockWrite = () => this._unlockWrite();
        const lockWrite = () => this._lockWrite();
        this.on("pipe", (source) => {
          source.prependListener("data", unlockWrite);
          source.on("data", lockWrite);
          source.prependListener("end", unlockWrite);
          source.on("end", lockWrite);
        });
        this.on("unpipe", (source) => {
          source.off("data", unlockWrite);
          source.off("data", lockWrite);
          source.off("end", unlockWrite);
          source.off("end", lockWrite);
        });
        this.on("pipe", (source) => {
          if (source instanceof http_1.IncomingMessage) {
            this.options.headers = __spreadValues(__spreadValues({}, source.headers), this.options.headers);
          }
        });
        const { json, body, form } = options;
        if (json || body || form) {
          this._lockWrite();
        }
        if (exports2.kIsNormalizedAlready in options) {
          this.options = options;
        } else {
          try {
            this.options = this.constructor.normalizeArguments(url, options, defaults);
          } catch (error) {
            if (is_1.default.nodeStream(options.body)) {
              options.body.destroy();
            }
            this.destroy(error);
            return;
          }
        }
        (async () => {
          var _a;
          try {
            if (this.options.body instanceof fs_1.ReadStream) {
              await waitForOpenFile(this.options.body);
            }
            const { url: normalizedURL } = this.options;
            if (!normalizedURL) {
              throw new TypeError("Missing `url` property");
            }
            this.requestUrl = normalizedURL.toString();
            decodeURI(this.requestUrl);
            await this._finalizeBody();
            await this._makeRequest();
            if (this.destroyed) {
              (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.destroy();
              return;
            }
            for (const job of this[kJobs]) {
              job();
            }
            this[kJobs].length = 0;
            this.requestInitialized = true;
          } catch (error) {
            if (error instanceof RequestError) {
              this._beforeError(error);
              return;
            }
            if (!this.destroyed) {
              this.destroy(error);
            }
          }
        })();
      }
      static normalizeArguments(url, options, defaults) {
        var _a, _b, _c, _d, _e;
        const rawOptions = options;
        if (is_1.default.object(url) && !is_1.default.urlInstance(url)) {
          options = __spreadValues(__spreadValues(__spreadValues({}, defaults), url), options);
        } else {
          if (url && options && options.url !== void 0) {
            throw new TypeError("The `url` option is mutually exclusive with the `input` argument");
          }
          options = __spreadValues(__spreadValues({}, defaults), options);
          if (url !== void 0) {
            options.url = url;
          }
          if (is_1.default.urlInstance(options.url)) {
            options.url = new url_1.URL(options.url.toString());
          }
        }
        if (options.cache === false) {
          options.cache = void 0;
        }
        if (options.dnsCache === false) {
          options.dnsCache = void 0;
        }
        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.method);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.headers);
        is_1.assert.any([is_1.default.string, is_1.default.urlInstance, is_1.default.undefined], options.prefixUrl);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cookieJar);
        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.searchParams);
        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.cache);
        is_1.assert.any([is_1.default.object, is_1.default.number, is_1.default.undefined], options.timeout);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.context);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.hooks);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.decompress);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.ignoreInvalidCookies);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.followRedirect);
        is_1.assert.any([is_1.default.number, is_1.default.undefined], options.maxRedirects);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.throwHttpErrors);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.http2);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.allowGetBody);
        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.localAddress);
        is_1.assert.any([dns_ip_version_1.isDnsLookupIpVersion, is_1.default.undefined], options.dnsLookupIpVersion);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.https);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.rejectUnauthorized);
        if (options.https) {
          is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.https.rejectUnauthorized);
          is_1.assert.any([is_1.default.function_, is_1.default.undefined], options.https.checkServerIdentity);
          is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificateAuthority);
          is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.key);
          is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificate);
          is_1.assert.any([is_1.default.string, is_1.default.undefined], options.https.passphrase);
          is_1.assert.any([is_1.default.string, is_1.default.buffer, is_1.default.array, is_1.default.undefined], options.https.pfx);
        }
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cacheOptions);
        if (is_1.default.string(options.method)) {
          options.method = options.method.toUpperCase();
        } else {
          options.method = "GET";
        }
        if (options.headers === (defaults === null || defaults === void 0 ? void 0 : defaults.headers)) {
          options.headers = __spreadValues({}, options.headers);
        } else {
          options.headers = lowercaseKeys(__spreadValues(__spreadValues({}, defaults === null || defaults === void 0 ? void 0 : defaults.headers), options.headers));
        }
        if ("slashes" in options) {
          throw new TypeError("The legacy `url.Url` has been deprecated. Use `URL` instead.");
        }
        if ("auth" in options) {
          throw new TypeError("Parameter `auth` is deprecated. Use `username` / `password` instead.");
        }
        if ("searchParams" in options) {
          if (options.searchParams && options.searchParams !== (defaults === null || defaults === void 0 ? void 0 : defaults.searchParams)) {
            let searchParameters;
            if (is_1.default.string(options.searchParams) || options.searchParams instanceof url_1.URLSearchParams) {
              searchParameters = new url_1.URLSearchParams(options.searchParams);
            } else {
              validateSearchParameters(options.searchParams);
              searchParameters = new url_1.URLSearchParams();
              for (const key in options.searchParams) {
                const value = options.searchParams[key];
                if (value === null) {
                  searchParameters.append(key, "");
                } else if (value !== void 0) {
                  searchParameters.append(key, value);
                }
              }
            }
            (_a = defaults === null || defaults === void 0 ? void 0 : defaults.searchParams) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => {
              if (!searchParameters.has(key)) {
                searchParameters.append(key, value);
              }
            });
            options.searchParams = searchParameters;
          }
        }
        options.username = (_b = options.username) !== null && _b !== void 0 ? _b : "";
        options.password = (_c = options.password) !== null && _c !== void 0 ? _c : "";
        if (is_1.default.undefined(options.prefixUrl)) {
          options.prefixUrl = (_d = defaults === null || defaults === void 0 ? void 0 : defaults.prefixUrl) !== null && _d !== void 0 ? _d : "";
        } else {
          options.prefixUrl = options.prefixUrl.toString();
          if (options.prefixUrl !== "" && !options.prefixUrl.endsWith("/")) {
            options.prefixUrl += "/";
          }
        }
        if (is_1.default.string(options.url)) {
          if (options.url.startsWith("/")) {
            throw new Error("`input` must not start with a slash when using `prefixUrl`");
          }
          options.url = options_to_url_1.default(options.prefixUrl + options.url, options);
        } else if (is_1.default.undefined(options.url) && options.prefixUrl !== "" || options.protocol) {
          options.url = options_to_url_1.default(options.prefixUrl, options);
        }
        if (options.url) {
          if ("port" in options) {
            delete options.port;
          }
          let { prefixUrl } = options;
          Object.defineProperty(options, "prefixUrl", {
            set: (value) => {
              const url2 = options.url;
              if (!url2.href.startsWith(value)) {
                throw new Error(`Cannot change \`prefixUrl\` from ${prefixUrl} to ${value}: ${url2.href}`);
              }
              options.url = new url_1.URL(value + url2.href.slice(prefixUrl.length));
              prefixUrl = value;
            },
            get: () => prefixUrl
          });
          let { protocol } = options.url;
          if (protocol === "unix:") {
            protocol = "http:";
            options.url = new url_1.URL(`http://unix${options.url.pathname}${options.url.search}`);
          }
          if (options.searchParams) {
            options.url.search = options.searchParams.toString();
          }
          if (protocol !== "http:" && protocol !== "https:") {
            throw new UnsupportedProtocolError(options);
          }
          if (options.username === "") {
            options.username = options.url.username;
          } else {
            options.url.username = options.username;
          }
          if (options.password === "") {
            options.password = options.url.password;
          } else {
            options.url.password = options.password;
          }
        }
        const { cookieJar } = options;
        if (cookieJar) {
          let { setCookie, getCookieString } = cookieJar;
          is_1.assert.function_(setCookie);
          is_1.assert.function_(getCookieString);
          if (setCookie.length === 4 && getCookieString.length === 0) {
            setCookie = util_1.promisify(setCookie.bind(options.cookieJar));
            getCookieString = util_1.promisify(getCookieString.bind(options.cookieJar));
            options.cookieJar = {
              setCookie,
              getCookieString
            };
          }
        }
        const { cache } = options;
        if (cache) {
          if (!cacheableStore.has(cache)) {
            cacheableStore.set(cache, new CacheableRequest((requestOptions, handler) => {
              const result = requestOptions[kRequest](requestOptions, handler);
              if (is_1.default.promise(result)) {
                result.once = (event, handler2) => {
                  if (event === "error") {
                    result.catch(handler2);
                  } else if (event === "abort") {
                    (async () => {
                      try {
                        const request = await result;
                        request.once("abort", handler2);
                      } catch (_a2) {
                      }
                    })();
                  } else {
                    throw new Error(`Unknown HTTP2 promise event: ${event}`);
                  }
                  return result;
                };
              }
              return result;
            }, cache));
          }
        }
        options.cacheOptions = __spreadValues({}, options.cacheOptions);
        if (options.dnsCache === true) {
          if (!globalDnsCache) {
            globalDnsCache = new cacheable_lookup_1.default();
          }
          options.dnsCache = globalDnsCache;
        } else if (!is_1.default.undefined(options.dnsCache) && !options.dnsCache.lookup) {
          throw new TypeError(`Parameter \`dnsCache\` must be a CacheableLookup instance or a boolean, got ${is_1.default(options.dnsCache)}`);
        }
        if (is_1.default.number(options.timeout)) {
          options.timeout = { request: options.timeout };
        } else if (defaults && options.timeout !== defaults.timeout) {
          options.timeout = __spreadValues(__spreadValues({}, defaults.timeout), options.timeout);
        } else {
          options.timeout = __spreadValues({}, options.timeout);
        }
        if (!options.context) {
          options.context = {};
        }
        const areHooksDefault = options.hooks === (defaults === null || defaults === void 0 ? void 0 : defaults.hooks);
        options.hooks = __spreadValues({}, options.hooks);
        for (const event of exports2.knownHookEvents) {
          if (event in options.hooks) {
            if (is_1.default.array(options.hooks[event])) {
              options.hooks[event] = [...options.hooks[event]];
            } else {
              throw new TypeError(`Parameter \`${event}\` must be an Array, got ${is_1.default(options.hooks[event])}`);
            }
          } else {
            options.hooks[event] = [];
          }
        }
        if (defaults && !areHooksDefault) {
          for (const event of exports2.knownHookEvents) {
            const defaultHooks = defaults.hooks[event];
            if (defaultHooks.length > 0) {
              options.hooks[event] = [
                ...defaults.hooks[event],
                ...options.hooks[event]
              ];
            }
          }
        }
        if ("family" in options) {
          deprecation_warning_1.default('"options.family" was never documented, please use "options.dnsLookupIpVersion"');
        }
        if (defaults === null || defaults === void 0 ? void 0 : defaults.https) {
          options.https = __spreadValues(__spreadValues({}, defaults.https), options.https);
        }
        if ("rejectUnauthorized" in options) {
          deprecation_warning_1.default('"options.rejectUnauthorized" is now deprecated, please use "options.https.rejectUnauthorized"');
        }
        if ("checkServerIdentity" in options) {
          deprecation_warning_1.default('"options.checkServerIdentity" was never documented, please use "options.https.checkServerIdentity"');
        }
        if ("ca" in options) {
          deprecation_warning_1.default('"options.ca" was never documented, please use "options.https.certificateAuthority"');
        }
        if ("key" in options) {
          deprecation_warning_1.default('"options.key" was never documented, please use "options.https.key"');
        }
        if ("cert" in options) {
          deprecation_warning_1.default('"options.cert" was never documented, please use "options.https.certificate"');
        }
        if ("passphrase" in options) {
          deprecation_warning_1.default('"options.passphrase" was never documented, please use "options.https.passphrase"');
        }
        if ("pfx" in options) {
          deprecation_warning_1.default('"options.pfx" was never documented, please use "options.https.pfx"');
        }
        if ("followRedirects" in options) {
          throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
        }
        if (options.agent) {
          for (const key in options.agent) {
            if (key !== "http" && key !== "https" && key !== "http2") {
              throw new TypeError(`Expected the \`options.agent\` properties to be \`http\`, \`https\` or \`http2\`, got \`${key}\``);
            }
          }
        }
        options.maxRedirects = (_e = options.maxRedirects) !== null && _e !== void 0 ? _e : 0;
        exports2.setNonEnumerableProperties([defaults, rawOptions], options);
        return normalize_arguments_1.default(options, defaults);
      }
      _lockWrite() {
        const onLockedWrite = () => {
          throw new TypeError("The payload has been already provided");
        };
        this.write = onLockedWrite;
        this.end = onLockedWrite;
      }
      _unlockWrite() {
        this.write = super.write;
        this.end = super.end;
      }
      async _finalizeBody() {
        const { options } = this;
        const { headers } = options;
        const isForm = !is_1.default.undefined(options.form);
        const isJSON = !is_1.default.undefined(options.json);
        const isBody = !is_1.default.undefined(options.body);
        const hasPayload = isForm || isJSON || isBody;
        const cannotHaveBody = exports2.withoutBody.has(options.method) && !(options.method === "GET" && options.allowGetBody);
        this._cannotHaveBody = cannotHaveBody;
        if (hasPayload) {
          if (cannotHaveBody) {
            throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
          }
          if ([isBody, isForm, isJSON].filter((isTrue) => isTrue).length > 1) {
            throw new TypeError("The `body`, `json` and `form` options are mutually exclusive");
          }
          if (isBody && !(options.body instanceof stream_1.Readable) && !is_1.default.string(options.body) && !is_1.default.buffer(options.body) && !is_form_data_1.default(options.body)) {
            throw new TypeError("The `body` option must be a stream.Readable, string or Buffer");
          }
          if (isForm && !is_1.default.object(options.form)) {
            throw new TypeError("The `form` option must be an Object");
          }
          {
            const noContentType = !is_1.default.string(headers["content-type"]);
            if (isBody) {
              if (is_form_data_1.default(options.body) && noContentType) {
                headers["content-type"] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
              }
              this[kBody] = options.body;
            } else if (isForm) {
              if (noContentType) {
                headers["content-type"] = "application/x-www-form-urlencoded";
              }
              this[kBody] = new url_1.URLSearchParams(options.form).toString();
            } else {
              if (noContentType) {
                headers["content-type"] = "application/json";
              }
              this[kBody] = options.stringifyJson(options.json);
            }
            const uploadBodySize = await get_body_size_1.default(this[kBody], options.headers);
            if (is_1.default.undefined(headers["content-length"]) && is_1.default.undefined(headers["transfer-encoding"])) {
              if (!cannotHaveBody && !is_1.default.undefined(uploadBodySize)) {
                headers["content-length"] = String(uploadBodySize);
              }
            }
          }
        } else if (cannotHaveBody) {
          this._lockWrite();
        } else {
          this._unlockWrite();
        }
        this[kBodySize] = Number(headers["content-length"]) || void 0;
      }
      async _onResponseBase(response) {
        const { options } = this;
        const { url } = options;
        this[kOriginalResponse] = response;
        if (options.decompress) {
          response = decompressResponse(response);
        }
        const statusCode = response.statusCode;
        const typedResponse = response;
        typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];
        typedResponse.url = options.url.toString();
        typedResponse.requestUrl = this.requestUrl;
        typedResponse.redirectUrls = this.redirects;
        typedResponse.request = this;
        typedResponse.isFromCache = response.fromCache || false;
        typedResponse.ip = this.ip;
        typedResponse.retryCount = this.retryCount;
        this[kIsFromCache] = typedResponse.isFromCache;
        this[kResponseSize] = Number(response.headers["content-length"]) || void 0;
        this[kResponse] = response;
        response.once("end", () => {
          this[kResponseSize] = this[kDownloadedSize];
          this.emit("downloadProgress", this.downloadProgress);
        });
        response.once("error", (error) => {
          response.destroy();
          this._beforeError(new ReadError(error, this));
        });
        response.once("aborted", () => {
          this._beforeError(new ReadError({
            name: "Error",
            message: "The server aborted pending request",
            code: "ECONNRESET"
          }, this));
        });
        this.emit("downloadProgress", this.downloadProgress);
        const rawCookies = response.headers["set-cookie"];
        if (is_1.default.object(options.cookieJar) && rawCookies) {
          let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));
          if (options.ignoreInvalidCookies) {
            promises = promises.map(async (p) => p.catch(() => {
            }));
          }
          try {
            await Promise.all(promises);
          } catch (error) {
            this._beforeError(error);
            return;
          }
        }
        if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {
          response.resume();
          if (this[kRequest]) {
            this[kCancelTimeouts]();
            delete this[kRequest];
            this[kUnproxyEvents]();
          }
          const shouldBeGet = statusCode === 303 && options.method !== "GET" && options.method !== "HEAD";
          if (shouldBeGet || !options.methodRewriting) {
            options.method = "GET";
            if ("body" in options) {
              delete options.body;
            }
            if ("json" in options) {
              delete options.json;
            }
            if ("form" in options) {
              delete options.form;
            }
            this[kBody] = void 0;
            delete options.headers["content-length"];
          }
          if (this.redirects.length >= options.maxRedirects) {
            this._beforeError(new MaxRedirectsError(this));
            return;
          }
          try {
            const redirectBuffer = Buffer.from(response.headers.location, "binary").toString();
            const redirectUrl = new url_1.URL(redirectBuffer, url);
            const redirectString = redirectUrl.toString();
            decodeURI(redirectString);
            if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {
              if ("host" in options.headers) {
                delete options.headers.host;
              }
              if ("cookie" in options.headers) {
                delete options.headers.cookie;
              }
              if ("authorization" in options.headers) {
                delete options.headers.authorization;
              }
              if (options.username || options.password) {
                options.username = "";
                options.password = "";
              }
            } else {
              redirectUrl.username = options.username;
              redirectUrl.password = options.password;
            }
            this.redirects.push(redirectString);
            options.url = redirectUrl;
            for (const hook of options.hooks.beforeRedirect) {
              await hook(options, typedResponse);
            }
            this.emit("redirect", typedResponse, options);
            await this._makeRequest();
          } catch (error) {
            this._beforeError(error);
            return;
          }
          return;
        }
        if (options.isStream && options.throwHttpErrors && !is_response_ok_1.isResponseOk(typedResponse)) {
          this._beforeError(new HTTPError(typedResponse));
          return;
        }
        response.on("readable", () => {
          if (this[kTriggerRead]) {
            this._read();
          }
        });
        this.on("resume", () => {
          response.resume();
        });
        this.on("pause", () => {
          response.pause();
        });
        response.once("end", () => {
          this.push(null);
        });
        this.emit("response", response);
        for (const destination of this[kServerResponsesPiped]) {
          if (destination.headersSent) {
            continue;
          }
          for (const key in response.headers) {
            const isAllowed = options.decompress ? key !== "content-encoding" : true;
            const value = response.headers[key];
            if (isAllowed) {
              destination.setHeader(key, value);
            }
          }
          destination.statusCode = statusCode;
        }
      }
      async _onResponse(response) {
        try {
          await this._onResponseBase(response);
        } catch (error) {
          this._beforeError(error);
        }
      }
      _onRequest(request) {
        const { options } = this;
        const { timeout, url } = options;
        http_timer_1.default(request);
        this[kCancelTimeouts] = timed_out_1.default(request, timeout, url);
        const responseEventName = options.cache ? "cacheableResponse" : "response";
        request.once(responseEventName, (response) => {
          void this._onResponse(response);
        });
        request.once("error", (error) => {
          var _a;
          request.destroy();
          (_a = request.res) === null || _a === void 0 ? void 0 : _a.removeAllListeners("end");
          error = error instanceof timed_out_1.TimeoutError ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);
          this._beforeError(error);
        });
        this[kUnproxyEvents] = proxy_events_1.default(request, this, proxiedRequestEvents);
        this[kRequest] = request;
        this.emit("uploadProgress", this.uploadProgress);
        const body = this[kBody];
        const currentRequest = this.redirects.length === 0 ? this : request;
        if (is_1.default.nodeStream(body)) {
          body.pipe(currentRequest);
          body.once("error", (error) => {
            this._beforeError(new UploadError(error, this));
          });
        } else {
          this._unlockWrite();
          if (!is_1.default.undefined(body)) {
            this._writeRequest(body, void 0, () => {
            });
            currentRequest.end();
            this._lockWrite();
          } else if (this._cannotHaveBody || this._noPipe) {
            currentRequest.end();
            this._lockWrite();
          }
        }
        this.emit("request", request);
      }
      async _createCacheableRequest(url, options) {
        return new Promise((resolve, reject) => {
          Object.assign(options, url_to_options_1.default(url));
          delete options.url;
          let request;
          const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {
            response._readableState.autoDestroy = false;
            if (request) {
              (await request).emit("cacheableResponse", response);
            }
            resolve(response);
          });
          options.url = url;
          cacheRequest.once("error", reject);
          cacheRequest.once("request", async (requestOrPromise) => {
            request = requestOrPromise;
            resolve(request);
          });
        });
      }
      async _makeRequest() {
        var _a, _b, _c, _d, _e;
        const { options } = this;
        const { headers } = options;
        for (const key in headers) {
          if (is_1.default.undefined(headers[key])) {
            delete headers[key];
          } else if (is_1.default.null_(headers[key])) {
            throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
          }
        }
        if (options.decompress && is_1.default.undefined(headers["accept-encoding"])) {
          headers["accept-encoding"] = supportsBrotli ? "gzip, deflate, br" : "gzip, deflate";
        }
        if (options.cookieJar) {
          const cookieString = await options.cookieJar.getCookieString(options.url.toString());
          if (is_1.default.nonEmptyString(cookieString)) {
            options.headers.cookie = cookieString;
          }
        }
        for (const hook of options.hooks.beforeRequest) {
          const result = await hook(options);
          if (!is_1.default.undefined(result)) {
            options.request = () => result;
            break;
          }
        }
        if (options.body && this[kBody] !== options.body) {
          this[kBody] = options.body;
        }
        const { agent, request, timeout, url } = options;
        if (options.dnsCache && !("lookup" in options)) {
          options.lookup = options.dnsCache.lookup;
        }
        if (url.hostname === "unix") {
          const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
          if (matches === null || matches === void 0 ? void 0 : matches.groups) {
            const { socketPath, path } = matches.groups;
            Object.assign(options, {
              socketPath,
              path,
              host: ""
            });
          }
        }
        const isHttps = url.protocol === "https:";
        let fallbackFn;
        if (options.http2) {
          fallbackFn = http2wrapper.auto;
        } else {
          fallbackFn = isHttps ? https.request : http.request;
        }
        const realFn = (_a = options.request) !== null && _a !== void 0 ? _a : fallbackFn;
        const fn = options.cache ? this._createCacheableRequest : realFn;
        if (agent && !options.http2) {
          options.agent = agent[isHttps ? "https" : "http"];
        }
        options[kRequest] = realFn;
        delete options.request;
        delete options.timeout;
        const requestOptions = options;
        requestOptions.shared = (_b = options.cacheOptions) === null || _b === void 0 ? void 0 : _b.shared;
        requestOptions.cacheHeuristic = (_c = options.cacheOptions) === null || _c === void 0 ? void 0 : _c.cacheHeuristic;
        requestOptions.immutableMinTimeToLive = (_d = options.cacheOptions) === null || _d === void 0 ? void 0 : _d.immutableMinTimeToLive;
        requestOptions.ignoreCargoCult = (_e = options.cacheOptions) === null || _e === void 0 ? void 0 : _e.ignoreCargoCult;
        if (options.dnsLookupIpVersion !== void 0) {
          try {
            requestOptions.family = dns_ip_version_1.dnsLookupIpVersionToFamily(options.dnsLookupIpVersion);
          } catch (_f) {
            throw new Error("Invalid `dnsLookupIpVersion` option value");
          }
        }
        if (options.https) {
          if ("rejectUnauthorized" in options.https) {
            requestOptions.rejectUnauthorized = options.https.rejectUnauthorized;
          }
          if (options.https.checkServerIdentity) {
            requestOptions.checkServerIdentity = options.https.checkServerIdentity;
          }
          if (options.https.certificateAuthority) {
            requestOptions.ca = options.https.certificateAuthority;
          }
          if (options.https.certificate) {
            requestOptions.cert = options.https.certificate;
          }
          if (options.https.key) {
            requestOptions.key = options.https.key;
          }
          if (options.https.passphrase) {
            requestOptions.passphrase = options.https.passphrase;
          }
          if (options.https.pfx) {
            requestOptions.pfx = options.https.pfx;
          }
        }
        try {
          let requestOrResponse = await fn(url, requestOptions);
          if (is_1.default.undefined(requestOrResponse)) {
            requestOrResponse = fallbackFn(url, requestOptions);
          }
          options.request = request;
          options.timeout = timeout;
          options.agent = agent;
          if (options.https) {
            if ("rejectUnauthorized" in options.https) {
              delete requestOptions.rejectUnauthorized;
            }
            if (options.https.checkServerIdentity) {
              delete requestOptions.checkServerIdentity;
            }
            if (options.https.certificateAuthority) {
              delete requestOptions.ca;
            }
            if (options.https.certificate) {
              delete requestOptions.cert;
            }
            if (options.https.key) {
              delete requestOptions.key;
            }
            if (options.https.passphrase) {
              delete requestOptions.passphrase;
            }
            if (options.https.pfx) {
              delete requestOptions.pfx;
            }
          }
          if (isClientRequest(requestOrResponse)) {
            this._onRequest(requestOrResponse);
          } else if (this.writable) {
            this.once("finish", () => {
              void this._onResponse(requestOrResponse);
            });
            this._unlockWrite();
            this.end();
            this._lockWrite();
          } else {
            void this._onResponse(requestOrResponse);
          }
        } catch (error) {
          if (error instanceof CacheableRequest.CacheError) {
            throw new CacheError(error, this);
          }
          throw new RequestError(error.message, error, this);
        }
      }
      async _error(error) {
        try {
          for (const hook of this.options.hooks.beforeError) {
            error = await hook(error);
          }
        } catch (error_) {
          error = new RequestError(error_.message, error_, this);
        }
        this.destroy(error);
      }
      _beforeError(error) {
        if (this[kStopReading]) {
          return;
        }
        const { options } = this;
        const retryCount = this.retryCount + 1;
        this[kStopReading] = true;
        if (!(error instanceof RequestError)) {
          error = new RequestError(error.message, error, this);
        }
        const typedError = error;
        const { response } = typedError;
        void (async () => {
          if (response && !response.body) {
            response.setEncoding(this._readableState.encoding);
            try {
              response.rawBody = await get_buffer_1.default(response);
              response.body = response.rawBody.toString();
            } catch (_a) {
            }
          }
          if (this.listenerCount("retry") !== 0) {
            let backoff;
            try {
              let retryAfter;
              if (response && "retry-after" in response.headers) {
                retryAfter = Number(response.headers["retry-after"]);
                if (Number.isNaN(retryAfter)) {
                  retryAfter = Date.parse(response.headers["retry-after"]) - Date.now();
                  if (retryAfter <= 0) {
                    retryAfter = 1;
                  }
                } else {
                  retryAfter *= 1e3;
                }
              }
              backoff = await options.retry.calculateDelay({
                attemptCount: retryCount,
                retryOptions: options.retry,
                error: typedError,
                retryAfter,
                computedValue: calculate_retry_delay_1.default({
                  attemptCount: retryCount,
                  retryOptions: options.retry,
                  error: typedError,
                  retryAfter,
                  computedValue: 0
                })
              });
            } catch (error_) {
              void this._error(new RequestError(error_.message, error_, this));
              return;
            }
            if (backoff) {
              const retry = async () => {
                try {
                  for (const hook of this.options.hooks.beforeRetry) {
                    await hook(this.options, typedError, retryCount);
                  }
                } catch (error_) {
                  void this._error(new RequestError(error_.message, error, this));
                  return;
                }
                if (this.destroyed) {
                  return;
                }
                this.destroy();
                this.emit("retry", retryCount, error);
              };
              this[kRetryTimeout] = setTimeout(retry, backoff);
              return;
            }
          }
          void this._error(typedError);
        })();
      }
      _read() {
        this[kTriggerRead] = true;
        const response = this[kResponse];
        if (response && !this[kStopReading]) {
          if (response.readableLength) {
            this[kTriggerRead] = false;
          }
          let data;
          while ((data = response.read()) !== null) {
            this[kDownloadedSize] += data.length;
            this[kStartedReading] = true;
            const progress = this.downloadProgress;
            if (progress.percent < 1) {
              this.emit("downloadProgress", progress);
            }
            this.push(data);
          }
        }
      }
      _write(chunk, encoding, callback) {
        const write = () => {
          this._writeRequest(chunk, encoding, callback);
        };
        if (this.requestInitialized) {
          write();
        } else {
          this[kJobs].push(write);
        }
      }
      _writeRequest(chunk, encoding, callback) {
        if (this[kRequest].destroyed) {
          return;
        }
        this._progressCallbacks.push(() => {
          this[kUploadedSize] += Buffer.byteLength(chunk, encoding);
          const progress = this.uploadProgress;
          if (progress.percent < 1) {
            this.emit("uploadProgress", progress);
          }
        });
        this[kRequest].write(chunk, encoding, (error) => {
          if (!error && this._progressCallbacks.length > 0) {
            this._progressCallbacks.shift()();
          }
          callback(error);
        });
      }
      _final(callback) {
        const endRequest = () => {
          while (this._progressCallbacks.length !== 0) {
            this._progressCallbacks.shift()();
          }
          if (!(kRequest in this)) {
            callback();
            return;
          }
          if (this[kRequest].destroyed) {
            callback();
            return;
          }
          this[kRequest].end((error) => {
            if (!error) {
              this[kBodySize] = this[kUploadedSize];
              this.emit("uploadProgress", this.uploadProgress);
              this[kRequest].emit("upload-complete");
            }
            callback(error);
          });
        };
        if (this.requestInitialized) {
          endRequest();
        } else {
          this[kJobs].push(endRequest);
        }
      }
      _destroy(error, callback) {
        var _a;
        this[kStopReading] = true;
        clearTimeout(this[kRetryTimeout]);
        if (kRequest in this) {
          this[kCancelTimeouts]();
          if (!((_a = this[kResponse]) === null || _a === void 0 ? void 0 : _a.complete)) {
            this[kRequest].destroy();
          }
        }
        if (error !== null && !is_1.default.undefined(error) && !(error instanceof RequestError)) {
          error = new RequestError(error.message, error, this);
        }
        callback(error);
      }
      get _isAboutToError() {
        return this[kStopReading];
      }
      get ip() {
        var _a;
        return (_a = this.socket) === null || _a === void 0 ? void 0 : _a.remoteAddress;
      }
      get aborted() {
        var _a, _b, _c;
        return ((_b = (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.destroyed) !== null && _b !== void 0 ? _b : this.destroyed) && !((_c = this[kOriginalResponse]) === null || _c === void 0 ? void 0 : _c.complete);
      }
      get socket() {
        var _a, _b;
        return (_b = (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.socket) !== null && _b !== void 0 ? _b : void 0;
      }
      get downloadProgress() {
        let percent;
        if (this[kResponseSize]) {
          percent = this[kDownloadedSize] / this[kResponseSize];
        } else if (this[kResponseSize] === this[kDownloadedSize]) {
          percent = 1;
        } else {
          percent = 0;
        }
        return {
          percent,
          transferred: this[kDownloadedSize],
          total: this[kResponseSize]
        };
      }
      get uploadProgress() {
        let percent;
        if (this[kBodySize]) {
          percent = this[kUploadedSize] / this[kBodySize];
        } else if (this[kBodySize] === this[kUploadedSize]) {
          percent = 1;
        } else {
          percent = 0;
        }
        return {
          percent,
          transferred: this[kUploadedSize],
          total: this[kBodySize]
        };
      }
      get timings() {
        var _a;
        return (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.timings;
      }
      get isFromCache() {
        return this[kIsFromCache];
      }
      pipe(destination, options) {
        if (this[kStartedReading]) {
          throw new Error("Failed to pipe. The response has been emitted already.");
        }
        if (destination instanceof http_1.ServerResponse) {
          this[kServerResponsesPiped].add(destination);
        }
        return super.pipe(destination, options);
      }
      unpipe(destination) {
        if (destination instanceof http_1.ServerResponse) {
          this[kServerResponsesPiped].delete(destination);
        }
        super.unpipe(destination);
        return this;
      }
    };
    exports2.default = Request2;
  }
});

// node_modules/got/dist/source/as-promise/types.js
var require_types = __commonJS({
  "node_modules/got/dist/source/as-promise/types.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancelError = exports2.ParseError = void 0;
    var core_1 = require_core();
    var ParseError = class extends core_1.RequestError {
      constructor(error, response) {
        const { options } = response.request;
        super(`${error.message} in "${options.url.toString()}"`, error, response.request);
        this.name = "ParseError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_BODY_PARSE_FAILURE" : this.code;
      }
    };
    exports2.ParseError = ParseError;
    var CancelError = class extends core_1.RequestError {
      constructor(request) {
        super("Promise was canceled", {}, request);
        this.name = "CancelError";
        this.code = "ERR_CANCELED";
      }
      get isCanceled() {
        return true;
      }
    };
    exports2.CancelError = CancelError;
    __exportStar(require_core(), exports2);
  }
});

// node_modules/got/dist/source/as-promise/parse-body.js
var require_parse_body = __commonJS({
  "node_modules/got/dist/source/as-promise/parse-body.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var types_1 = require_types();
    var parseBody = (response, responseType, parseJson, encoding) => {
      const { rawBody } = response;
      try {
        if (responseType === "text") {
          return rawBody.toString(encoding);
        }
        if (responseType === "json") {
          return rawBody.length === 0 ? "" : parseJson(rawBody.toString());
        }
        if (responseType === "buffer") {
          return rawBody;
        }
        throw new types_1.ParseError({
          message: `Unknown body type '${responseType}'`,
          name: "Error"
        }, response);
      } catch (error) {
        throw new types_1.ParseError(error, response);
      }
    };
    exports2.default = parseBody;
  }
});

// node_modules/got/dist/source/as-promise/index.js
var require_as_promise = __commonJS({
  "node_modules/got/dist/source/as-promise/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require("events");
    var is_1 = require_dist();
    var PCancelable = require_p_cancelable();
    var types_1 = require_types();
    var parse_body_1 = require_parse_body();
    var core_1 = require_core();
    var proxy_events_1 = require_proxy_events2();
    var get_buffer_1 = require_get_buffer();
    var is_response_ok_1 = require_is_response_ok();
    var proxiedRequestEvents = [
      "request",
      "response",
      "redirect",
      "uploadProgress",
      "downloadProgress"
    ];
    function asPromise(normalizedOptions) {
      let globalRequest;
      let globalResponse;
      const emitter = new events_1.EventEmitter();
      const promise = new PCancelable((resolve, reject, onCancel) => {
        const makeRequest = (retryCount) => {
          const request = new core_1.default(void 0, normalizedOptions);
          request.retryCount = retryCount;
          request._noPipe = true;
          onCancel(() => request.destroy());
          onCancel.shouldReject = false;
          onCancel(() => reject(new types_1.CancelError(request)));
          globalRequest = request;
          request.once("response", async (response) => {
            var _a;
            response.retryCount = retryCount;
            if (response.request.aborted) {
              return;
            }
            let rawBody;
            try {
              rawBody = await get_buffer_1.default(request);
              response.rawBody = rawBody;
            } catch (_b) {
              return;
            }
            if (request._isAboutToError) {
              return;
            }
            const contentEncoding = ((_a = response.headers["content-encoding"]) !== null && _a !== void 0 ? _a : "").toLowerCase();
            const isCompressed = ["gzip", "deflate", "br"].includes(contentEncoding);
            const { options } = request;
            if (isCompressed && !options.decompress) {
              response.body = rawBody;
            } else {
              try {
                response.body = parse_body_1.default(response, options.responseType, options.parseJson, options.encoding);
              } catch (error) {
                response.body = rawBody.toString();
                if (is_response_ok_1.isResponseOk(response)) {
                  request._beforeError(error);
                  return;
                }
              }
            }
            try {
              for (const [index, hook] of options.hooks.afterResponse.entries()) {
                response = await hook(response, async (updatedOptions) => {
                  const typedOptions = core_1.default.normalizeArguments(void 0, __spreadProps(__spreadValues({}, updatedOptions), {
                    retry: {
                      calculateDelay: () => 0
                    },
                    throwHttpErrors: false,
                    resolveBodyOnly: false
                  }), options);
                  typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);
                  for (const hook2 of typedOptions.hooks.beforeRetry) {
                    await hook2(typedOptions);
                  }
                  const promise2 = asPromise(typedOptions);
                  onCancel(() => {
                    promise2.catch(() => {
                    });
                    promise2.cancel();
                  });
                  return promise2;
                });
              }
            } catch (error) {
              request._beforeError(new types_1.RequestError(error.message, error, request));
              return;
            }
            if (!is_response_ok_1.isResponseOk(response)) {
              request._beforeError(new types_1.HTTPError(response));
              return;
            }
            globalResponse = response;
            resolve(request.options.resolveBodyOnly ? response.body : response);
          });
          const onError = (error) => {
            if (promise.isCanceled) {
              return;
            }
            const { options } = request;
            if (error instanceof types_1.HTTPError && !options.throwHttpErrors) {
              const { response } = error;
              resolve(request.options.resolveBodyOnly ? response.body : response);
              return;
            }
            reject(error);
          };
          request.once("error", onError);
          const previousBody = request.options.body;
          request.once("retry", (newRetryCount, error) => {
            var _a, _b;
            if (previousBody === ((_a = error.request) === null || _a === void 0 ? void 0 : _a.options.body) && is_1.default.nodeStream((_b = error.request) === null || _b === void 0 ? void 0 : _b.options.body)) {
              onError(error);
              return;
            }
            makeRequest(newRetryCount);
          });
          proxy_events_1.default(request, emitter, proxiedRequestEvents);
        };
        makeRequest(0);
      });
      promise.on = (event, fn) => {
        emitter.on(event, fn);
        return promise;
      };
      const shortcut = (responseType) => {
        const newPromise = (async () => {
          await promise;
          const { options } = globalResponse.request;
          return parse_body_1.default(globalResponse, responseType, options.parseJson, options.encoding);
        })();
        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
        return newPromise;
      };
      promise.json = () => {
        const { headers } = globalRequest.options;
        if (!globalRequest.writableFinished && headers.accept === void 0) {
          headers.accept = "application/json";
        }
        return shortcut("json");
      };
      promise.buffer = () => shortcut("buffer");
      promise.text = () => shortcut("text");
      return promise;
    }
    exports2.default = asPromise;
    __exportStar(require_types(), exports2);
  }
});

// node_modules/got/dist/source/as-promise/create-rejection.js
var require_create_rejection = __commonJS({
  "node_modules/got/dist/source/as-promise/create-rejection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var types_1 = require_types();
    function createRejection(error, ...beforeErrorGroups) {
      const promise = (async () => {
        if (error instanceof types_1.RequestError) {
          try {
            for (const hooks of beforeErrorGroups) {
              if (hooks) {
                for (const hook of hooks) {
                  error = await hook(error);
                }
              }
            }
          } catch (error_) {
            error = error_;
          }
        }
        throw error;
      })();
      const returnPromise = () => promise;
      promise.json = returnPromise;
      promise.text = returnPromise;
      promise.buffer = returnPromise;
      promise.on = returnPromise;
      return promise;
    }
    exports2.default = createRejection;
  }
});

// node_modules/got/dist/source/utils/deep-freeze.js
var require_deep_freeze = __commonJS({
  "node_modules/got/dist/source/utils/deep-freeze.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var is_1 = require_dist();
    function deepFreeze(object) {
      for (const value of Object.values(object)) {
        if (is_1.default.plainObject(value) || is_1.default.array(value)) {
          deepFreeze(value);
        }
      }
      return Object.freeze(object);
    }
    exports2.default = deepFreeze;
  }
});

// node_modules/got/dist/source/types.js
var require_types2 = __commonJS({
  "node_modules/got/dist/source/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/got/dist/source/create.js
var require_create = __commonJS({
  "node_modules/got/dist/source/create.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultHandler = void 0;
    var is_1 = require_dist();
    var as_promise_1 = require_as_promise();
    var create_rejection_1 = require_create_rejection();
    var core_1 = require_core();
    var deep_freeze_1 = require_deep_freeze();
    var errors = {
      RequestError: as_promise_1.RequestError,
      CacheError: as_promise_1.CacheError,
      ReadError: as_promise_1.ReadError,
      HTTPError: as_promise_1.HTTPError,
      MaxRedirectsError: as_promise_1.MaxRedirectsError,
      TimeoutError: as_promise_1.TimeoutError,
      ParseError: as_promise_1.ParseError,
      CancelError: as_promise_1.CancelError,
      UnsupportedProtocolError: as_promise_1.UnsupportedProtocolError,
      UploadError: as_promise_1.UploadError
    };
    var delay = async (ms) => new Promise((resolve) => {
      setTimeout(resolve, ms);
    });
    var { normalizeArguments } = core_1.default;
    var mergeOptions = (...sources) => {
      let mergedOptions;
      for (const source of sources) {
        mergedOptions = normalizeArguments(void 0, source, mergedOptions);
      }
      return mergedOptions;
    };
    var getPromiseOrStream = (options) => options.isStream ? new core_1.default(void 0, options) : as_promise_1.default(options);
    var isGotInstance = (value) => "defaults" in value && "options" in value.defaults;
    var aliases = [
      "get",
      "post",
      "put",
      "patch",
      "head",
      "delete"
    ];
    exports2.defaultHandler = (options, next) => next(options);
    var callInitHooks = (hooks, options) => {
      if (hooks) {
        for (const hook of hooks) {
          hook(options);
        }
      }
    };
    var create = (defaults) => {
      defaults._rawHandlers = defaults.handlers;
      defaults.handlers = defaults.handlers.map((fn) => (options, next) => {
        let root;
        const result = fn(options, (newOptions) => {
          root = next(newOptions);
          return root;
        });
        if (result !== root && !options.isStream && root) {
          const typedResult = result;
          const { then: promiseThen, catch: promiseCatch, finally: promiseFianlly } = typedResult;
          Object.setPrototypeOf(typedResult, Object.getPrototypeOf(root));
          Object.defineProperties(typedResult, Object.getOwnPropertyDescriptors(root));
          typedResult.then = promiseThen;
          typedResult.catch = promiseCatch;
          typedResult.finally = promiseFianlly;
        }
        return result;
      });
      const got = (url, options = {}, _defaults) => {
        var _a, _b;
        let iteration = 0;
        const iterateHandlers = (newOptions) => {
          return defaults.handlers[iteration++](newOptions, iteration === defaults.handlers.length ? getPromiseOrStream : iterateHandlers);
        };
        if (is_1.default.plainObject(url)) {
          const mergedOptions = __spreadValues(__spreadValues({}, url), options);
          core_1.setNonEnumerableProperties([url, options], mergedOptions);
          options = mergedOptions;
          url = void 0;
        }
        try {
          let initHookError;
          try {
            callInitHooks(defaults.options.hooks.init, options);
            callInitHooks((_a = options.hooks) === null || _a === void 0 ? void 0 : _a.init, options);
          } catch (error) {
            initHookError = error;
          }
          const normalizedOptions = normalizeArguments(url, options, _defaults !== null && _defaults !== void 0 ? _defaults : defaults.options);
          normalizedOptions[core_1.kIsNormalizedAlready] = true;
          if (initHookError) {
            throw new as_promise_1.RequestError(initHookError.message, initHookError, normalizedOptions);
          }
          return iterateHandlers(normalizedOptions);
        } catch (error) {
          if (options.isStream) {
            throw error;
          } else {
            return create_rejection_1.default(error, defaults.options.hooks.beforeError, (_b = options.hooks) === null || _b === void 0 ? void 0 : _b.beforeError);
          }
        }
      };
      got.extend = (...instancesOrOptions) => {
        const optionsArray = [defaults.options];
        let handlers = [...defaults._rawHandlers];
        let isMutableDefaults;
        for (const value of instancesOrOptions) {
          if (isGotInstance(value)) {
            optionsArray.push(value.defaults.options);
            handlers.push(...value.defaults._rawHandlers);
            isMutableDefaults = value.defaults.mutableDefaults;
          } else {
            optionsArray.push(value);
            if ("handlers" in value) {
              handlers.push(...value.handlers);
            }
            isMutableDefaults = value.mutableDefaults;
          }
        }
        handlers = handlers.filter((handler) => handler !== exports2.defaultHandler);
        if (handlers.length === 0) {
          handlers.push(exports2.defaultHandler);
        }
        return create({
          options: mergeOptions(...optionsArray),
          handlers,
          mutableDefaults: Boolean(isMutableDefaults)
        });
      };
      const paginateEach = async function* (url, options) {
        let normalizedOptions = normalizeArguments(url, options, defaults.options);
        normalizedOptions.resolveBodyOnly = false;
        const pagination = normalizedOptions.pagination;
        if (!is_1.default.object(pagination)) {
          throw new TypeError("`options.pagination` must be implemented");
        }
        const all = [];
        let { countLimit } = pagination;
        let numberOfRequests = 0;
        while (numberOfRequests < pagination.requestLimit) {
          if (numberOfRequests !== 0) {
            await delay(pagination.backoff);
          }
          const result = await got(void 0, void 0, normalizedOptions);
          const parsed = await pagination.transform(result);
          const current = [];
          for (const item of parsed) {
            if (pagination.filter(item, all, current)) {
              if (!pagination.shouldContinue(item, all, current)) {
                return;
              }
              yield item;
              if (pagination.stackAllItems) {
                all.push(item);
              }
              current.push(item);
              if (--countLimit <= 0) {
                return;
              }
            }
          }
          const optionsToMerge = pagination.paginate(result, all, current);
          if (optionsToMerge === false) {
            return;
          }
          if (optionsToMerge === result.request.options) {
            normalizedOptions = result.request.options;
          } else if (optionsToMerge !== void 0) {
            normalizedOptions = normalizeArguments(void 0, optionsToMerge, normalizedOptions);
          }
          numberOfRequests++;
        }
      };
      got.paginate = paginateEach;
      got.paginate.all = async (url, options) => {
        const results = [];
        for await (const item of paginateEach(url, options)) {
          results.push(item);
        }
        return results;
      };
      got.paginate.each = paginateEach;
      got.stream = (url, options) => got(url, __spreadProps(__spreadValues({}, options), { isStream: true }));
      for (const method of aliases) {
        got[method] = (url, options) => got(url, __spreadProps(__spreadValues({}, options), { method }));
        got.stream[method] = (url, options) => {
          return got(url, __spreadProps(__spreadValues({}, options), { method, isStream: true }));
        };
      }
      Object.assign(got, errors);
      Object.defineProperty(got, "defaults", {
        value: defaults.mutableDefaults ? defaults : deep_freeze_1.default(defaults),
        writable: defaults.mutableDefaults,
        configurable: defaults.mutableDefaults,
        enumerable: true
      });
      got.mergeOptions = mergeOptions;
      return got;
    };
    exports2.default = create;
    __exportStar(require_types2(), exports2);
  }
});

// node_modules/got/dist/source/index.js
var require_source5 = __commonJS({
  "node_modules/got/dist/source/index.js"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var url_1 = require("url");
    var create_1 = require_create();
    var defaults = {
      options: {
        method: "GET",
        retry: {
          limit: 2,
          methods: [
            "GET",
            "PUT",
            "HEAD",
            "DELETE",
            "OPTIONS",
            "TRACE"
          ],
          statusCodes: [
            408,
            413,
            429,
            500,
            502,
            503,
            504,
            521,
            522,
            524
          ],
          errorCodes: [
            "ETIMEDOUT",
            "ECONNRESET",
            "EADDRINUSE",
            "ECONNREFUSED",
            "EPIPE",
            "ENOTFOUND",
            "ENETUNREACH",
            "EAI_AGAIN"
          ],
          maxRetryAfter: void 0,
          calculateDelay: ({ computedValue }) => computedValue
        },
        timeout: {},
        headers: {
          "user-agent": "got (https://github.com/sindresorhus/got)"
        },
        hooks: {
          init: [],
          beforeRequest: [],
          beforeRedirect: [],
          beforeRetry: [],
          beforeError: [],
          afterResponse: []
        },
        cache: void 0,
        dnsCache: void 0,
        decompress: true,
        throwHttpErrors: true,
        followRedirect: true,
        isStream: false,
        responseType: "text",
        resolveBodyOnly: false,
        maxRedirects: 10,
        prefixUrl: "",
        methodRewriting: true,
        ignoreInvalidCookies: false,
        context: {},
        http2: false,
        allowGetBody: false,
        https: void 0,
        pagination: {
          transform: (response) => {
            if (response.request.options.responseType === "json") {
              return response.body;
            }
            return JSON.parse(response.body);
          },
          paginate: (response) => {
            if (!Reflect.has(response.headers, "link")) {
              return false;
            }
            const items = response.headers.link.split(",");
            let next;
            for (const item of items) {
              const parsed = item.split(";");
              if (parsed[1].includes("next")) {
                next = parsed[0].trimStart().trim();
                next = next.slice(1, -1);
                break;
              }
            }
            if (next) {
              const options = {
                url: new url_1.URL(next)
              };
              return options;
            }
            return false;
          },
          filter: () => true,
          shouldContinue: () => true,
          countLimit: Infinity,
          backoff: 0,
          requestLimit: 1e4,
          stackAllItems: true
        },
        parseJson: (text) => JSON.parse(text),
        stringifyJson: (object) => JSON.stringify(object),
        cacheOptions: {}
      },
      handlers: [create_1.defaultHandler],
      mutableDefaults: false
    };
    var got = create_1.default(defaults);
    exports2.default = got;
    module2.exports = got;
    module2.exports.default = got;
    module2.exports.__esModule = true;
    __exportStar(require_create(), exports2);
    __exportStar(require_as_promise(), exports2);
  }
});

// node_modules/async-limiter/index.js
var require_async_limiter = __commonJS({
  "node_modules/async-limiter/index.js"(exports2, module2) {
    "use strict";
    function Queue(options) {
      if (!(this instanceof Queue)) {
        return new Queue(options);
      }
      options = options || {};
      this.concurrency = options.concurrency || Infinity;
      this.pending = 0;
      this.jobs = [];
      this.cbs = [];
      this._done = done.bind(this);
    }
    var arrayAddMethods = [
      "push",
      "unshift",
      "splice"
    ];
    arrayAddMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        var methodResult = Array.prototype[method].apply(this.jobs, arguments);
        this._run();
        return methodResult;
      };
    });
    Object.defineProperty(Queue.prototype, "length", {
      get: function() {
        return this.pending + this.jobs.length;
      }
    });
    Queue.prototype._run = function() {
      if (this.pending === this.concurrency) {
        return;
      }
      if (this.jobs.length) {
        var job = this.jobs.shift();
        this.pending++;
        job(this._done);
        this._run();
      }
      if (this.pending === 0) {
        while (this.cbs.length !== 0) {
          var cb = this.cbs.pop();
          process.nextTick(cb);
        }
      }
    };
    Queue.prototype.onDone = function(cb) {
      if (typeof cb === "function") {
        this.cbs.push(cb);
        this._run();
      }
    };
    function done() {
      this.pending--;
      this._run();
    }
    module2.exports = Queue;
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    function concat(list, totalLength) {
      const target = Buffer.allocUnsafe(totalLength);
      var offset = 0;
      for (var i = 0; i < list.length; i++) {
        const buf = list[i];
        buf.copy(target, offset);
        offset += buf.length;
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (var i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      const length = buffer.length;
      for (var i = 0; i < length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    try {
      const bufferUtil = require("bufferutil");
      const bu = bufferUtil.BufferUtil || bufferUtil;
      module2.exports = {
        mask(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bu.mask(source, mask, output, offset, length);
        },
        unmask(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bu.unmask(buffer, mask);
        },
        concat
      };
    } catch (e) {
      module2.exports = { concat, mask: _mask, unmask: _unmask };
    }
  }
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      EMPTY_BUFFER: Buffer.alloc(0),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var Limiter = require_async_limiter();
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var constants = require_constants();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var EMPTY_BLOCK = Buffer.from([0]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kWriteInProgress = Symbol("write-in-progress");
    var kPendingClose = Symbol("pending-close");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter({ concurrency });
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          if (this._inflate[kWriteInProgress]) {
            this._inflate[kPendingClose] = true;
          } else {
            this._inflate.close();
            this._inflate = null;
          }
        }
        if (this._deflate) {
          if (this._deflate[kWriteInProgress]) {
            this._deflate[kPendingClose] = true;
          } else {
            this._deflate.close();
            this._deflate = null;
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            var value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data, fin, callback) {
        zlibLimiter.push((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data, fin, callback) {
        zlibLimiter.push((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw(Object.assign({}, this._options.zlibInflateOptions, { windowBits }));
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate[kWriteInProgress] = true;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (fin && this.params[`${endpoint}_no_context_takeover`] || this._inflate[kPendingClose]) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kWriteInProgress] = false;
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
          }
          callback(null, data2);
        });
      }
      _compress(data, fin, callback) {
        if (!data || data.length === 0) {
          process.nextTick(callback, null, EMPTY_BLOCK);
          return;
        }
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw(Object.assign({
            memLevel: this._options.memLevel,
            level: this._options.level
          }, this._options.zlibDeflateOptions, { windowBits }));
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kWriteInProgress] = true;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          var data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          if (fin && this.params[`${endpoint}_no_context_takeover`] || this._deflate[kPendingClose]) {
            this._deflate.close();
            this._deflate = null;
          } else {
            this._deflate[kWriteInProgress] = false;
            this._deflate[kTotalLength] = 0;
            this._deflate[kBuffers] = [];
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError][constants.kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[constants.kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var Event = class {
      constructor(type, target) {
        this.target = target;
        this.type = type;
      }
    };
    var MessageEvent = class extends Event {
      constructor(data, target) {
        super("message", target);
        this.data = data;
      }
    };
    var CloseEvent = class extends Event {
      constructor(code, reason, target) {
        super("close", target);
        this.wasClean = target._closeFrameReceived && target._closeFrameSent;
        this.reason = reason;
        this.code = code;
      }
    };
    var OpenEvent = class extends Event {
      constructor(target) {
        super("open", target);
      }
    };
    var ErrorEvent = class extends Event {
      constructor(error, target) {
        super("error", target);
        this.message = error.message;
        this.error = error;
      }
    };
    var EventTarget = {
      addEventListener(method, listener) {
        if (typeof listener !== "function")
          return;
        function onMessage(data) {
          listener.call(this, new MessageEvent(data, this));
        }
        function onClose(code, message) {
          listener.call(this, new CloseEvent(code, message, this));
        }
        function onError(error) {
          listener.call(this, new ErrorEvent(error, this));
        }
        function onOpen() {
          listener.call(this, new OpenEvent(this));
        }
        if (method === "message") {
          onMessage._listener = listener;
          this.on(method, onMessage);
        } else if (method === "close") {
          onClose._listener = listener;
          this.on(method, onClose);
        } else if (method === "error") {
          onError._listener = listener;
          this.on(method, onError);
        } else if (method === "open") {
          onOpen._listener = listener;
          this.on(method, onOpen);
        } else {
          this.on(method, listener);
        }
      },
      removeEventListener(method, listener) {
        const listeners = this.listeners(method);
        for (var i = 0; i < listeners.length; i++) {
          if (listeners[i] === listener || listeners[i]._listener === listener) {
            this.removeListener(method, listeners[i]);
          }
        }
      }
    };
    module2.exports = EventTarget;
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function push(dest, name, elem) {
      if (Object.prototype.hasOwnProperty.call(dest, name))
        dest[name].push(elem);
      else
        dest[name] = [elem];
    }
    function parse(header) {
      const offers = {};
      if (header === void 0 || header === "")
        return offers;
      var params = {};
      var mustUnescape = false;
      var isEscaping = false;
      var inQuotes = false;
      var extensionName;
      var paramName;
      var start = -1;
      var end = -1;
      for (var i = 0; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = {};
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = {};
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            var value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = {};
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, {});
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        var configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(Object.keys(params).map((k) => {
            var values = params[k];
            if (!Array.isArray(values))
              values = [values];
            return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports2) {
    "use strict";
    try {
      const isValidUTF8 = require("utf-8-validate");
      exports2.isValidUTF8 = typeof isValidUTF8 === "object" ? isValidUTF8.Validation.isValidUTF8 : isValidUTF8;
    } catch (e) {
      exports2.isValidUTF8 = () => true;
    }
    exports2.isValidStatusCode = (code) => {
      return code >= 1e3 && code <= 1013 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    };
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var stream = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var bufferUtil = require_buffer_util();
    var validation = require_validation();
    var constants = require_constants();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends stream.Writable {
      constructor(binaryType, extensions, maxPayload) {
        super();
        this._binaryType = binaryType || constants.BINARY_TYPES[0];
        this[constants.kWebSocket] = void 0;
        this._extensions = extensions || {};
        this._maxPayload = maxPayload | 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          if (n >= buf.length) {
            this._buffers.shift().copy(dst, dst.length - n);
          } else {
            buf.copy(dst, dst.length - n, 0, n);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      startLoop(cb) {
        var err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002);
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002);
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002);
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(RangeError, "invalid opcode 0", true, 1002);
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(RangeError, "FIN must be set", true, 1002);
          }
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002);
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002);
          }
        } else {
          this._loop = false;
          return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009);
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(RangeError, "Max payload size exceeded", false, 1009);
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        var data = constants.EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked)
            bufferUtil.unmask(data, this._mask);
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(error(RangeError, "Max payload size exceeded", false, 1009));
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            var data;
            if (this._binaryType === "nodebuffer") {
              data = toBuffer(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(toBuffer(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data);
          } else {
            const buf = toBuffer(fragments, messageLength);
            if (!validation.isValidUTF8(buf)) {
              this._loop = false;
              return error(Error, "invalid UTF-8 sequence", true, 1007);
            }
            this.emit("message", buf.toString());
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, "");
            this.end();
          } else if (data.length === 1) {
            return error(RangeError, "invalid payload length 1", true, 1002);
          } else {
            const code = data.readUInt16BE(0);
            if (!validation.isValidStatusCode(code)) {
              return error(RangeError, `invalid status code ${code}`, true, 1002);
            }
            const buf = data.slice(2);
            if (!validation.isValidUTF8(buf)) {
              return error(Error, "invalid UTF-8 sequence", true, 1007);
            }
            this.emit("conclude", code, buf.toString());
            this.end();
          }
          return;
        }
        if (this._opcode === 9)
          this.emit("ping", data);
        else
          this.emit("pong", data);
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode) {
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, error);
      err[constants.kStatusCode] = statusCode;
      return err;
    }
    function toBuffer(fragments, messageLength) {
      if (fragments.length === 1)
        return fragments[0];
      if (fragments.length > 1)
        return bufferUtil.concat(fragments, messageLength);
      return constants.EMPTY_BUFFER;
    }
    function toArrayBuffer(buf) {
      if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var bufferUtil = require_buffer_util();
    var validation = require_validation();
    var constants = require_constants();
    var Sender = class {
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data, options) {
        const merge = data.length < 1024 || options.mask && options.readOnly;
        var offset = options.mask ? 6 : 2;
        var payloadLength = data.length;
        if (data.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        if (payloadLength === 126) {
          target.writeUInt16BE(data.length, 2);
        } else if (payloadLength === 127) {
          target.writeUInt32BE(0, 2);
          target.writeUInt32BE(data.length, 6);
        }
        if (!options.mask) {
          target[1] = payloadLength;
          if (merge) {
            data.copy(target, offset);
            return [target];
          }
          return [target, data];
        }
        const mask = crypto.randomBytes(4);
        target[1] = payloadLength | 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge) {
          bufferUtil.mask(data, mask, target, offset, data.length);
          return [target];
        }
        bufferUtil.mask(data, mask, data, 0, data.length);
        return [target, data];
      }
      close(code, data, mask, cb) {
        var buf;
        if (code === void 0) {
          buf = constants.EMPTY_BUFFER;
        } else if (typeof code !== "number" || !validation.isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || data === "") {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));
          buf.writeUInt16BE(code, 0);
          buf.write(data, 2);
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask, cb]);
        } else {
          this.doClose(buf, mask, cb);
        }
      }
      doClose(data, mask, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 8,
          mask,
          readOnly: false
        }), cb);
      }
      ping(data, mask, cb) {
        var readOnly = true;
        if (!Buffer.isBuffer(data)) {
          if (data instanceof ArrayBuffer) {
            data = Buffer.from(data);
          } else if (ArrayBuffer.isView(data)) {
            data = viewToBuffer(data);
          } else {
            data = Buffer.from(data);
            readOnly = false;
          }
        }
        if (this._deflating) {
          this.enqueue([this.doPing, data, mask, readOnly, cb]);
        } else {
          this.doPing(data, mask, readOnly, cb);
        }
      }
      doPing(data, mask, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 9,
          mask,
          readOnly
        }), cb);
      }
      pong(data, mask, cb) {
        var readOnly = true;
        if (!Buffer.isBuffer(data)) {
          if (data instanceof ArrayBuffer) {
            data = Buffer.from(data);
          } else if (ArrayBuffer.isView(data)) {
            data = viewToBuffer(data);
          } else {
            data = Buffer.from(data);
            readOnly = false;
          }
        }
        if (this._deflating) {
          this.enqueue([this.doPong, data, mask, readOnly, cb]);
        } else {
          this.doPong(data, mask, readOnly, cb);
        }
      }
      doPong(data, mask, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 10,
          mask,
          readOnly
        }), cb);
      }
      send(data, options, cb) {
        var opcode = options.binary ? 2 : 1;
        var rsv1 = options.compress;
        var readOnly = true;
        if (!Buffer.isBuffer(data)) {
          if (data instanceof ArrayBuffer) {
            data = Buffer.from(data);
          } else if (ArrayBuffer.isView(data)) {
            data = viewToBuffer(data);
          } else {
            data = Buffer.from(data);
            readOnly = false;
          }
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate) {
            rsv1 = data.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options.fin,
            rsv1,
            opcode,
            mask: options.mask,
            readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(Sender.frame(data, {
            fin: options.fin,
            rsv1: false,
            opcode,
            mask: options.mask,
            readOnly
          }), cb);
        }
      }
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this._deflating = false;
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          params[0].apply(this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
    function viewToBuffer(view) {
      const buf = Buffer.from(view.buffer);
      if (view.byteLength !== view.buffer.byteLength) {
        return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);
      }
      return buf;
    }
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var crypto = require("crypto");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var url = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var EventTarget = require_event_target();
    var extension = require_extension();
    var constants = require_constants();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var kWebSocket = constants.kWebSocket;
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket = class extends EventEmitter {
      constructor(address, protocols, options) {
        super();
        this.readyState = WebSocket.CONNECTING;
        this.protocol = "";
        this._binaryType = constants.BINARY_TYPES[0];
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = "";
        this._closeTimer = null;
        this._closeCode = 1006;
        this._extensions = {};
        this._isServer = true;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          if (Array.isArray(protocols)) {
            protocols = protocols.join(", ");
          } else if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = void 0;
          }
          initAsClient.call(this, address, protocols, options);
        }
      }
      get CONNECTING() {
        return WebSocket.CONNECTING;
      }
      get CLOSING() {
        return WebSocket.CLOSING;
      }
      get CLOSED() {
        return WebSocket.CLOSED;
      }
      get OPEN() {
        return WebSocket.OPEN;
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (constants.BINARY_TYPES.indexOf(type) < 0)
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return 0;
        return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      setSocket(socket, head, maxPayload) {
        const receiver = new Receiver(this._binaryType, this._extensions, maxPayload);
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this.readyState = WebSocket.OPEN;
        this.emit("open");
      }
      emitClose() {
        this.readyState = WebSocket.CLOSED;
        if (!this._socket) {
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && this._closeFrameReceived)
            this._socket.end();
          return;
        }
        this.readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._socket.writable) {
            if (this._closeFrameReceived)
              this._socket.end();
            this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
          }
        });
      }
      ping(data, mask, cb) {
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (this.readyState !== WebSocket.OPEN) {
          const err = new Error(`WebSocket is not open: readyState ${this.readyState} (${readyStates[this.readyState]})`);
          if (cb)
            return cb(err);
          throw err;
        }
        if (typeof data === "number")
          data = data.toString();
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || constants.EMPTY_BUFFER, mask, cb);
      }
      pong(data, mask, cb) {
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (this.readyState !== WebSocket.OPEN) {
          const err = new Error(`WebSocket is not open: readyState ${this.readyState} (${readyStates[this.readyState]})`);
          if (cb)
            return cb(err);
          throw err;
        }
        if (typeof data === "number")
          data = data.toString();
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || constants.EMPTY_BUFFER, mask, cb);
      }
      send(data, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (this.readyState !== WebSocket.OPEN) {
          const err = new Error(`WebSocket is not open: readyState ${this.readyState} (${readyStates[this.readyState]})`);
          if (cb)
            return cb(err);
          throw err;
        }
        if (typeof data === "number")
          data = data.toString();
        const opts = Object.assign({
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true
        }, options);
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || constants.EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this.readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    readyStates.forEach((readyState, i) => {
      WebSocket[readyStates[i]] = i;
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        get() {
          const listeners = this.listeners(method);
          for (var i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              return listeners[i]._listener;
          }
        },
        set(listener) {
          const listeners = this.listeners(method);
          for (var i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              this.removeListener(method, listeners[i]);
          }
          this.addEventListener(method, listener);
        }
      });
    });
    WebSocket.prototype.addEventListener = EventTarget.addEventListener;
    WebSocket.prototype.removeEventListener = EventTarget.removeEventListener;
    module2.exports = WebSocket;
    function initAsClient(address, protocols, options) {
      options = Object.assign({
        protocolVersion: protocolVersions[1],
        perMessageDeflate: true
      }, options, {
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        auth: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      });
      if (protocolVersions.indexOf(options.protocolVersion) === -1) {
        throw new RangeError(`Unsupported protocol version: ${options.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
      }
      this._isServer = false;
      var parsedUrl;
      if (typeof address === "object" && address.href !== void 0) {
        parsedUrl = address;
        this.url = address.href;
      } else {
        parsedUrl = url.parse(address);
        this.url = address;
      }
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
        throw new Error(`Invalid URL: ${this.url}`);
      }
      const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
      const key = crypto.randomBytes(16).toString("base64");
      const httpObj = isSecure ? https : http;
      const path = parsedUrl.search ? `${parsedUrl.pathname || "/"}${parsedUrl.search}` : parsedUrl.pathname || "/";
      var perMessageDeflate;
      options.createConnection = isSecure ? tlsConnect : netConnect;
      options.port = parsedUrl.port || (isSecure ? 443 : 80);
      options.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      options.headers = Object.assign({
        "Sec-WebSocket-Version": options.protocolVersion,
        "Sec-WebSocket-Key": key,
        "Connection": "Upgrade",
        "Upgrade": "websocket"
      }, options.headers);
      options.path = path;
      if (options.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(options.perMessageDeflate !== true ? options.perMessageDeflate : {}, false);
        options.headers["Sec-WebSocket-Extensions"] = extension.format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols) {
        options.headers["Sec-WebSocket-Protocol"] = protocols;
      }
      if (options.origin) {
        if (options.protocolVersion < 13) {
          options.headers["Sec-WebSocket-Origin"] = options.origin;
        } else {
          options.headers.Origin = options.origin;
        }
      }
      if (parsedUrl.auth) {
        options.auth = parsedUrl.auth;
      } else if (parsedUrl.username || parsedUrl.password) {
        options.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = path.split(":");
        if (options.agent == null && process.versions.modules < 57) {
          options._socketPath = parts[0];
        } else {
          options.socketPath = parts[0];
        }
        options.path = parts[1];
      }
      var req = this._req = httpObj.get(options);
      if (options.handshakeTimeout) {
        req.setTimeout(options.handshakeTimeout, () => abortHandshake(this, req, "Opening handshake has timed out"));
      }
      req.on("error", (err) => {
        if (this._req.aborted)
          return;
        req = this._req = null;
        this.readyState = WebSocket.CLOSING;
        this.emit("error", err);
        this.emitClose();
      });
      req.on("response", (res) => {
        if (this.emit("unexpected-response", req, res))
          return;
        abortHandshake(this, req, `Unexpected server response: ${res.statusCode}`);
      });
      req.on("upgrade", (res, socket, head) => {
        this.emit("upgrade", res);
        if (this.readyState !== WebSocket.CONNECTING)
          return;
        req = this._req = null;
        const digest = crypto.createHash("sha1").update(key + constants.GUID, "binary").digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(this, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        const protList = (protocols || "").split(/, */);
        var protError;
        if (!protocols && serverProt) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (protocols && !serverProt) {
          protError = "Server sent no subprotocol";
        } else if (serverProt && protList.indexOf(serverProt) === -1) {
          protError = "Server sent an invalid subprotocol";
        }
        if (protError) {
          abortHandshake(this, socket, protError);
          return;
        }
        if (serverProt)
          this.protocol = serverProt;
        if (perMessageDeflate) {
          try {
            const extensions = extension.parse(res.headers["sec-websocket-extensions"]);
            if (extensions[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
              this._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            abortHandshake(this, socket, "Invalid Sec-WebSocket-Extensions header");
            return;
          }
        }
        this.setSocket(socket, head, 0);
      });
    }
    function netConnect(options) {
      options.path = options.socketPath || options._socketPath || void 0;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = options.socketPath || options._socketPath || void 0;
      options.servername = options.servername || options.host;
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket.readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._socket.removeListener("data", socketOnData);
      websocket._socket.resume();
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      this[kWebSocket]._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      websocket._socket.removeListener("data", socketOnData);
      websocket.readyState = WebSocket.CLOSING;
      websocket._closeCode = err[constants.kStatusCode];
      websocket.emit("error", err);
      websocket._socket.destroy();
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data) {
      this[kWebSocket].emit("message", data);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, constants.NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("end", socketOnEnd);
      websocket.readyState = WebSocket.CLOSING;
      websocket._socket.read();
      websocket._receiver.end();
      this.removeListener("data", socketOnData);
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket.readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", constants.NOOP);
      if (websocket) {
        websocket.readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var crypto = require("crypto");
    var http = require("http");
    var url = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var extension = require_extension();
    var constants = require_constants();
    var WebSocket = require_websocket();
    var WebSocketServer = class extends EventEmitter {
      constructor(options, callback) {
        super();
        options = Object.assign({
          maxPayload: 100 * 1024 * 1024,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null
        }, options);
        if (options.port == null && !options.server && !options.noServer) {
          throw new TypeError('One of the "port", "server", or "noServer" options must be specified');
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options.port, options.host, options.backlog, callback);
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, (ws) => {
                this.emit("connection", ws, req);
              });
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking)
          this.clients = new Set();
        this.options = options;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (this.clients) {
          for (const client of this.clients)
            client.terminate();
        }
        const server = this._server;
        if (server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
          if (this.options.port != null)
            return server.close(cb);
        }
        if (cb)
          cb();
      }
      shouldHandle(req) {
        if (this.options.path && url.parse(req.url).pathname !== this.options.path) {
          return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const version = +req.headers["sec-websocket-version"];
        const extensions = {};
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !req.headers["sec-websocket-key"] || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        if (this.options.perMessageDeflate) {
          const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            const offers = extension.parse(req.headers["sec-websocket-extensions"]);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.connection.authorized || req.connection.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(extensions, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, req, socket, head, cb);
      }
      completeUpgrade(extensions, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        const key = crypto.createHash("sha1").update(req.headers["sec-websocket-key"] + constants.GUID, "binary").digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${key}`
        ];
        const ws = new WebSocket(null);
        var protocol = req.headers["sec-websocket-protocol"];
        if (protocol) {
          protocol = protocol.split(",").map(trim);
          if (this.options.handleProtocols) {
            protocol = this.options.handleProtocols(protocol, req);
          } else {
            protocol = protocol[0];
          }
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws.protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, this.options.maxPayload);
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => this.clients.delete(ws));
        }
        cb(ws);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http.STATUS_CODES[code];
        headers = Object.assign({
          "Connection": "close",
          "Content-type": "text/html",
          "Content-Length": Buffer.byteLength(message)
        }, headers);
        socket.write(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    function trim(str) {
      return str.trim();
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports2, module2) {
    "use strict";
    var WebSocket = require_websocket();
    WebSocket.Server = require_websocket_server();
    WebSocket.Receiver = require_receiver();
    WebSocket.Sender = require_sender();
    module2.exports = WebSocket;
  }
});

// node_modules/ably/browser/static/ably-node.js
var require_ably_node = __commonJS({
  "node_modules/ably/browser/static/ably-node.js"(exports2, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports2 === "object" && typeof module2 === "object")
        module2.exports = factory(require_source5(), require_ws());
      else if (typeof define === "function" && define.amd)
        define(["got", "ws"], factory);
      else if (typeof exports2 === "object")
        exports2["Ably"] = factory(require_source5(), require_ws());
      else
        root["Ably"] = factory(root["got"], root["ws"]);
    })(global, function(__WEBPACK_EXTERNAL_MODULE__7__, __WEBPACK_EXTERNAL_MODULE__11__) {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module3 = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          module3.l = true;
          return module3.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports3, name, getter) {
          if (!__webpack_require__.o(exports3, name)) {
            Object.defineProperty(exports3, name, { enumerable: true, get: getter });
          }
        };
        __webpack_require__.r = function(exports3) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports3, "__esModule", { value: true });
        };
        __webpack_require__.t = function(value, mode) {
          if (mode & 1)
            value = __webpack_require__(value);
          if (mode & 8)
            return value;
          if (mode & 4 && typeof value === "object" && value && value.__esModule)
            return value;
          var ns = Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, "default", { enumerable: true, value });
          if (mode & 2 && typeof value != "string")
            for (var key in value)
              __webpack_require__.d(ns, key, function(key2) {
                return value[key2];
              }.bind(null, key));
          return ns;
        };
        __webpack_require__.n = function(module3) {
          var getter = module3 && module3.__esModule ? function getDefault() {
            return module3["default"];
          } : function getModuleExports() {
            return module3;
          };
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 26);
      }([
        function(module3, exports3, __webpack_require__) {
          "use strict";
          exports3.__esModule = true;
          var Defaults = {
            internetUpUrl: "https://internet-up.ably-realtime.com/is-the-internet-up.txt",
            defaultTransports: ["web_socket"],
            baseTransportOrder: ["comet", "web_socket"],
            transportPreferenceOrder: ["comet", "web_socket"],
            upgradeTransports: ["web_socket"],
            restAgentOptions: { maxSockets: 40, keepAlive: true },
            agent: "nodejs/" + process.versions.node
          };
          exports3["default"] = Defaults;
        },
        function(module3, exports3) {
          module3.exports = require("buffer");
        },
        function(module3, exports3) {
          module3.exports = require("crypto");
        },
        function(module3, exports3) {
          module3.exports = require("util");
        },
        function(module3, exports3, __webpack_require__) {
          ;
          (function(root, factory) {
            if (true) {
              module3.exports = exports3 = factory();
            } else {
            }
          })(this, function() {
            var CryptoJS = CryptoJS || function(Math2, undefined2) {
              var crypto;
              if (typeof window !== "undefined" && window.crypto) {
                crypto = window.crypto;
              }
              if (!crypto && typeof window !== "undefined" && window.msCrypto) {
                crypto = window.msCrypto;
              }
              if (!crypto && typeof global !== "undefined" && global.crypto) {
                crypto = global.crypto;
              }
              if (!crypto && true) {
                try {
                  crypto = __webpack_require__(2);
                } catch (err) {
                }
              }
              var cryptoSecureRandomInt = function() {
                if (crypto) {
                  if (typeof crypto.getRandomValues === "function") {
                    try {
                      return crypto.getRandomValues(new Uint32Array(1))[0];
                    } catch (err) {
                    }
                  }
                  if (typeof crypto.randomBytes === "function") {
                    try {
                      return crypto.randomBytes(4).readInt32LE();
                    } catch (err) {
                    }
                  }
                }
                throw new Error("Native crypto module could not be used to get secure random number.");
              };
              var create = Object.create || function() {
                function F() {
                }
                return function(obj) {
                  var subtype;
                  F.prototype = obj;
                  subtype = new F();
                  F.prototype = null;
                  return subtype;
                };
              }();
              var C = {};
              var C_lib = C.lib = {};
              var Base = C_lib.Base = function() {
                return {
                  extend: function(overrides) {
                    var subtype = create(this);
                    if (overrides) {
                      subtype.mixIn(overrides);
                    }
                    if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                      subtype.init = function() {
                        subtype.$super.init.apply(this, arguments);
                      };
                    }
                    subtype.init.prototype = subtype;
                    subtype.$super = this;
                    return subtype;
                  },
                  create: function() {
                    var instance = this.extend();
                    instance.init.apply(instance, arguments);
                    return instance;
                  },
                  init: function() {
                  },
                  mixIn: function(properties) {
                    for (var propertyName in properties) {
                      if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                      }
                    }
                    if (properties.hasOwnProperty("toString")) {
                      this.toString = properties.toString;
                    }
                  },
                  clone: function() {
                    return this.init.prototype.extend(this);
                  }
                };
              }();
              var WordArray = C_lib.WordArray = Base.extend({
                init: function(words, sigBytes) {
                  words = this.words = words || [];
                  if (sigBytes != undefined2) {
                    this.sigBytes = sigBytes;
                  } else {
                    this.sigBytes = words.length * 4;
                  }
                },
                toString: function(encoder) {
                  return (encoder || Hex).stringify(this);
                },
                concat: function(wordArray) {
                  var thisWords = this.words;
                  var thatWords = wordArray.words;
                  var thisSigBytes = this.sigBytes;
                  var thatSigBytes = wordArray.sigBytes;
                  this.clamp();
                  if (thisSigBytes % 4) {
                    for (var i = 0; i < thatSigBytes; i++) {
                      var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                      thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
                    }
                  } else {
                    for (var i = 0; i < thatSigBytes; i += 4) {
                      thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
                    }
                  }
                  this.sigBytes += thatSigBytes;
                  return this;
                },
                clamp: function() {
                  var words = this.words;
                  var sigBytes = this.sigBytes;
                  words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
                  words.length = Math2.ceil(sigBytes / 4);
                },
                clone: function() {
                  var clone = Base.clone.call(this);
                  clone.words = this.words.slice(0);
                  return clone;
                },
                random: function(nBytes) {
                  var words = [];
                  for (var i = 0; i < nBytes; i += 4) {
                    words.push(cryptoSecureRandomInt());
                  }
                  return new WordArray.init(words, nBytes);
                }
              });
              var C_enc = C.enc = {};
              var Hex = C_enc.Hex = {
                stringify: function(wordArray) {
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
                  var hexChars = [];
                  for (var i = 0; i < sigBytes; i++) {
                    var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                    hexChars.push((bite >>> 4).toString(16));
                    hexChars.push((bite & 15).toString(16));
                  }
                  return hexChars.join("");
                },
                parse: function(hexStr) {
                  var hexStrLength = hexStr.length;
                  var words = [];
                  for (var i = 0; i < hexStrLength; i += 2) {
                    words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
                  }
                  return new WordArray.init(words, hexStrLength / 2);
                }
              };
              var Latin1 = C_enc.Latin1 = {
                stringify: function(wordArray) {
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
                  var latin1Chars = [];
                  for (var i = 0; i < sigBytes; i++) {
                    var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                    latin1Chars.push(String.fromCharCode(bite));
                  }
                  return latin1Chars.join("");
                },
                parse: function(latin1Str) {
                  var latin1StrLength = latin1Str.length;
                  var words = [];
                  for (var i = 0; i < latin1StrLength; i++) {
                    words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
                  }
                  return new WordArray.init(words, latin1StrLength);
                }
              };
              var Utf8 = C_enc.Utf8 = {
                stringify: function(wordArray) {
                  try {
                    return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                  } catch (e) {
                    throw new Error("Malformed UTF-8 data");
                  }
                },
                parse: function(utf8Str) {
                  return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
                }
              };
              var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
                reset: function() {
                  this._data = new WordArray.init();
                  this._nDataBytes = 0;
                },
                _append: function(data) {
                  if (typeof data == "string") {
                    data = Utf8.parse(data);
                  }
                  this._data.concat(data);
                  this._nDataBytes += data.sigBytes;
                },
                _process: function(doFlush) {
                  var processedWords;
                  var data = this._data;
                  var dataWords = data.words;
                  var dataSigBytes = data.sigBytes;
                  var blockSize = this.blockSize;
                  var blockSizeBytes = blockSize * 4;
                  var nBlocksReady = dataSigBytes / blockSizeBytes;
                  if (doFlush) {
                    nBlocksReady = Math2.ceil(nBlocksReady);
                  } else {
                    nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
                  }
                  var nWordsReady = nBlocksReady * blockSize;
                  var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
                  if (nWordsReady) {
                    for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                      this._doProcessBlock(dataWords, offset);
                    }
                    processedWords = dataWords.splice(0, nWordsReady);
                    data.sigBytes -= nBytesReady;
                  }
                  return new WordArray.init(processedWords, nBytesReady);
                },
                clone: function() {
                  var clone = Base.clone.call(this);
                  clone._data = this._data.clone();
                  return clone;
                },
                _minBufferSize: 0
              });
              var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
                cfg: Base.extend(),
                init: function(cfg) {
                  this.cfg = this.cfg.extend(cfg);
                  this.reset();
                },
                reset: function() {
                  BufferedBlockAlgorithm.reset.call(this);
                  this._doReset();
                },
                update: function(messageUpdate) {
                  this._append(messageUpdate);
                  this._process();
                  return this;
                },
                finalize: function(messageUpdate) {
                  if (messageUpdate) {
                    this._append(messageUpdate);
                  }
                  var hash = this._doFinalize();
                  return hash;
                },
                blockSize: 512 / 32,
                _createHelper: function(hasher) {
                  return function(message, cfg) {
                    return new hasher.init(cfg).finalize(message);
                  };
                },
                _createHmacHelper: function(hasher) {
                  return function(message, key) {
                    return new C_algo.HMAC.init(hasher, key).finalize(message);
                  };
                }
              });
              var C_algo = C.algo = {};
              return C;
            }(Math);
            return CryptoJS;
          });
        },
        function(module3, exports3) {
          module3.exports = require("http");
        },
        function(module3, exports3) {
          module3.exports = require("https");
        },
        function(module3, exports3) {
          module3.exports = __WEBPACK_EXTERNAL_MODULE__7__;
        },
        function(module3) {
          module3.exports = JSON.parse('{"a":"1.2.17"}');
        },
        function(module3, exports3, __webpack_require__) {
          ;
          (function(root, factory) {
            if (true) {
              module3.exports = exports3 = factory(__webpack_require__(4), __webpack_require__(23), __webpack_require__(24));
            } else {
            }
          })(this, function(CryptoJS) {
            return CryptoJS.HmacSHA256;
          });
        },
        function(module3, exports3, __webpack_require__) {
          ;
          (function(root, factory) {
            if (true) {
              module3.exports = exports3 = factory(__webpack_require__(4));
            } else {
            }
          })(this, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var WordArray = C_lib.WordArray;
              var C_enc = C.enc;
              var Base64 = C_enc.Base64 = {
                stringify: function(wordArray) {
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
                  var map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                  wordArray.clamp();
                  var base64Chars = [];
                  for (var i = 0; i < sigBytes; i += 3) {
                    var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                    var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                    var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                    var triplet = byte1 << 16 | byte2 << 8 | byte3;
                    for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                      base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                    }
                  }
                  var paddingChar = map.charAt(64);
                  if (paddingChar) {
                    while (base64Chars.length % 4) {
                      base64Chars.push(paddingChar);
                    }
                  }
                  return base64Chars.join("");
                },
                parse: function(base64Str) {
                  var base64StrLength = base64Str.length;
                  var map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                  var reverseMap = this._reverseMap;
                  if (!reverseMap) {
                    reverseMap = this._reverseMap = [];
                    for (var j = 0; j < map.length; j++) {
                      reverseMap[map.charCodeAt(j)] = j;
                    }
                  }
                  var paddingChar = map.charAt(64);
                  if (paddingChar) {
                    var paddingIndex = base64Str.indexOf(paddingChar);
                    if (paddingIndex !== -1) {
                      base64StrLength = paddingIndex;
                    }
                  }
                  return parseLoop(base64Str, base64StrLength, reverseMap);
                }
              };
              function parseLoop(base64Str, base64StrLength, reverseMap) {
                var words = [];
                var nBytes = 0;
                for (var i = 0; i < base64StrLength; i++) {
                  if (i % 4) {
                    var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
                    var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
                    var bitsCombined = bits1 | bits2;
                    words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                    nBytes++;
                  }
                }
                return WordArray.create(words, nBytes);
              }
            })();
            return CryptoJS.enc.Base64;
          });
        },
        function(module3, exports3) {
          module3.exports = __WEBPACK_EXTERNAL_MODULE__11__;
        },
        function(module3, exports3, __webpack_require__) {
          "use strict";
          var bops = __webpack_require__(13);
          exports3.encode = function(value, sparse) {
            var size = sizeof(value, sparse);
            if (size == 0)
              return void 0;
            var buffer = bops.create(size);
            encode(value, buffer, 0, sparse);
            return buffer;
          };
          exports3.decode = decode;
          var SH_L_32 = (1 << 16) * (1 << 16), SH_R_32 = 1 / SH_L_32;
          function readInt64BE(buf, offset) {
            offset = offset || 0;
            return buf.readInt32BE(offset + 0) * SH_L_32 + buf.readUInt32BE(offset + 4);
          }
          function readUInt64BE(buf, offset) {
            offset = offset || 0;
            return buf.readUInt32BE(offset + 0) * SH_L_32 + buf.readUInt32BE(offset + 4);
          }
          function writeInt64BE(buf, val, offset) {
            if (val < 9223372036854776e3) {
              buf.writeInt32BE(Math.floor(val * SH_R_32), offset);
              buf.writeInt32BE(val & -1, offset + 4);
            } else {
              buf.writeUInt32BE(2147483647, offset);
              buf.writeUInt32BE(4294967295, offset + 4);
            }
          }
          function writeUInt64BE(buf, val, offset) {
            if (val < 18446744073709552e3) {
              buf.writeUInt32BE(Math.floor(val * SH_R_32), offset);
              buf.writeInt32BE(val & -1, offset + 4);
            } else {
              buf.writeUInt32BE(4294967295, offset);
              buf.writeUInt32BE(4294967295, offset + 4);
            }
          }
          function Decoder(buffer, offset) {
            this.offset = offset || 0;
            this.buffer = buffer;
            this.bufferLength = buffer.length;
          }
          Decoder.prototype.map = function(length) {
            if (length * 2 > this.bufferLength) {
              throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a map of length ${length})`);
            }
            var value = {};
            for (var i = 0; i < length; i++) {
              var key = this.parse();
              value[key] = this.parse();
            }
            return value;
          };
          Decoder.prototype.bin = Decoder.prototype.buf = function(length) {
            if (length > this.bufferLength) {
              throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a binary of length ${length})`);
            }
            var value = bops.subarray(this.buffer, this.offset, this.offset + length);
            this.offset += length;
            return value;
          };
          Decoder.prototype.str = function(length) {
            if (length > this.bufferLength) {
              throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced a string of length ${length})`);
            }
            var value = bops.to(bops.subarray(this.buffer, this.offset, this.offset + length));
            this.offset += length;
            return value;
          };
          Decoder.prototype.array = function(length) {
            if (length > this.bufferLength) {
              throw new Error(`malformed messagepack detected: buffer size was ${this.bufferLength}, but referenced an array of length ${length})`);
            }
            var value = new Array(length);
            for (var i = 0; i < length; i++) {
              value[i] = this.parse();
            }
            return value;
          };
          Decoder.prototype.parse = function() {
            var type = this.buffer[this.offset];
            var value, length, extType;
            if (type === void 0) {
              throw new Error("malformed messagepack (referenced offset is outside buffer)");
            }
            if ((type & 128) === 0) {
              this.offset++;
              return type;
            }
            if ((type & 240) === 128) {
              length = type & 15;
              this.offset++;
              return this.map(length);
            }
            if ((type & 240) === 144) {
              length = type & 15;
              this.offset++;
              return this.array(length);
            }
            if ((type & 224) === 160) {
              length = type & 31;
              this.offset++;
              return this.str(length);
            }
            if ((type & 224) === 224) {
              value = bops.readInt8(this.buffer, this.offset);
              this.offset++;
              return value;
            }
            switch (type) {
              case 192:
                this.offset++;
                return null;
              case 194:
                this.offset++;
                return false;
              case 195:
                this.offset++;
                return true;
              case 196:
                length = bops.readUInt8(this.buffer, this.offset + 1);
                this.offset += 2;
                return this.bin(length);
              case 197:
                length = bops.readUInt16BE(this.buffer, this.offset + 1);
                this.offset += 3;
                return this.bin(length);
              case 198:
                length = bops.readUInt32BE(this.buffer, this.offset + 1);
                this.offset += 5;
                return this.bin(length);
              case 199:
                length = bops.readUInt8(this.buffer, this.offset + 1);
                extType = bops.readUInt8(this.buffer, this.offset + 2);
                this.offset += 3;
                return [extType, this.bin(length)];
              case 200:
                length = bops.readUInt16BE(this.buffer, this.offset + 1);
                extType = bops.readUInt8(this.buffer, this.offset + 3);
                this.offset += 4;
                return [extType, this.bin(length)];
              case 201:
                length = bops.readUInt32BE(this.buffer, this.offset + 1);
                extType = bops.readUInt8(this.buffer, this.offset + 5);
                this.offset += 6;
                return [extType, this.bin(length)];
              case 202:
                value = bops.readFloatBE(this.buffer, this.offset + 1);
                this.offset += 5;
                return value;
              case 203:
                value = bops.readDoubleBE(this.buffer, this.offset + 1);
                this.offset += 9;
                return value;
              case 204:
                value = this.buffer[this.offset + 1];
                this.offset += 2;
                return value;
              case 205:
                value = bops.readUInt16BE(this.buffer, this.offset + 1);
                this.offset += 3;
                return value;
              case 206:
                value = bops.readUInt32BE(this.buffer, this.offset + 1);
                this.offset += 5;
                return value;
              case 207:
                value = readUInt64BE(this.buffer, this.offset + 1);
                this.offset += 9;
                return value;
              case 208:
                value = bops.readInt8(this.buffer, this.offset + 1);
                this.offset += 2;
                return value;
              case 209:
                value = bops.readInt16BE(this.buffer, this.offset + 1);
                this.offset += 3;
                return value;
              case 210:
                value = bops.readInt32BE(this.buffer, this.offset + 1);
                this.offset += 5;
                return value;
              case 211:
                value = readInt64BE(this.buffer, this.offset + 1);
                this.offset += 9;
                return value;
              case 212:
                extType = bops.readUInt8(this.buffer, this.offset + 1);
                value = bops.readUInt8(this.buffer, this.offset + 2);
                this.offset += 3;
                return extType === 0 && value === 0 ? void 0 : [extType, value];
              case 213:
                extType = bops.readUInt8(this.buffer, this.offset + 1);
                this.offset += 2;
                return [extType, this.bin(2)];
              case 214:
                extType = bops.readUInt8(this.buffer, this.offset + 1);
                this.offset += 2;
                return [extType, this.bin(4)];
              case 215:
                extType = bops.readUInt8(this.buffer, this.offset + 1);
                this.offset += 2;
                return [extType, this.bin(8)];
              case 216:
                extType = bops.readUInt8(this.buffer, this.offset + 1);
                this.offset += 2;
                return [extType, this.bin(16)];
              case 217:
                length = bops.readUInt8(this.buffer, this.offset + 1);
                this.offset += 2;
                return this.str(length);
              case 218:
                length = bops.readUInt16BE(this.buffer, this.offset + 1);
                this.offset += 3;
                return this.str(length);
              case 219:
                length = bops.readUInt32BE(this.buffer, this.offset + 1);
                this.offset += 5;
                return this.str(length);
              case 220:
                length = bops.readUInt16BE(this.buffer, this.offset + 1);
                this.offset += 3;
                return this.array(length);
              case 221:
                length = bops.readUInt32BE(this.buffer, this.offset + 1);
                this.offset += 5;
                return this.array(length);
              case 222:
                length = bops.readUInt16BE(this.buffer, this.offset + 1);
                this.offset += 3;
                return this.map(length);
              case 223:
                length = bops.readUInt32BE(this.buffer, this.offset + 1);
                this.offset += 5;
                return this.map(length);
            }
            throw new Error("Unknown type 0x" + type.toString(16));
          };
          function decode(buffer) {
            var decoder = new Decoder(buffer);
            var value = decoder.parse();
            if (decoder.offset !== buffer.length)
              throw new Error(buffer.length - decoder.offset + " trailing bytes");
            return value;
          }
          function encodeableKeys(value, sparse) {
            return Object.keys(value).filter(function(e) {
              var val = value[e], type = typeof val;
              return (!sparse || val !== void 0 && val !== null) && (type !== "function" || !!val.toJSON);
            });
          }
          function encode(value, buffer, offset, sparse, isMapElement) {
            var type = typeof value;
            var length, size;
            if (type === "string") {
              value = bops.from(value);
              length = value.length;
              if (length < 32) {
                buffer[offset] = length | 160;
                bops.copy(value, buffer, offset + 1);
                return 1 + length;
              }
              if (length < 256) {
                buffer[offset] = 217;
                bops.writeUInt8(buffer, length, offset + 1);
                bops.copy(value, buffer, offset + 2);
                return 2 + length;
              }
              if (length < 65536) {
                buffer[offset] = 218;
                bops.writeUInt16BE(buffer, length, offset + 1);
                bops.copy(value, buffer, offset + 3);
                return 3 + length;
              }
              if (length < 4294967296) {
                buffer[offset] = 219;
                bops.writeUInt32BE(buffer, length, offset + 1);
                bops.copy(value, buffer, offset + 5);
                return 5 + length;
              }
            }
            if (bops.is(value)) {
              length = value.length;
              if (length < 256) {
                buffer[offset] = 196;
                bops.writeUInt8(buffer, length, offset + 1);
                bops.copy(value, buffer, offset + 2);
                return 2 + length;
              }
              if (length < 65536) {
                buffer[offset] = 197;
                bops.writeUInt16BE(buffer, length, offset + 1);
                bops.copy(value, buffer, offset + 3);
                return 3 + length;
              }
              if (length < 4294967296) {
                buffer[offset] = 198;
                bops.writeUInt32BE(buffer, length, offset + 1);
                bops.copy(value, buffer, offset + 5);
                return 5 + length;
              }
            }
            if (type === "number") {
              if (Math.floor(value) !== value) {
                buffer[offset] = 203;
                bops.writeDoubleBE(buffer, value, offset + 1);
                return 9;
              }
              if (value >= 0) {
                if (value < 128) {
                  buffer[offset] = value;
                  return 1;
                }
                if (value < 256) {
                  buffer[offset] = 204;
                  buffer[offset + 1] = value;
                  return 2;
                }
                if (value < 65536) {
                  buffer[offset] = 205;
                  bops.writeUInt16BE(buffer, value, offset + 1);
                  return 3;
                }
                if (value < 4294967296) {
                  buffer[offset] = 206;
                  bops.writeUInt32BE(buffer, value, offset + 1);
                  return 5;
                }
                if (value < 18446744073709552e3) {
                  buffer[offset] = 207;
                  writeUInt64BE(buffer, value, offset + 1);
                  return 9;
                }
                throw new Error("Number too big 0x" + value.toString(16));
              }
              if (value >= -32) {
                bops.writeInt8(buffer, value, offset);
                return 1;
              }
              if (value >= -128) {
                buffer[offset] = 208;
                bops.writeInt8(buffer, value, offset + 1);
                return 2;
              }
              if (value >= -32768) {
                buffer[offset] = 209;
                bops.writeInt16BE(buffer, value, offset + 1);
                return 3;
              }
              if (value >= -2147483648) {
                buffer[offset] = 210;
                bops.writeInt32BE(buffer, value, offset + 1);
                return 5;
              }
              if (value >= -9223372036854776e3) {
                buffer[offset] = 211;
                writeInt64BE(buffer, value, offset + 1);
                return 9;
              }
              throw new Error("Number too small -0x" + value.toString(16).substr(1));
            }
            if (type === "undefined") {
              if (sparse && isMapElement)
                return 0;
              buffer[offset] = 212;
              buffer[offset + 1] = 0;
              buffer[offset + 2] = 0;
              return 3;
            }
            if (value === null) {
              if (sparse && isMapElement)
                return 0;
              buffer[offset] = 192;
              return 1;
            }
            if (type === "boolean") {
              buffer[offset] = value ? 195 : 194;
              return 1;
            }
            if (typeof value.toJSON === "function")
              return encode(value.toJSON(), buffer, offset, sparse);
            if (type === "object") {
              size = 0;
              var isArray = Array.isArray(value);
              if (isArray) {
                length = value.length;
              } else {
                var keys = encodeableKeys(value, sparse);
                length = keys.length;
              }
              if (length < 16) {
                buffer[offset] = length | (isArray ? 144 : 128);
                size = 1;
              } else if (length < 65536) {
                buffer[offset] = isArray ? 220 : 222;
                bops.writeUInt16BE(buffer, length, offset + 1);
                size = 3;
              } else if (length < 4294967296) {
                buffer[offset] = isArray ? 221 : 223;
                bops.writeUInt32BE(buffer, length, offset + 1);
                size = 5;
              }
              if (isArray) {
                for (var i = 0; i < length; i++) {
                  size += encode(value[i], buffer, offset + size, sparse);
                }
              } else {
                for (var i = 0; i < length; i++) {
                  var key = keys[i];
                  size += encode(key, buffer, offset + size);
                  size += encode(value[key], buffer, offset + size, sparse, true);
                }
              }
              return size;
            }
            if (type === "function")
              return void 0;
            throw new Error("Unknown type " + type);
          }
          function sizeof(value, sparse, isMapElement) {
            var type = typeof value;
            var length, size;
            if (type === "string") {
              length = bops.from(value).length;
              if (length < 32) {
                return 1 + length;
              }
              if (length < 256) {
                return 2 + length;
              }
              if (length < 65536) {
                return 3 + length;
              }
              if (length < 4294967296) {
                return 5 + length;
              }
            }
            if (bops.is(value)) {
              length = value.length;
              if (length < 256) {
                return 2 + length;
              }
              if (length < 65536) {
                return 3 + length;
              }
              if (length < 4294967296) {
                return 5 + length;
              }
            }
            if (type === "number") {
              if (Math.floor(value) !== value)
                return 9;
              if (value >= 0) {
                if (value < 128)
                  return 1;
                if (value < 256)
                  return 2;
                if (value < 65536)
                  return 3;
                if (value < 4294967296)
                  return 5;
                if (value < 18446744073709552e3)
                  return 9;
                throw new Error("Number too big 0x" + value.toString(16));
              }
              if (value >= -32)
                return 1;
              if (value >= -128)
                return 2;
              if (value >= -32768)
                return 3;
              if (value >= -2147483648)
                return 5;
              if (value >= -9223372036854776e3)
                return 9;
              throw new Error("Number too small -0x" + value.toString(16).substr(1));
            }
            if (type === "boolean")
              return 1;
            if (value === null)
              return sparse && isMapElement ? 0 : 1;
            if (value === void 0)
              return sparse && isMapElement ? 0 : 3;
            if (typeof value.toJSON === "function")
              return sizeof(value.toJSON(), sparse);
            if (type === "object") {
              size = 0;
              if (Array.isArray(value)) {
                length = value.length;
                for (var i = 0; i < length; i++) {
                  size += sizeof(value[i], sparse);
                }
              } else {
                var keys = encodeableKeys(value, sparse);
                length = keys.length;
                for (var i = 0; i < length; i++) {
                  var key = keys[i];
                  size += sizeof(key) + sizeof(value[key], sparse, true);
                }
              }
              if (length < 16) {
                return 1 + size;
              }
              if (length < 65536) {
                return 3 + size;
              }
              if (length < 4294967296) {
                return 5 + size;
              }
              throw new Error("Array or object too long 0x" + length.toString(16));
            }
            if (type === "function")
              return 0;
            throw new Error("Unknown type " + type);
          }
        },
        function(module3, exports3, __webpack_require__) {
          var proto = {};
          module3.exports = proto;
          proto.from = __webpack_require__(14);
          proto.to = __webpack_require__(15);
          proto.is = __webpack_require__(16);
          proto.subarray = __webpack_require__(17);
          proto.join = __webpack_require__(18);
          proto.copy = __webpack_require__(19);
          proto.create = __webpack_require__(20);
          mix(__webpack_require__(21), proto);
          mix(__webpack_require__(22), proto);
          function mix(from, into) {
            for (var key in from) {
              into[key] = from[key];
            }
          }
        },
        function(module3, exports3, __webpack_require__) {
          var Buffer2 = __webpack_require__(1).Buffer;
          module3.exports = function(source, encoding) {
            return new Buffer2(source, encoding);
          };
        },
        function(module3, exports3) {
          module3.exports = function(source, encoding) {
            return source.toString(encoding);
          };
        },
        function(module3, exports3, __webpack_require__) {
          var Buffer2 = __webpack_require__(1).Buffer;
          module3.exports = function(buffer) {
            return Buffer2.isBuffer(buffer);
          };
        },
        function(module3, exports3) {
          module3.exports = function(source, from, to) {
            return arguments.length === 2 ? source.slice(from) : source.slice(from, to);
          };
        },
        function(module3, exports3, __webpack_require__) {
          var Buffer2 = __webpack_require__(1).Buffer;
          module3.exports = function(targets, hint) {
            return hint !== void 0 ? Buffer2.concat(targets, hint) : Buffer2.concat(targets);
          };
        },
        function(module3, exports3) {
          module3.exports = copy;
          function copy(source, target, target_start, source_start, source_end) {
            return source.copy(target, target_start, source_start, source_end);
          }
        },
        function(module3, exports3, __webpack_require__) {
          module3.exports = create;
          var Buffer2 = __webpack_require__(1).Buffer;
          function create(size) {
            return new Buffer2(size);
          }
        },
        function(module3, exports3) {
          var proto = {}, rex = /read.+/, buildFn;
          buildFn = function(key2) {
            var code = "return buf." + key2 + "(" + ["a", "b", "c"].join(",") + ")";
            return new Function(["buf", "a", "b", "c"], code);
          };
          module3.exports = proto;
          for (var key in Buffer.prototype) {
            if (rex.test(key)) {
              proto[key] = buildFn(key);
            }
          }
        },
        function(module3, exports3, __webpack_require__) {
          var Buffer2 = __webpack_require__(1).Buffer;
          var proto = {}, rex = /write.+/, buildFn;
          buildFn = function(key2) {
            var code = "return buf." + key2 + "(" + ["a", "b", "c"].join(",") + ")";
            return new Function(["buf", "a", "b", "c"], code);
          };
          module3.exports = proto;
          for (var key in Buffer2.prototype) {
            if (rex.test(key)) {
              proto[key] = buildFn(key);
            }
          }
        },
        function(module3, exports3, __webpack_require__) {
          ;
          (function(root, factory) {
            if (true) {
              module3.exports = exports3 = factory(__webpack_require__(4));
            } else {
            }
          })(this, function(CryptoJS) {
            (function(Math2) {
              var C = CryptoJS;
              var C_lib = C.lib;
              var WordArray = C_lib.WordArray;
              var Hasher = C_lib.Hasher;
              var C_algo = C.algo;
              var H = [];
              var K = [];
              (function() {
                function isPrime(n2) {
                  var sqrtN = Math2.sqrt(n2);
                  for (var factor = 2; factor <= sqrtN; factor++) {
                    if (!(n2 % factor)) {
                      return false;
                    }
                  }
                  return true;
                }
                function getFractionalBits(n2) {
                  return (n2 - (n2 | 0)) * 4294967296 | 0;
                }
                var n = 2;
                var nPrime = 0;
                while (nPrime < 64) {
                  if (isPrime(n)) {
                    if (nPrime < 8) {
                      H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
                    }
                    K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
                    nPrime++;
                  }
                  n++;
                }
              })();
              var W = [];
              var SHA256 = C_algo.SHA256 = Hasher.extend({
                _doReset: function() {
                  this._hash = new WordArray.init(H.slice(0));
                },
                _doProcessBlock: function(M, offset) {
                  var H2 = this._hash.words;
                  var a = H2[0];
                  var b = H2[1];
                  var c = H2[2];
                  var d = H2[3];
                  var e = H2[4];
                  var f = H2[5];
                  var g = H2[6];
                  var h = H2[7];
                  for (var i = 0; i < 64; i++) {
                    if (i < 16) {
                      W[i] = M[offset + i] | 0;
                    } else {
                      var gamma0x = W[i - 15];
                      var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                      var gamma1x = W[i - 2];
                      var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                      W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                    }
                    var ch = e & f ^ ~e & g;
                    var maj = a & b ^ a & c ^ b & c;
                    var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
                    var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
                    var t1 = h + sigma1 + ch + K[i] + W[i];
                    var t2 = sigma0 + maj;
                    h = g;
                    g = f;
                    f = e;
                    e = d + t1 | 0;
                    d = c;
                    c = b;
                    b = a;
                    a = t1 + t2 | 0;
                  }
                  H2[0] = H2[0] + a | 0;
                  H2[1] = H2[1] + b | 0;
                  H2[2] = H2[2] + c | 0;
                  H2[3] = H2[3] + d | 0;
                  H2[4] = H2[4] + e | 0;
                  H2[5] = H2[5] + f | 0;
                  H2[6] = H2[6] + g | 0;
                  H2[7] = H2[7] + h | 0;
                },
                _doFinalize: function() {
                  var data = this._data;
                  var dataWords = data.words;
                  var nBitsTotal = this._nDataBytes * 8;
                  var nBitsLeft = data.sigBytes * 8;
                  dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                  dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
                  dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                  data.sigBytes = dataWords.length * 4;
                  this._process();
                  return this._hash;
                },
                clone: function() {
                  var clone = Hasher.clone.call(this);
                  clone._hash = this._hash.clone();
                  return clone;
                }
              });
              C.SHA256 = Hasher._createHelper(SHA256);
              C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
            })(Math);
            return CryptoJS.SHA256;
          });
        },
        function(module3, exports3, __webpack_require__) {
          ;
          (function(root, factory) {
            if (true) {
              module3.exports = exports3 = factory(__webpack_require__(4));
            } else {
            }
          })(this, function(CryptoJS) {
            (function() {
              var C = CryptoJS;
              var C_lib = C.lib;
              var Base = C_lib.Base;
              var C_enc = C.enc;
              var Utf8 = C_enc.Utf8;
              var C_algo = C.algo;
              var HMAC = C_algo.HMAC = Base.extend({
                init: function(hasher, key) {
                  hasher = this._hasher = new hasher.init();
                  if (typeof key == "string") {
                    key = Utf8.parse(key);
                  }
                  var hasherBlockSize = hasher.blockSize;
                  var hasherBlockSizeBytes = hasherBlockSize * 4;
                  if (key.sigBytes > hasherBlockSizeBytes) {
                    key = hasher.finalize(key);
                  }
                  key.clamp();
                  var oKey = this._oKey = key.clone();
                  var iKey = this._iKey = key.clone();
                  var oKeyWords = oKey.words;
                  var iKeyWords = iKey.words;
                  for (var i = 0; i < hasherBlockSize; i++) {
                    oKeyWords[i] ^= 1549556828;
                    iKeyWords[i] ^= 909522486;
                  }
                  oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
                  this.reset();
                },
                reset: function() {
                  var hasher = this._hasher;
                  hasher.reset();
                  hasher.update(this._iKey);
                },
                update: function(messageUpdate) {
                  this._hasher.update(messageUpdate);
                  return this;
                },
                finalize: function(messageUpdate) {
                  var hasher = this._hasher;
                  var innerHash = hasher.finalize(messageUpdate);
                  hasher.reset();
                  var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
                  return hmac;
                }
              });
            })();
          });
        },
        function(module3, exports3) {
          module3.exports = require("url");
        },
        function(module3, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          var Platform = {
            agent: "nodejs/" + process.versions.node,
            logTimestamps: true,
            userAgent: null,
            binaryType: "nodebuffer",
            WebSocket: __webpack_require__(11),
            useProtocolHeartbeats: false,
            createHmac: __webpack_require__(2).createHmac,
            msgpack: __webpack_require__(12),
            supportsBinary: true,
            preferBinary: true,
            nextTick: process.nextTick,
            inspect: __webpack_require__(3).inspect,
            stringByteSize: Buffer.byteLength,
            inherits: __webpack_require__(3).inherits,
            addEventListener: null,
            getRandomValues: function(arr, callback) {
              var bytes = __webpack_require__(2).randomBytes(arr.length);
              arr.set(bytes);
              if (callback) {
                callback(null);
              }
            },
            Promise: global && global.Promise
          };
          var platform = Platform;
          var defaults = __webpack_require__(0);
          var defaults_default = /* @__PURE__ */ __webpack_require__.n(defaults);
          var BufferUtils = function() {
            function BufferUtils2() {
            }
            function isArrayBuffer(ob) {
              return ob !== null && ob !== void 0 && ob.constructor === ArrayBuffer;
            }
            var isBuffer = BufferUtils2.isBuffer = function(buf) {
              return Buffer.isBuffer(buf) || isArrayBuffer(buf) || ArrayBuffer.isView(buf);
            };
            var toBuffer = BufferUtils2.toBuffer = function(buf) {
              if (Buffer.isBuffer(buf)) {
                return buf;
              }
              return Buffer.from(buf);
            };
            BufferUtils2.toArrayBuffer = function(buf) {
              return toBuffer(buf).buffer;
            };
            BufferUtils2.base64Encode = function(buf) {
              return toBuffer(buf).toString("base64");
            };
            BufferUtils2.base64Decode = function(string) {
              return Buffer.from(string, "base64");
            };
            BufferUtils2.hexEncode = function(buf) {
              return toBuffer(buf).toString("hex");
            };
            BufferUtils2.hexDecode = function(string) {
              return Buffer.from(string, "hex");
            };
            BufferUtils2.utf8Encode = function(string) {
              return Buffer.from(string, "utf8");
            };
            BufferUtils2.utf8Decode = function(buf) {
              if (!isBuffer(buf)) {
                throw new Error("Expected input of utf8Decode to be a buffer, arraybuffer, or view");
              }
              return toBuffer(buf).toString("utf8");
            };
            BufferUtils2.bufferCompare = function(buf1, buf2) {
              if (!buf1)
                return -1;
              if (!buf2)
                return 1;
              return buf1.compare(buf2);
            };
            BufferUtils2.byteLength = function(buffer) {
              return buffer.byteLength;
            };
            BufferUtils2.typedArrayToBuffer = function(typedArray) {
              return toBuffer(typedArray.buffer);
            };
            return BufferUtils2;
          }();
          var bufferutils = BufferUtils;
          var logger_Logger = function() {
            var consoleLogger, errorLogger;
            if (typeof Window === "undefined" && typeof WorkerGlobalScope === "undefined" || global.console && global.console.log && typeof global.console.log.apply === "function") {
              consoleLogger = function() {
                console.log.apply(console, arguments);
              };
              errorLogger = console.warn ? function() {
                console.warn.apply(console, arguments);
              } : consoleLogger;
            } else if (global.console && global.console.log) {
              consoleLogger = errorLogger = function() {
                Function.prototype.apply.call(console.log, console, arguments);
              };
            } else {
              consoleLogger = errorLogger = function() {
              };
            }
            function pad(str, three) {
              return ("000" + str).slice(-2 - (three || 0));
            }
            var LOG_NONE = 0, LOG_ERROR = 1, LOG_MAJOR = 2, LOG_MINOR = 3, LOG_MICRO = 4;
            var LOG_DEFAULT = LOG_ERROR, LOG_DEBUG = LOG_MICRO;
            var logLevel = LOG_DEFAULT;
            function getHandler(logger) {
              return platform.logTimestamps ? function(msg) {
                var time = new Date();
                logger(pad(time.getHours()) + ":" + pad(time.getMinutes()) + ":" + pad(time.getSeconds()) + "." + pad(time.getMilliseconds(), true) + " " + msg);
              } : logger;
            }
            var logHandler = getHandler(consoleLogger), logErrorHandler = getHandler(errorLogger);
            function Logger(args) {
            }
            Logger.LOG_NONE = LOG_NONE, Logger.LOG_ERROR = LOG_ERROR, Logger.LOG_MAJOR = LOG_MAJOR, Logger.LOG_MINOR = LOG_MINOR, Logger.LOG_MICRO = LOG_MICRO;
            Logger.LOG_DEFAULT = LOG_DEFAULT, Logger.LOG_DEBUG = LOG_DEBUG;
            Logger.logAction = function(level, action, message) {
              if (Logger.shouldLog(level)) {
                (level === LOG_ERROR ? logErrorHandler : logHandler)("Ably: " + action + ": " + message);
              }
            };
            Logger.deprecated = function(original, replacement) {
              Logger.deprecatedWithMsg(original, "Please use '" + replacement + "' instead.");
            };
            Logger.deprecatedWithMsg = function(funcName, msg) {
              if (Logger.shouldLog(LOG_ERROR)) {
                logErrorHandler("Ably: Deprecation warning - '" + funcName + "' is deprecated and will be removed from a future version. " + msg);
              }
            };
            Logger.shouldLog = function(level) {
              return level <= logLevel;
            };
            Logger.setLog = function(level, handler) {
              if (level !== void 0)
                logLevel = level;
              if (handler !== void 0)
                logHandler = logErrorHandler = handler;
            };
            return Logger;
          }();
          var util_logger = logger_Logger;
          var errorinfo_ErrorInfo = function() {
            function ErrorInfo2(message, code, statusCode, cause) {
              this.message = message;
              this.code = code;
              this.statusCode = statusCode;
              this.cause = cause;
              this.href = void 0;
            }
            ErrorInfo2.prototype.toString = function() {
              var result = "[" + this.constructor.name;
              if (this.message)
                result += ": " + this.message;
              if (this.statusCode)
                result += "; statusCode=" + this.statusCode;
              if (this.code)
                result += "; code=" + this.code;
              if (this.cause)
                result += "; cause=" + utils.inspectError(this.cause);
              if (this.href && !(this.message && this.message.indexOf("help.ably.io") > -1))
                result += "; see " + this.href + " ";
              result += "]";
              return result;
            };
            ErrorInfo2.fromValues = function(values) {
              var result = utils.mixin(new ErrorInfo2(), values);
              if (values instanceof Error) {
                result.message = values.message;
              }
              if (result.code && !result.href) {
                result.href = "https://help.ably.io/error/" + result.code;
              }
              return result;
            };
            return ErrorInfo2;
          }();
          var errorinfo = errorinfo_ErrorInfo;
          var package_0 = __webpack_require__(8);
          defaults_default.a.ENVIRONMENT = "";
          defaults_default.a.REST_HOST = "rest.ably.io";
          defaults_default.a.REALTIME_HOST = "realtime.ably.io";
          defaults_default.a.FALLBACK_HOSTS = ["A.ably-realtime.com", "B.ably-realtime.com", "C.ably-realtime.com", "D.ably-realtime.com", "E.ably-realtime.com"];
          defaults_default.a.PORT = 80;
          defaults_default.a.TLS_PORT = 443;
          defaults_default.a.TIMEOUTS = {
            disconnectedRetryTimeout: 15e3,
            suspendedRetryTimeout: 3e4,
            httpRequestTimeout: 15e3,
            channelRetryTimeout: 15e3,
            fallbackRetryTimeout: 6e5,
            connectionStateTtl: 12e4,
            realtimeRequestTimeout: 1e4,
            recvTimeout: 9e4,
            preferenceConnectTimeout: 6e3,
            parallelUpgradeDelay: 6e3
          };
          defaults_default.a.httpMaxRetryCount = 3;
          defaults_default.a.maxMessageSize = 65536;
          defaults_default.a.errorReportingUrl = "https://errors.ably.io/api/15/store/";
          defaults_default.a.errorReportingHeaders = {
            "X-Sentry-Auth": "Sentry sentry_version=7, sentry_key=a04e33c8674c451f8a310fbec029acf5, sentry_client=ably-js/0.1",
            "Content-Type": "application/json"
          };
          defaults_default.a.version = package_0["a"];
          defaults_default.a.apiVersion = "1.2";
          var agent = "ably-js/" + defaults_default.a.version;
          if (platform.agent) {
            agent += " " + platform.agent;
          }
          defaults_default.a.agent = agent;
          defaults_default.a.getHost = function(options, host, ws) {
            if (ws)
              host = host == options.restHost && options.realtimeHost || host || options.realtimeHost;
            else
              host = host || options.restHost;
            return host;
          };
          defaults_default.a.getPort = function(options, tls) {
            return tls || options.tls ? options.tlsPort : options.port;
          };
          defaults_default.a.getHttpScheme = function(options) {
            return options.tls ? "https://" : "http://";
          };
          defaults_default.a.environmentFallbackHosts = function(environment) {
            return [
              environment + "-a-fallback.ably-realtime.com",
              environment + "-b-fallback.ably-realtime.com",
              environment + "-c-fallback.ably-realtime.com",
              environment + "-d-fallback.ably-realtime.com",
              environment + "-e-fallback.ably-realtime.com"
            ];
          };
          defaults_default.a.getFallbackHosts = function(options) {
            var fallbackHosts = options.fallbackHosts, httpMaxRetryCount = typeof options.httpMaxRetryCount !== "undefined" ? options.httpMaxRetryCount : defaults_default.a.httpMaxRetryCount;
            return fallbackHosts ? utils.arrChooseN(fallbackHosts, httpMaxRetryCount) : [];
          };
          defaults_default.a.getHosts = function(options) {
            return [options.restHost].concat(defaults_default.a.getFallbackHosts(options));
          };
          function checkHost(host) {
            if (typeof host !== "string") {
              throw new errorinfo("host must be a string; was a " + typeof host, 4e4, 400);
            }
            ;
            if (!host.length) {
              throw new errorinfo("host must not be zero-length", 4e4, 400);
            }
            ;
          }
          defaults_default.a.objectifyOptions = function(options) {
            if (typeof options == "string") {
              return options.indexOf(":") == -1 ? { token: options } : { key: options };
            }
            return options;
          };
          defaults_default.a.normaliseOptions = function(options) {
            if (options.host) {
              util_logger.deprecated("host", "restHost");
              options.restHost = options.host;
            }
            if (options.wsHost) {
              util_logger.deprecated("wsHost", "realtimeHost");
              options.realtimeHost = options.wsHost;
            }
            if (options.queueEvents) {
              util_logger.deprecated("queueEvents", "queueMessages");
              options.queueMessages = options.queueEvents;
            }
            if (options.fallbackHostsUseDefault) {
              if (options.fallbackHosts) {
                var msg = "fallbackHosts and fallbackHostsUseDefault cannot both be set";
                util_logger.logAction(util_logger.LOG_ERROR, "Defaults.normaliseOptions", msg);
                throw new errorinfo(msg, 4e4, 400);
              }
              if (options.port || options.tlsPort) {
                var msg = "fallbackHostsUseDefault cannot be set when port or tlsPort are set";
                util_logger.logAction(util_logger.LOG_ERROR, "Defaults.normaliseOptions", msg);
                throw new errorinfo(msg, 4e4, 400);
              }
              if (options.environment) {
                util_logger.deprecatedWithMsg("fallbackHostsUseDefault", "There is no longer a need to set this when the environment option is also set since the library will now generate the correct fallback hosts using the environment option.");
              } else {
                util_logger.deprecated("fallbackHostsUseDefault", "fallbackHosts: Ably.Defaults.FALLBACK_HOSTS");
              }
              options.fallbackHosts = defaults_default.a.FALLBACK_HOSTS;
            }
            if (options.recover === true) {
              util_logger.deprecated("{recover: true}", "{recover: function(lastConnectionDetails, cb) { cb(true); }}");
              options.recover = function(lastConnectionDetails, cb) {
                cb(true);
              };
            }
            if (typeof options.recover === "function" && options.closeOnUnload === true) {
              util_logger.logAction(util_logger.LOG_ERROR, "Defaults.normaliseOptions", "closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter");
              options.recover = null;
            }
            if (!("closeOnUnload" in options)) {
              options.closeOnUnload = !options.recover;
            }
            if (options.transports && utils.arrIn(options.transports, "xhr")) {
              util_logger.deprecated('transports: ["xhr"]', 'transports: ["xhr_streaming"]');
              utils.arrDeleteValue(options.transports, "xhr");
              options.transports.push("xhr_streaming");
            }
            if (!("queueMessages" in options))
              options.queueMessages = true;
            var environment = options.environment && String(options.environment).toLowerCase() || defaults_default.a.ENVIRONMENT;
            var production = !environment || environment === "production";
            if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {
              options.fallbackHosts = production ? defaults_default.a.FALLBACK_HOSTS : defaults_default.a.environmentFallbackHosts(environment);
            }
            if (!options.realtimeHost) {
              if (options.restHost) {
                util_logger.logAction(util_logger.LOG_WARN, "Defaults.normaliseOptions", 'restHost is set to "' + options.restHost + '" but realtimeHost is not set, so setting realtimeHost to "' + options.restHost + '" too. If this is not what you want, please set realtimeHost explicitly.');
                options.realtimeHost = options.restHost;
              } else {
                options.realtimeHost = production ? defaults_default.a.REALTIME_HOST : environment + "-" + defaults_default.a.REALTIME_HOST;
              }
            }
            if (!options.restHost) {
              options.restHost = production ? defaults_default.a.REST_HOST : environment + "-" + defaults_default.a.REST_HOST;
            }
            utils.arrForEach((options.fallbackHosts || []).concat(options.restHost, options.realtimeHost), checkHost);
            options.port = options.port || defaults_default.a.PORT;
            options.tlsPort = options.tlsPort || defaults_default.a.TLS_PORT;
            options.maxMessageSize = options.maxMessageSize || defaults_default.a.maxMessageSize;
            if (!("tls" in options))
              options.tls = true;
            options.timeouts = {};
            for (var prop in defaults_default.a.TIMEOUTS) {
              options.timeouts[prop] = options[prop] || defaults_default.a.TIMEOUTS[prop];
            }
            ;
            if ("useBinaryProtocol" in options) {
              options.useBinaryProtocol = platform.supportsBinary && options.useBinaryProtocol;
            } else {
              options.useBinaryProtocol = platform.preferBinary;
            }
            if (options.clientId) {
              var headers = options.headers = options.headers || {};
              headers["X-Ably-ClientId"] = bufferutils.base64Encode(bufferutils.utf8Encode(options.clientId));
            }
            if (!("idempotentRestPublishing" in options)) {
              options.idempotentRestPublishing = true;
            }
            if (options.promises && !platform.Promise) {
              util_logger.logAction(util_logger.LOG_ERROR, "Defaults.normaliseOptions", "{promises: true} was specified, but no Promise constructor found; disabling promises");
              options.promises = false;
            }
            if (options.agents) {
              for (var key in options.agents) {
                defaults_default.a.agent += " " + key + "/" + options.agents[key];
              }
            }
            return options;
          };
          var util_defaults = defaults_default.a;
          var utils_hasOwnProperty = Object.prototype.hasOwnProperty;
          var utils_Utils = function() {
            var msgpack = platform.msgpack;
            function Utils() {
            }
            function randomPosn(arrOrStr) {
              return Math.floor(Math.random() * arrOrStr.length);
            }
            Utils.mixin = function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                if (!source) {
                  break;
                }
                for (var key in source) {
                  if (utils_hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            Utils.copy = function(src) {
              return Utils.mixin({}, src);
            };
            Utils.isArray = Array.isArray || function(ob) {
              return Object.prototype.toString.call(ob) == "[object Array]";
            };
            Utils.ensureArray = function(obj) {
              if (Utils.isEmptyArg(obj)) {
                return [];
              }
              if (Utils.isArray(obj)) {
                return obj;
              }
              return [obj];
            };
            Utils.isObject = function(ob) {
              return Object.prototype.toString.call(ob) == "[object Object]";
            };
            Utils.isEmpty = function(ob) {
              for (var prop in ob)
                return false;
              return true;
            };
            Utils.isOnlyPropIn = function(ob, property) {
              for (var prop in ob) {
                if (prop !== property) {
                  return false;
                }
              }
              return true;
            };
            Utils.isEmptyArg = function(arg) {
              return arg === null || arg === void 0;
            };
            Utils.shallowClone = function(ob) {
              var result = new Object();
              for (var prop in ob)
                result[prop] = ob[prop];
              return result;
            };
            Utils.prototypicalClone = function(ob, ownProperties) {
              function F() {
              }
              F.prototype = ob;
              var result = new F();
              if (ownProperties)
                Utils.mixin(result, ownProperties);
              return result;
            };
            Utils.inherits = platform.inherits || function(ctor, superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Utils.prototypicalClone(superCtor.prototype, { constructor: ctor });
            };
            Utils.containsValue = function(ob, val) {
              for (var i in ob) {
                if (ob[i] == val)
                  return true;
              }
              return false;
            };
            Utils.intersect = function(arr, ob) {
              return Utils.isArray(ob) ? Utils.arrIntersect(arr, ob) : Utils.arrIntersectOb(arr, ob);
            };
            Utils.arrIntersect = function(arr1, arr2) {
              var result = [];
              for (var i = 0; i < arr1.length; i++) {
                var member = arr1[i];
                if (Utils.arrIndexOf(arr2, member) != -1)
                  result.push(member);
              }
              return result;
            };
            Utils.arrIntersectOb = function(arr, ob) {
              var result = [];
              for (var i = 0; i < arr.length; i++) {
                var member = arr[i];
                if (member in ob)
                  result.push(member);
              }
              return result;
            };
            Utils.arrSubtract = function(arr1, arr2) {
              var result = [];
              for (var i = 0; i < arr1.length; i++) {
                var element = arr1[i];
                if (Utils.arrIndexOf(arr2, element) == -1)
                  result.push(element);
              }
              return result;
            };
            Utils.arrIndexOf = Array.prototype.indexOf ? function(arr, elem, fromIndex) {
              return arr.indexOf(elem, fromIndex);
            } : function(arr, elem, fromIndex) {
              fromIndex = fromIndex || 0;
              var len = arr.length;
              for (; fromIndex < len; fromIndex++) {
                if (arr[fromIndex] === elem) {
                  return fromIndex;
                }
              }
              return -1;
            };
            Utils.arrIn = function(arr, val) {
              return Utils.arrIndexOf(arr, val) !== -1;
            };
            Utils.arrDeleteValue = function(arr, val) {
              var idx = Utils.arrIndexOf(arr, val);
              var res = idx != -1;
              if (res)
                arr.splice(idx, 1);
              return res;
            };
            Utils.arrWithoutValue = function(arr, val) {
              var newArr = arr.slice();
              Utils.arrDeleteValue(newArr, val);
              return newArr;
            };
            Utils.keysArray = function(ob, ownOnly) {
              var result = [];
              for (var prop in ob) {
                if (ownOnly && !utils_hasOwnProperty.call(ob, prop))
                  continue;
                result.push(prop);
              }
              return result;
            };
            Utils.valuesArray = function(ob, ownOnly) {
              var result = [];
              for (var prop in ob) {
                if (ownOnly && !utils_hasOwnProperty.call(ob, prop))
                  continue;
                result.push(ob[prop]);
              }
              return result;
            };
            Utils.forInOwnNonNullProps = function(ob, fn) {
              for (var prop in ob) {
                if (utils_hasOwnProperty.call(ob, prop) && ob[prop]) {
                  fn(prop);
                }
              }
            };
            Utils.arrForEach = Array.prototype.forEach ? function(arr, fn) {
              arr.forEach(fn);
            } : function(arr, fn) {
              var len = arr.length;
              for (var i = 0; i < len; i++) {
                fn(arr[i], i, arr);
              }
            };
            Utils.safeArrForEach = function(arr, fn) {
              return Utils.arrForEach(arr.slice(), fn);
            };
            Utils.arrMap = Array.prototype.map ? function(arr, fn) {
              return arr.map(fn);
            } : function(arr, fn) {
              var result = [], len = arr.length;
              for (var i = 0; i < len; i++) {
                result.push(fn(arr[i], i, arr));
              }
              return result;
            };
            Utils.arrFilter = Array.prototype.filter ? function(arr, fn) {
              return arr.filter(fn);
            } : function(arr, fn) {
              var result = [], len = arr.length;
              for (var i = 0; i < len; i++) {
                if (fn(arr[i])) {
                  result.push(arr[i]);
                }
              }
              return result;
            };
            Utils.arrEvery = Array.prototype.every ? function(arr, fn) {
              return arr.every(fn);
            } : function(arr, fn) {
              var len = arr.length;
              for (var i = 0; i < len; i++) {
                if (!fn(arr[i], i, arr)) {
                  return false;
                }
                ;
              }
              return true;
            };
            Utils.allSame = function(arr, prop) {
              if (arr.length === 0) {
                return true;
              }
              var first = arr[0][prop];
              return Utils.arrEvery(arr, function(item) {
                return item[prop] === first;
              });
            };
            Utils.nextTick = platform.nextTick;
            var contentTypes = {
              json: "application/json",
              jsonp: "application/javascript",
              xml: "application/xml",
              html: "text/html",
              msgpack: "application/x-msgpack"
            };
            Utils.defaultGetHeaders = function(format) {
              var accept = contentTypes[format || "json"];
              return {
                accept,
                "X-Ably-Version": util_defaults.apiVersion,
                "Ably-Agent": util_defaults.agent
              };
            };
            Utils.defaultPostHeaders = function(format) {
              var accept, contentType;
              accept = contentType = contentTypes[format || "json"];
              return {
                accept,
                "content-type": contentType,
                "X-Ably-Version": util_defaults.apiVersion,
                "Ably-Agent": util_defaults.agent
              };
            };
            Utils.arrPopRandomElement = function(arr) {
              return arr.splice(randomPosn(arr), 1)[0];
            };
            Utils.toQueryString = function(params) {
              var parts = [];
              if (params) {
                for (var key in params)
                  parts.push(encodeURIComponent(key) + "=" + encodeURIComponent(params[key]));
              }
              return parts.length ? "?" + parts.join("&") : "";
            };
            Utils.parseQueryString = function(query) {
              var match, search = /([^?&=]+)=?([^&]*)/g, result = {};
              while (match = search.exec(query))
                result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);
              return result;
            };
            Utils.now = Date.now || function() {
              return new Date().getTime();
            };
            Utils.inspect = platform.inspect;
            Utils.isErrorInfo = function(err) {
              return err.constructor.name == "ErrorInfo";
            };
            Utils.inspectError = function(x) {
              return x && (Utils.isErrorInfo(x) || x.constructor.name == "Error" || x instanceof Error) ? x.toString() : Utils.inspect(x);
            };
            Utils.inspectBody = function(body) {
              if (bufferutils.isBuffer(body)) {
                return body.toString();
              } else if (typeof body === "string") {
                return body;
              } else {
                return platform.inspect(body);
              }
            };
            Utils.dataSizeBytes = function(data) {
              if (bufferutils.isBuffer(data)) {
                return bufferutils.byteLength(data);
              }
              if (typeof data === "string") {
                return platform.stringByteSize(data);
              }
              throw new Error("Expected input of Utils.dataSizeBytes to be a buffer or string, but was: " + typeof data);
            };
            Utils.cheapRandStr = function() {
              return String(Math.random()).substr(2);
            };
            Utils.randomString = platform.getRandomValues && typeof Uint8Array !== "undefined" ? function(numBytes) {
              var uIntArr = new Uint8Array(numBytes);
              platform.getRandomValues(uIntArr);
              return bufferutils.base64Encode(uIntArr);
            } : function(numBytes) {
              var charset = bufferutils.base64CharSet;
              var length = Math.round(numBytes * 4 / 3);
              var result = "";
              for (var i = 0; i < length; i++) {
                result += charset[randomPosn(charset)];
              }
              return result;
            };
            Utils.randomHexString = platform.getRandomValues && typeof Uint8Array !== "undefined" ? function(numBytes) {
              var uIntArr = new Uint8Array(numBytes);
              platform.getRandomValues(uIntArr);
              return bufferutils.hexEncode(uIntArr);
            } : function(numBytes) {
              var charset = bufferutils.hexCharSet;
              var length = numBytes * 2;
              var result = "";
              for (var i = 0; i < length; i++) {
                result += charset[randomPosn(charset)];
              }
              return result;
            };
            Utils.arrChooseN = function(arr, n) {
              var numItems = Math.min(n, arr.length), mutableArr = arr.slice(), result = [];
              for (var i = 0; i < numItems; i++) {
                result.push(Utils.arrPopRandomElement(mutableArr));
              }
              return result;
            };
            Utils.trim = String.prototype.trim ? function(str) {
              return str.trim();
            } : function(str) {
              return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
            };
            Utils.promisify = function(ob, fnName, args) {
              return new Promise(function(resolve, reject) {
                ob[fnName].apply(ob, Array.prototype.slice.call(args).concat(function(err, res) {
                  err ? reject(err) : resolve(res);
                }));
              });
            };
            Utils.decodeBody = function(body, format) {
              return format == "msgpack" ? msgpack.decode(body) : JSON.parse(String(body));
            };
            Utils.encodeBody = function(body, format) {
              return format == "msgpack" ? msgpack.encode(body, true) : JSON.stringify(body);
            };
            Utils.allToLowerCase = function(arr) {
              return Utils.arrMap(arr, function(element) {
                return element && element.toLowerCase();
              });
            };
            Utils.allToUpperCase = function(arr) {
              return Utils.arrMap(arr, function(element) {
                return element && element.toUpperCase();
              });
            };
            return Utils;
          }();
          var utils = utils_Utils;
          var external_got_ = __webpack_require__(7);
          var external_got_default = /* @__PURE__ */ __webpack_require__.n(external_got_);
          var external_http_ = __webpack_require__(5);
          var external_http_default = /* @__PURE__ */ __webpack_require__.n(external_http_);
          var external_https_ = __webpack_require__(6);
          var external_https_default = /* @__PURE__ */ __webpack_require__.n(external_https_);
          var http_Http = function() {
            var msgpack = platform.msgpack;
            var noop = function() {
            };
            var handler = function(uri, params, callback) {
              callback = callback || noop;
              return function(err, response, body) {
                if (err) {
                  callback(err);
                  return;
                }
                var statusCode = response.statusCode, headers = response.headers;
                if (statusCode >= 300) {
                  switch (headers["content-type"]) {
                    case "application/json":
                      body = JSON.parse(body);
                      break;
                    case "application/x-msgpack":
                      body = msgpack.decode(body);
                  }
                  var error = body.error ? errorinfo.fromValues(body.error) : new errorinfo(headers["x-ably-errormessage"] || "Error response received from server: " + statusCode + " body was: " + utils.inspect(body), headers["x-ably-errorcode"], statusCode);
                  callback(error, body, headers, true, statusCode);
                  return;
                }
                callback(null, body, headers, false, statusCode);
              };
            };
            function Http() {
            }
            function shouldFallback(err) {
              var code = err.code, statusCode = err.statusCode;
              return code === "ENETUNREACH" || code === "EHOSTUNREACH" || code === "EHOSTDOWN" || code === "ETIMEDOUT" || code === "ESOCKETTIMEDOUT" || code === "ENOTFOUND" || code === "ECONNRESET" || code === "ECONNREFUSED" || statusCode >= 500 && statusCode <= 504;
            }
            function getHosts(client) {
              var connection = client.connection, connectionHost = connection && connection.connectionManager.host;
              if (connectionHost) {
                return [connectionHost].concat(util_defaults.getFallbackHosts(client.options));
              }
              return util_defaults.getHosts(client.options);
            }
            Http._getHosts = getHosts;
            Http.methods = ["get", "delete", "post", "put", "patch"];
            Http.methodsWithoutBody = ["get", "delete"];
            Http.methodsWithBody = utils.arrSubtract(Http.methods, Http.methodsWithoutBody);
            utils.arrForEach(Http.methodsWithoutBody, function(method) {
              Http[method] = function(rest, path, headers, params, callback) {
                Http["do"](method, rest, path, headers, null, params, callback);
              };
              Http[method + "Uri"] = function(rest, uri, headers, params, callback) {
                Http.doUri(method, rest, uri, headers, null, params, callback);
              };
            });
            utils.arrForEach(Http.methodsWithBody, function(method) {
              Http[method] = function(rest, path, headers, body, params, callback) {
                Http["do"](method, rest, path, headers, body, params, callback);
              };
              Http[method + "Uri"] = function(rest, uri, headers, body, params, callback) {
                Http.doUri(method, rest, uri, headers, body, params, callback);
              };
            });
            Http["do"] = function(method, rest, path, headers, body, params, callback) {
              var uriFromHost = typeof path == "function" ? path : function(host) {
                return rest.baseUri(host) + path;
              };
              var doArgs = arguments;
              var currentFallback = rest._currentFallback;
              if (currentFallback) {
                if (currentFallback.validUntil > Date.now()) {
                  Http.doUri(method, rest, uriFromHost(currentFallback.host), headers, body, params, function(err) {
                    if (err && shouldFallback(err)) {
                      rest._currentFallback = null;
                      Http["do"].apply(Http, doArgs);
                      return;
                    }
                    callback.apply(null, arguments);
                  });
                  return;
                } else {
                  rest._currentFallback = null;
                }
              }
              var hosts = getHosts(rest);
              if (hosts.length == 1) {
                Http.doUri(method, rest, uriFromHost(hosts[0]), headers, body, params, callback);
                return;
              }
              var tryAHost = function(candidateHosts, persistOnSuccess) {
                var host = candidateHosts.shift();
                Http.doUri(method, rest, uriFromHost(host), headers, body, params, function(err) {
                  if (err && shouldFallback(err) && candidateHosts.length) {
                    tryAHost(candidateHosts, true);
                    return;
                  }
                  if (persistOnSuccess) {
                    rest._currentFallback = {
                      host,
                      validUntil: Date.now() + rest.options.timeouts.fallbackRetryTimeout
                    };
                  }
                  callback.apply(null, arguments);
                });
              };
              tryAHost(hosts);
            };
            Http.doUri = function(method, rest, uri, headers, body, params, callback) {
              var agentOptions = rest && rest.options.restAgentOptions || util_defaults.restAgentOptions;
              var doOptions = { headers: headers || void 0, responseType: "buffer" };
              if (body) {
                doOptions.body = body;
              }
              if (params)
                doOptions.searchParams = params;
              if (!Http.agent) {
                Http.agent = {
                  http: new external_http_default.a.Agent(agentOptions),
                  https: new external_https_default.a.Agent(agentOptions)
                };
              }
              doOptions.agent = Http.agent;
              doOptions.url = uri;
              doOptions.timeout = { request: (rest && rest.options.timeouts || util_defaults.TIMEOUTS).httpRequestTimeout };
              external_got_default.a[method](doOptions).then((res) => {
                handler(uri, params, callback)(null, res, res.body);
              }).catch((err) => {
                if (err instanceof external_got_default.a.HTTPError) {
                  handler(uri, params, callback)(null, err.response, err.response.body);
                  return;
                }
                handler(uri, params, callback)(err);
              });
            };
            Http.supportsAuthHeaders = true;
            Http.supportsLinkHeaders = true;
            Http.checkConnectivity = function(callback) {
              var upUrl = util_defaults.internetUpUrl;
              Http.getUri(null, upUrl, null, null, function(err, responseText) {
                callback(null, !err && responseText.toString().trim() === "yes");
              });
            };
            return Http;
          }();
          var util_http = http_Http;
          var multicaster_Multicaster = function() {
            function Multicaster(members) {
              members = members || [];
              var handler = function() {
                for (var i = 0; i < members.length; i++) {
                  var member = members[i];
                  if (member) {
                    try {
                      member.apply(null, arguments);
                    } catch (e) {
                      util_logger.logAction(util_logger.LOG_ERROR, "Multicaster multiple callback handler", "Unexpected exception: " + e + "; stack = " + e.stack);
                    }
                  }
                }
              };
              handler.push = function() {
                Array.prototype.push.apply(members, arguments);
              };
              return handler;
            }
            return Multicaster;
          }();
          var util_multicaster = multicaster_Multicaster;
          var Base64 = function() {
            function StringBuffer() {
              this.buffer = [];
            }
            StringBuffer.prototype.append = function append(string) {
              this.buffer.push(string);
              return this;
            };
            StringBuffer.prototype.toString = function toString() {
              return this.buffer.join("");
            };
            var Base642 = {
              codex: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
              encode: function(input) {
                var output = new StringBuffer();
                var codex = Base642.codex;
                var enumerator = new Utf8EncodeEnumerator(input);
                while (enumerator.moveNext()) {
                  var chr1 = enumerator.current;
                  enumerator.moveNext();
                  var chr2 = enumerator.current;
                  enumerator.moveNext();
                  var chr3 = enumerator.current;
                  var enc1 = chr1 >> 2;
                  var enc2 = (chr1 & 3) << 4 | chr2 >> 4;
                  var enc3 = (chr2 & 15) << 2 | chr3 >> 6;
                  var enc4 = chr3 & 63;
                  if (isNaN(chr2)) {
                    enc3 = enc4 = 64;
                  } else if (isNaN(chr3)) {
                    enc4 = 64;
                  }
                  output.append(codex.charAt(enc1) + codex.charAt(enc2) + codex.charAt(enc3) + codex.charAt(enc4));
                }
                return output.toString();
              },
              decode: function(input) {
                var output = new StringBuffer();
                var enumerator = new Base64DecodeEnumerator(input);
                while (enumerator.moveNext()) {
                  var charCode = enumerator.current;
                  if (charCode < 128)
                    output.append(String.fromCharCode(charCode));
                  else if (charCode > 191 && charCode < 224) {
                    enumerator.moveNext();
                    var charCode2 = enumerator.current;
                    output.append(String.fromCharCode((charCode & 31) << 6 | charCode2 & 63));
                  } else {
                    enumerator.moveNext();
                    var charCode2 = enumerator.current;
                    enumerator.moveNext();
                    var charCode3 = enumerator.current;
                    output.append(String.fromCharCode((charCode & 15) << 12 | (charCode2 & 63) << 6 | charCode3 & 63));
                  }
                }
                return output.toString();
              }
            };
            function Utf8EncodeEnumerator(input) {
              this._input = input;
              this._index = -1;
              this._buffer = [];
            }
            Utf8EncodeEnumerator.prototype = {
              current: Number.NaN,
              moveNext: function() {
                if (this._buffer.length > 0) {
                  this.current = this._buffer.shift();
                  return true;
                } else if (this._index >= this._input.length - 1) {
                  this.current = Number.NaN;
                  return false;
                } else {
                  var charCode = this._input.charCodeAt(++this._index);
                  if (charCode == 13 && this._input.charCodeAt(this._index + 1) == 10) {
                    charCode = 10;
                    this._index += 2;
                  }
                  if (charCode < 128) {
                    this.current = charCode;
                  } else if (charCode > 127 && charCode < 2048) {
                    this.current = charCode >> 6 | 192;
                    this._buffer.push(charCode & 63 | 128);
                  } else {
                    this.current = charCode >> 12 | 224;
                    this._buffer.push(charCode >> 6 & 63 | 128);
                    this._buffer.push(charCode & 63 | 128);
                  }
                  return true;
                }
              }
            };
            function Base64DecodeEnumerator(input) {
              this._input = input;
              this._index = -1;
              this._buffer = [];
            }
            Base64DecodeEnumerator.prototype = {
              current: 64,
              moveNext: function() {
                if (this._buffer.length > 0) {
                  this.current = this._buffer.shift();
                  return true;
                } else if (this._index >= this._input.length - 1) {
                  this.current = 64;
                  return false;
                } else {
                  var enc1 = Base642.codex.indexOf(this._input.charAt(++this._index));
                  var enc2 = Base642.codex.indexOf(this._input.charAt(++this._index));
                  var enc3 = Base642.codex.indexOf(this._input.charAt(++this._index));
                  var enc4 = Base642.codex.indexOf(this._input.charAt(++this._index));
                  var chr1 = enc1 << 2 | enc2 >> 4;
                  var chr2 = (enc2 & 15) << 4 | enc3 >> 2;
                  var chr3 = (enc3 & 3) << 6 | enc4;
                  this.current = chr1;
                  if (enc3 != 64)
                    this._buffer.push(chr2);
                  if (enc4 != 64)
                    this._buffer.push(chr3);
                  return true;
                }
              }
            };
            return Base642;
          }();
          var base64 = Base64;
          var hmac_sha256 = __webpack_require__(9);
          var hmac_sha256_default = /* @__PURE__ */ __webpack_require__.n(hmac_sha256);
          var enc_base64 = __webpack_require__(10);
          var auth_Auth = function() {
            var MAX_TOKEN_LENGTH = Math.pow(2, 17);
            function noop() {
            }
            function random() {
              return ("000000" + Math.floor(Math.random() * 1e16)).slice(-16);
            }
            function normaliseAuthcallbackError(err) {
              if (!utils.isErrorInfo(err)) {
                return new errorinfo(utils.inspectError(err), err.code || 40170, err.statusCode || 401);
              }
              if (!err.code) {
                if (err.statusCode === 403) {
                  err.code = 40300;
                } else {
                  err.code = 40170;
                  err.statusCode = 401;
                }
              }
              return err;
            }
            var hmac, toBase64;
            if (platform.createHmac) {
              toBase64 = function(str) {
                return Buffer.from(str, "ascii").toString("base64");
              };
              hmac = function(text, key) {
                var inst = platform.createHmac("SHA256", key);
                inst.update(text);
                return inst.digest("base64");
              };
            } else {
              toBase64 = base64.encode;
              hmac = function(text, key) {
                return Object(enc_base64["stringify"])(hmac_sha256_default()(text, key));
              };
            }
            function c14n(capability) {
              if (!capability)
                return "";
              if (typeof capability == "string")
                capability = JSON.parse(capability);
              var c14nCapability = Object.create(null);
              var keys = utils.keysArray(capability, true);
              if (!keys)
                return "";
              keys.sort();
              for (var i = 0; i < keys.length; i++) {
                c14nCapability[keys[i]] = capability[keys[i]].sort();
              }
              return JSON.stringify(c14nCapability);
            }
            function logAndValidateTokenAuthMethod(authOptions) {
              if (authOptions.authCallback) {
                util_logger.logAction(util_logger.LOG_MINOR, "Auth()", "using token auth with authCallback");
              } else if (authOptions.authUrl) {
                util_logger.logAction(util_logger.LOG_MINOR, "Auth()", "using token auth with authUrl");
              } else if (authOptions.key) {
                util_logger.logAction(util_logger.LOG_MINOR, "Auth()", "using token auth with client-side signing");
              } else if (authOptions.tokenDetails) {
                util_logger.logAction(util_logger.LOG_MINOR, "Auth()", "using token auth with supplied token only");
              } else {
                var msg = "authOptions must include valid authentication parameters";
                util_logger.logAction(util_logger.LOG_ERROR, "Auth()", msg);
                throw new Error(msg);
              }
            }
            function basicAuthForced(options) {
              return "useTokenAuth" in options && !options.useTokenAuth;
            }
            function useTokenAuth(options) {
              return options.useTokenAuth || !basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails);
            }
            function noWayToRenew(options) {
              return !options.key && !options.authCallback && !options.authUrl;
            }
            var trId = 0;
            function getTokenRequestId() {
              return trId++;
            }
            function Auth(client, options) {
              this.client = client;
              this.tokenParams = options.defaultTokenParams || {};
              this.currentTokenRequestId = null;
              this.waitingForTokenRequest = null;
              if (useTokenAuth(options)) {
                if (options.key && !hmac) {
                  var msg = "client-side token request signing not supported";
                  util_logger.logAction(util_logger.LOG_ERROR, "Auth()", msg);
                  throw new Error(msg);
                }
                if (noWayToRenew(options)) {
                  util_logger.logAction(util_logger.LOG_ERROR, "Auth()", "Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help");
                }
                this._saveTokenOptions(options.defaultTokenParams, options);
                logAndValidateTokenAuthMethod(this.authOptions);
              } else {
                if (!options.key) {
                  var msg = "No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)";
                  util_logger.logAction(util_logger.LOG_ERROR, "Auth()", msg);
                  throw new errorinfo(msg, 40160, 401);
                }
                util_logger.logAction(util_logger.LOG_MINOR, "Auth()", "anonymous, using basic auth");
                this._saveBasicOptions(options);
              }
            }
            Auth.prototype.authorize = function(tokenParams, authOptions, callback) {
              if (typeof tokenParams == "function" && !callback) {
                callback = tokenParams;
                authOptions = tokenParams = null;
              } else if (typeof authOptions == "function" && !callback) {
                callback = authOptions;
                authOptions = null;
              }
              if (!callback) {
                if (this.client.options.promises) {
                  return utils.promisify(this, "authorize", arguments);
                }
                callback = noop;
              }
              var self2 = this;
              if (authOptions && authOptions.key && this.authOptions.key !== authOptions.key) {
                throw new errorinfo("Unable to update auth options with incompatible key", 40102, 401);
              }
              if (authOptions && "force" in authOptions) {
                util_logger.logAction(util_logger.LOG_ERROR, "Auth.authorize", "Deprecation warning: specifying {force: true} in authOptions is no longer necessary, authorize() now always gets a new token. Please remove this, as in version 1.0 and later, having a non-null authOptions will overwrite stored library authOptions, which may not be what you want");
                if (utils.isOnlyPropIn(authOptions, "force")) {
                  authOptions = null;
                }
              }
              this._forceNewToken(tokenParams, authOptions, function(err, tokenDetails) {
                if (err) {
                  if (self2.client.connection) {
                    self2.client.connection.connectionManager.actOnErrorFromAuthorize(err);
                  }
                  callback(err);
                  return;
                }
                if (self2.client.connection) {
                  self2.client.connection.connectionManager.onAuthUpdated(tokenDetails, callback);
                } else {
                  callback(null, tokenDetails);
                }
              });
            };
            Auth.prototype.authorise = function() {
              util_logger.deprecated("Auth.authorise", "Auth.authorize");
              this.authorize.apply(this, arguments);
            };
            Auth.prototype._forceNewToken = function(tokenParams, authOptions, callback) {
              var self2 = this;
              this.tokenDetails = null;
              this._saveTokenOptions(tokenParams, authOptions);
              logAndValidateTokenAuthMethod(this.authOptions);
              this._ensureValidAuthCredentials(true, function(err, tokenDetails) {
                delete self2.tokenParams.timestamp;
                delete self2.authOptions.queryTime;
                callback(err, tokenDetails);
              });
            };
            Auth.prototype.requestToken = function(tokenParams, authOptions, callback) {
              if (typeof tokenParams == "function" && !callback) {
                callback = tokenParams;
                authOptions = tokenParams = null;
              } else if (typeof authOptions == "function" && !callback) {
                callback = authOptions;
                authOptions = null;
              }
              if (!callback && this.client.options.promises) {
                return utils.promisify(this, "requestToken", arguments);
              }
              authOptions = authOptions || this.authOptions;
              tokenParams = tokenParams || utils.copy(this.tokenParams);
              callback = callback || noop;
              var tokenRequestCallback, client = this.client;
              if (authOptions.authCallback) {
                util_logger.logAction(util_logger.LOG_MINOR, "Auth.requestToken()", "using token auth with authCallback");
                tokenRequestCallback = authOptions.authCallback;
              } else if (authOptions.authUrl) {
                util_logger.logAction(util_logger.LOG_MINOR, "Auth.requestToken()", "using token auth with authUrl");
                tokenRequestCallback = function(params, cb) {
                  var authHeaders = utils.mixin({ accept: "application/json, text/plain" }, authOptions.authHeaders), usePost = authOptions.authMethod && authOptions.authMethod.toLowerCase() === "post", providedQsParams;
                  var queryIdx = authOptions.authUrl.indexOf("?");
                  if (queryIdx > -1) {
                    providedQsParams = utils.parseQueryString(authOptions.authUrl.slice(queryIdx));
                    authOptions.authUrl = authOptions.authUrl.slice(0, queryIdx);
                    if (!usePost) {
                      authOptions.authParams = utils.mixin(providedQsParams, authOptions.authParams);
                    }
                  }
                  var authParams = utils.mixin({}, authOptions.authParams || {}, params);
                  var authUrlRequestCallback = function(err, body2, headers2, unpacked) {
                    var contentType;
                    if (err) {
                      util_logger.logAction(util_logger.LOG_MICRO, "Auth.requestToken().tokenRequestCallback", "Received Error: " + utils.inspectError(err));
                    } else {
                      contentType = headers2["content-type"];
                      util_logger.logAction(util_logger.LOG_MICRO, "Auth.requestToken().tokenRequestCallback", "Received; content-type: " + contentType + "; body: " + utils.inspectBody(body2));
                    }
                    if (err || unpacked)
                      return cb(err, body2);
                    if (bufferutils.isBuffer(body2))
                      body2 = body2.toString();
                    if (!contentType) {
                      cb(new errorinfo("authUrl response is missing a content-type header", 40170, 401));
                      return;
                    }
                    var json = contentType.indexOf("application/json") > -1, text = contentType.indexOf("text/plain") > -1 || contentType.indexOf("application/jwt") > -1;
                    if (!json && !text) {
                      cb(new errorinfo("authUrl responded with unacceptable content-type " + contentType + ", should be either text/plain, application/jwt or application/json", 40170, 401));
                      return;
                    }
                    if (json) {
                      if (body2.length > MAX_TOKEN_LENGTH) {
                        cb(new errorinfo("authUrl response exceeded max permitted length", 40170, 401));
                        return;
                      }
                      try {
                        body2 = JSON.parse(body2);
                      } catch (e) {
                        cb(new errorinfo("Unexpected error processing authURL response; err = " + e.message, 40170, 401));
                        return;
                      }
                    }
                    cb(null, body2, contentType);
                  };
                  util_logger.logAction(util_logger.LOG_MICRO, "Auth.requestToken().tokenRequestCallback", "Requesting token from " + authOptions.authUrl + "; Params: " + JSON.stringify(authParams) + "; method: " + (usePost ? "POST" : "GET"));
                  if (usePost) {
                    var headers = authHeaders || {};
                    headers["content-type"] = "application/x-www-form-urlencoded";
                    var body = utils.toQueryString(authParams).slice(1);
                    util_http.postUri(client, authOptions.authUrl, headers, body, providedQsParams, authUrlRequestCallback);
                  } else {
                    util_http.getUri(client, authOptions.authUrl, authHeaders || {}, authParams, authUrlRequestCallback);
                  }
                };
              } else if (authOptions.key) {
                var self2 = this;
                util_logger.logAction(util_logger.LOG_MINOR, "Auth.requestToken()", "using token auth with client-side signing");
                tokenRequestCallback = function(params, cb) {
                  self2.createTokenRequest(params, authOptions, cb);
                };
              } else {
                var msg = "Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)";
                util_logger.logAction(util_logger.LOG_ERROR, "Auth()", "library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help");
                callback(new errorinfo(msg, 40171, 403));
                return;
              }
              if ("capability" in tokenParams)
                tokenParams.capability = c14n(tokenParams.capability);
              var tokenRequest = function(signedTokenParams, tokenCb) {
                var keyName = signedTokenParams.keyName, path = "/keys/" + keyName + "/requestToken", tokenUri = function(host) {
                  return client.baseUri(host) + path;
                };
                var requestHeaders = utils.defaultPostHeaders();
                if (authOptions.requestHeaders)
                  utils.mixin(requestHeaders, authOptions.requestHeaders);
                util_logger.logAction(util_logger.LOG_MICRO, "Auth.requestToken().requestToken", "Sending POST to " + path + "; Token params: " + JSON.stringify(signedTokenParams));
                signedTokenParams = JSON.stringify(signedTokenParams);
                util_http.post(client, tokenUri, requestHeaders, signedTokenParams, null, tokenCb);
              };
              var tokenRequestCallbackTimeoutExpired = false, timeoutLength = this.client.options.timeouts.realtimeRequestTimeout, tokenRequestCallbackTimeout = setTimeout(function() {
                tokenRequestCallbackTimeoutExpired = true;
                var msg2 = "Token request callback timed out after " + timeoutLength / 1e3 + " seconds";
                util_logger.logAction(util_logger.LOG_ERROR, "Auth.requestToken()", msg2);
                callback(new errorinfo(msg2, 40170, 401));
              }, timeoutLength);
              tokenRequestCallback(tokenParams, function(err, tokenRequestOrDetails, contentType) {
                if (tokenRequestCallbackTimeoutExpired)
                  return;
                clearTimeout(tokenRequestCallbackTimeout);
                if (err) {
                  util_logger.logAction(util_logger.LOG_ERROR, "Auth.requestToken()", "token request signing call returned error; err = " + utils.inspectError(err));
                  callback(normaliseAuthcallbackError(err));
                  return;
                }
                if (typeof tokenRequestOrDetails === "string") {
                  if (tokenRequestOrDetails.length === 0) {
                    callback(new errorinfo("Token string is empty", 40170, 401));
                  } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {
                    callback(new errorinfo("Token string exceeded max permitted length (was " + tokenRequestOrDetails.length + " bytes)", 40170, 401));
                  } else if (tokenRequestOrDetails === "undefined" || tokenRequestOrDetails === "null") {
                    callback(new errorinfo("Token string was literal null/undefined", 40170, 401));
                  } else if (tokenRequestOrDetails[0] === "{" && !(contentType && contentType.indexOf("application/jwt") > -1)) {
                    callback(new errorinfo("Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details", 40170, 401));
                  } else {
                    callback(null, { token: tokenRequestOrDetails });
                  }
                  return;
                }
                if (typeof tokenRequestOrDetails !== "object") {
                  var msg2 = "Expected token request callback to call back with a token string or token request/details object, but got a " + typeof tokenRequestOrDetails;
                  util_logger.logAction(util_logger.LOG_ERROR, "Auth.requestToken()", msg2);
                  callback(new errorinfo(msg2, 40170, 401));
                  return;
                }
                var objectSize = JSON.stringify(tokenRequestOrDetails).length;
                if (objectSize > MAX_TOKEN_LENGTH && !authOptions.suppressMaxLengthCheck) {
                  callback(new errorinfo("Token request/details object exceeded max permitted stringified size (was " + objectSize + " bytes)", 40170, 401));
                  return;
                }
                if ("issued" in tokenRequestOrDetails) {
                  callback(null, tokenRequestOrDetails);
                  return;
                }
                if (!("keyName" in tokenRequestOrDetails)) {
                  var msg2 = "Expected token request callback to call back with a token string, token request object, or token details object";
                  util_logger.logAction(util_logger.LOG_ERROR, "Auth.requestToken()", msg2);
                  callback(new errorinfo(msg2, 40170, 401));
                  return;
                }
                tokenRequest(tokenRequestOrDetails, function(err2, tokenResponse, headers, unpacked) {
                  if (err2) {
                    util_logger.logAction(util_logger.LOG_ERROR, "Auth.requestToken()", "token request API call returned error; err = " + utils.inspectError(err2));
                    callback(normaliseAuthcallbackError(err2));
                    return;
                  }
                  if (!unpacked)
                    tokenResponse = JSON.parse(tokenResponse);
                  util_logger.logAction(util_logger.LOG_MINOR, "Auth.getToken()", "token received");
                  callback(null, tokenResponse);
                });
              });
            };
            Auth.prototype.createTokenRequest = function(tokenParams, authOptions, callback) {
              if (typeof tokenParams == "function" && !callback) {
                callback = tokenParams;
                authOptions = tokenParams = null;
              } else if (typeof authOptions == "function" && !callback) {
                callback = authOptions;
                authOptions = null;
              }
              if (!callback && this.client.options.promises) {
                return utils.promisify(this, "createTokenRequest", arguments);
              }
              authOptions = authOptions || this.authOptions;
              tokenParams = tokenParams || utils.copy(this.tokenParams);
              var key = authOptions.key;
              if (!key) {
                callback(new errorinfo("No key specified", 40101, 403));
                return;
              }
              var keyParts = key.split(":"), keyName = keyParts[0], keySecret = keyParts[1];
              if (!keySecret) {
                callback(new errorinfo("Invalid key specified", 40101, 403));
                return;
              }
              if (tokenParams.clientId === "") {
                callback(new errorinfo("clientId can\u2019t be an empty string", 40012, 400));
                return;
              }
              if ("capability" in tokenParams) {
                tokenParams.capability = c14n(tokenParams.capability);
              }
              var request = utils.mixin({ keyName }, tokenParams), clientId = tokenParams.clientId || "", ttl = tokenParams.ttl || "", capability = tokenParams.capability || "", self2 = this;
              (function(authoriseCb) {
                if (request.timestamp) {
                  authoriseCb();
                  return;
                }
                ;
                self2.getTimestamp(authOptions && authOptions.queryTime, function(err, time) {
                  if (err) {
                    callback(err);
                    return;
                  }
                  request.timestamp = time;
                  authoriseCb();
                });
              })(function() {
                var nonce = request.nonce || (request.nonce = random()), timestamp = request.timestamp;
                var signText = request.keyName + "\n" + ttl + "\n" + capability + "\n" + clientId + "\n" + timestamp + "\n" + nonce + "\n";
                request.mac = request.mac || hmac(signText, keySecret);
                util_logger.logAction(util_logger.LOG_MINOR, "Auth.getTokenRequest()", "generated signed request");
                callback(null, request);
              });
            };
            Auth.prototype.getAuthParams = function(callback) {
              if (this.method == "basic")
                callback(null, { key: this.key });
              else
                this._ensureValidAuthCredentials(false, function(err, tokenDetails) {
                  if (err) {
                    callback(err);
                    return;
                  }
                  callback(null, { access_token: tokenDetails.token });
                });
            };
            Auth.prototype.getAuthHeaders = function(callback) {
              if (this.method == "basic") {
                callback(null, { authorization: "Basic " + this.basicKey });
              } else {
                this._ensureValidAuthCredentials(false, function(err, tokenDetails) {
                  if (err) {
                    callback(err);
                    return;
                  }
                  callback(null, { authorization: "Bearer " + toBase64(tokenDetails.token) });
                });
              }
            };
            Auth.prototype.getTimestamp = function(queryTime, callback) {
              if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {
                this.client.time(callback);
              } else {
                callback(null, this.getTimestampUsingOffset());
              }
            };
            Auth.prototype.getTimestampUsingOffset = function() {
              return utils.now() + (this.client.serverTimeOffset || 0);
            };
            Auth.prototype.isTimeOffsetSet = function() {
              return this.client.serverTimeOffset !== null;
            };
            Auth.prototype._saveBasicOptions = function(authOptions) {
              this.method = "basic";
              this.key = authOptions.key;
              this.basicKey = toBase64(authOptions.key);
              this.authOptions = authOptions || {};
              if ("clientId" in authOptions) {
                this._userSetClientId(authOptions.clientId);
              }
            };
            Auth.prototype._saveTokenOptions = function(tokenParams, authOptions) {
              this.method = "token";
              if (tokenParams) {
                this.tokenParams = tokenParams;
              }
              if (authOptions) {
                if (authOptions.token) {
                  authOptions.tokenDetails = typeof authOptions.token === "string" ? { token: authOptions.token } : authOptions.token;
                }
                if (authOptions.tokenDetails) {
                  this.tokenDetails = authOptions.tokenDetails;
                }
                if ("clientId" in authOptions) {
                  this._userSetClientId(authOptions.clientId);
                }
                this.authOptions = authOptions;
              }
            };
            Auth.prototype._ensureValidAuthCredentials = function(forceSupersede, callback) {
              var self2 = this, token = this.tokenDetails;
              if (token) {
                if (this._tokenClientIdMismatch(token.clientId)) {
                  callback(new errorinfo("Mismatch between clientId in token (" + token.clientId + ") and current clientId (" + this.clientId + ")", 40102, 403));
                  return;
                }
                if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {
                  util_logger.logAction(util_logger.LOG_MINOR, "Auth.getToken()", "using cached token; expires = " + token.expires);
                  callback(null, token);
                  return;
                }
                util_logger.logAction(util_logger.LOG_MINOR, "Auth.getToken()", "deleting expired token");
                this.tokenDetails = null;
              }
              (this.waitingForTokenRequest || (this.waitingForTokenRequest = util_multicaster())).push(callback);
              if (this.currentTokenRequestId !== null && !forceSupersede) {
                return;
              }
              var tokenRequestId = this.currentTokenRequestId = getTokenRequestId();
              this.requestToken(this.tokenParams, this.authOptions, function(err, tokenResponse) {
                if (self2.currentTokenRequestId > tokenRequestId) {
                  util_logger.logAction(util_logger.LOG_MINOR, "Auth._ensureValidAuthCredentials()", "Discarding token request response; overtaken by newer one");
                  return;
                }
                self2.currentTokenRequestId = null;
                var callbacks = self2.waitingForTokenRequest || noop;
                self2.waitingForTokenRequest = null;
                if (err) {
                  callbacks(err);
                  return;
                }
                callbacks(null, self2.tokenDetails = tokenResponse);
              });
            };
            Auth.prototype._userSetClientId = function(clientId) {
              if (!(typeof clientId === "string" || clientId === null)) {
                throw new errorinfo("clientId must be either a string or null", 40012, 400);
              } else if (clientId === "*") {
                throw new errorinfo('Can\u2019t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: "*"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: "*"}, authOptions)', 40012, 400);
              } else {
                var err = this._uncheckedSetClientId(clientId);
                if (err)
                  throw err;
              }
            };
            Auth.prototype._uncheckedSetClientId = function(clientId) {
              if (this._tokenClientIdMismatch(clientId)) {
                var msg = "Unexpected clientId mismatch: client has " + this.clientId + ", requested " + clientId;
                var err = new errorinfo(msg, 40102, 401);
                util_logger.logAction(util_logger.LOG_ERROR, "Auth._uncheckedSetClientId()", msg);
                return err;
              } else {
                this.clientId = this.tokenParams.clientId = clientId;
                return null;
              }
            };
            Auth.prototype._tokenClientIdMismatch = function(tokenClientId) {
              return this.clientId && this.clientId !== "*" && tokenClientId && tokenClientId !== "*" && this.clientId !== tokenClientId;
            };
            Auth.isTokenErr = function(error) {
              return error.code && error.code >= 40140 && error.code < 40150;
            };
            return Auth;
          }();
          var client_auth = auth_Auth;
          var devicedetails_DeviceDetails = function() {
            function DeviceDetails() {
              this.id = void 0;
              this.deviceSecret = void 0;
              this.platform = void 0;
              this.formFactor = void 0;
              this.clientId = void 0;
              this.metadata = void 0;
              this.deviceIdentityToken = void 0;
              this.push = {
                recipient: void 0,
                state: void 0,
                error: void 0
              };
            }
            DeviceDetails.prototype.toJSON = function() {
              return {
                id: this.id,
                deviceSecret: this.deviceSecret,
                platform: this.platform,
                formFactor: this.formFactor,
                clientId: this.clientId,
                metadata: this.metadata,
                deviceIdentityToken: this.deviceIdentityToken,
                push: {
                  recipient: this.push.recipient,
                  state: this.push.state,
                  error: this.push.error
                }
              };
            };
            DeviceDetails.prototype.toString = function() {
              var result = "[DeviceDetails";
              if (this.id)
                result += "; id=" + this.id;
              if (this.platform)
                result += "; platform=" + this.platform;
              if (this.formFactor)
                result += "; formFactor=" + this.formFactor;
              if (this.clientId)
                result += "; clientId=" + this.clientId;
              if (this.metadata)
                result += "; metadata=" + this.metadata;
              if (this.deviceIdentityToken)
                result += "; deviceIdentityToken=" + JSON.stringify(this.deviceIdentityToken);
              if (this.push.recipient)
                result += "; push.recipient=" + JSON.stringify(this.push.recipient);
              if (this.push.state)
                result += "; push.state=" + this.push.state;
              if (this.push.error)
                result += "; push.error=" + JSON.stringify(this.push.error);
              if (this.push.metadata)
                result += "; push.metadata=" + this.push.metadata;
              result += "]";
              return result;
            };
            DeviceDetails.toRequestBody = utils.encodeBody;
            DeviceDetails.fromResponseBody = function(body, format) {
              if (format) {
                body = utils.decodeBody(body, format);
              }
              if (utils.isArray(body)) {
                return DeviceDetails.fromValuesArray(body);
              } else {
                return DeviceDetails.fromValues(body);
              }
            };
            DeviceDetails.fromValues = function(values) {
              values.error = values.error && ErrorInfo.fromValues(values.error);
              return utils.mixin(new DeviceDetails(), values);
            };
            DeviceDetails.fromValuesArray = function(values) {
              var count = values.length, result = new Array(count);
              for (var i = 0; i < count; i++)
                result[i] = DeviceDetails.fromValues(values[i]);
              return result;
            };
            return DeviceDetails;
          }();
          var devicedetails = devicedetails_DeviceDetails;
          var resource_Resource = function() {
            var msgpack = platform.msgpack;
            function Resource() {
            }
            function withAuthDetails(rest, headers, params, errCallback, opCallback) {
              if (util_http.supportsAuthHeaders) {
                rest.auth.getAuthHeaders(function(err, authHeaders) {
                  if (err)
                    errCallback(err);
                  else
                    opCallback(utils.mixin(authHeaders, headers), params);
                });
              } else {
                rest.auth.getAuthParams(function(err, authParams) {
                  if (err)
                    errCallback(err);
                  else
                    opCallback(headers, utils.mixin(authParams, params));
                });
              }
            }
            function unenvelope(callback, format) {
              return function(err, body, outerHeaders, unpacked, outerStatusCode) {
                if (err && !body) {
                  callback(err);
                  return;
                }
                if (!unpacked) {
                  try {
                    body = utils.decodeBody(body, format);
                  } catch (e) {
                    callback(e);
                    return;
                  }
                }
                if (body.statusCode === void 0) {
                  callback(err, body, outerHeaders, true, outerStatusCode);
                  return;
                }
                var wrappedStatusCode = body.statusCode, response = body.response, wrappedHeaders = body.headers;
                if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {
                  var wrappedErr = response && response.error || err;
                  if (!wrappedErr) {
                    wrappedErr = new Error("Error in unenveloping " + body);
                    wrappedErr.statusCode = wrappedStatusCode;
                  }
                  callback(wrappedErr, response, wrappedHeaders, true, wrappedStatusCode);
                  return;
                }
                callback(err, response, wrappedHeaders, true, wrappedStatusCode);
              };
            }
            function paramString(params) {
              var paramPairs = [];
              if (params) {
                for (var needle in params) {
                  paramPairs.push(needle + "=" + params[needle]);
                }
              }
              return paramPairs.join("&");
            }
            function urlFromPathAndParams(path, params) {
              return path + (params ? "?" : "") + paramString(params);
            }
            function logResponseHandler(callback, method, path, params) {
              return function(err, body, headers, unpacked, statusCode) {
                if (err) {
                  util_logger.logAction(util_logger.LOG_MICRO, "Resource." + method + "()", "Received Error; " + urlFromPathAndParams(path, params) + "; Error: " + utils.inspectError(err));
                } else {
                  util_logger.logAction(util_logger.LOG_MICRO, "Resource." + method + "()", "Received; " + urlFromPathAndParams(path, params) + "; Headers: " + paramString(headers) + "; StatusCode: " + statusCode + "; Body: " + (bufferutils.isBuffer(body) ? body.toString() : body));
                }
                if (callback) {
                  callback(err, body, headers, unpacked, statusCode);
                }
              };
            }
            utils.arrForEach(util_http.methodsWithoutBody, function(method) {
              Resource[method] = function(rest, path, origheaders, origparams, envelope, callback) {
                Resource["do"](method, rest, path, null, origheaders, origparams, envelope, callback);
              };
            });
            utils.arrForEach(util_http.methodsWithBody, function(method) {
              Resource[method] = function(rest, path, body, origheaders, origparams, envelope, callback) {
                Resource["do"](method, rest, path, body, origheaders, origparams, envelope, callback);
              };
            });
            Resource["do"] = function(method, rest, path, body, origheaders, origparams, envelope, callback) {
              if (util_logger.shouldLog(util_logger.LOG_MICRO)) {
                callback = logResponseHandler(callback, method, path, origparams);
              }
              if (envelope) {
                callback = callback && unenvelope(callback, envelope);
                (origparams = origparams || {})["envelope"] = envelope;
              }
              function doRequest(headers, params) {
                if (util_logger.shouldLog(util_logger.LOG_MICRO)) {
                  util_logger.logAction(util_logger.LOG_MICRO, "Resource." + method + "()", "Sending; " + urlFromPathAndParams(path, params));
                }
                var args = [rest, path, headers, body, params, function(err, res, headers2, unpacked, statusCode) {
                  if (err && client_auth.isTokenErr(err)) {
                    rest.auth.authorize(null, null, function(err2) {
                      if (err2) {
                        callback(err2);
                        return;
                      }
                      withAuthDetails(rest, origheaders, origparams, callback, doRequest);
                    });
                    return;
                  }
                  callback(err, res, headers2, unpacked, statusCode);
                }];
                if (!body) {
                  args.splice(3, 1);
                }
                if (util_logger.shouldLog(util_logger.LOG_MICRO)) {
                  var decodedBody = body;
                  if ((headers["content-type"] || "").indexOf("msgpack") > 0) {
                    try {
                      decodedBody = msgpack.decode(body);
                    } catch (decodeErr) {
                      util_logger.logAction(util_logger.LOG_MICRO, "Resource." + method + "()", "Sending MsgPack Decoding Error: " + utils.inspectError(decodeErr));
                    }
                  }
                  util_logger.logAction(util_logger.LOG_MICRO, "Resource." + method + "()", "Sending; " + urlFromPathAndParams(path, params) + "; Body: " + decodedBody);
                }
                util_http[method].apply(this, args);
              }
              withAuthDetails(rest, origheaders, origparams, callback, doRequest);
            };
            return Resource;
          }();
          var client_resource = resource_Resource;
          var paginatedresource_PaginatedResource = function() {
            function getRelParams(linkUrl) {
              var urlMatch = linkUrl.match(/^\.\/(\w+)\?(.*)$/);
              return urlMatch && utils.parseQueryString(urlMatch[2]);
            }
            function parseRelLinks(linkHeader) {
              if (typeof linkHeader == "string")
                linkHeader = linkHeader.split(",");
              var relParams = {};
              for (var i = 0; i < linkHeader.length; i++) {
                var linkMatch = linkHeader[i].match(/^\s*<(.+)>;\s*rel="(\w+)"$/);
                if (linkMatch) {
                  var params = getRelParams(linkMatch[1]);
                  if (params)
                    relParams[linkMatch[2]] = params;
                }
              }
              return relParams;
            }
            function PaginatedResource(rest, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {
              this.rest = rest;
              this.path = path;
              this.headers = headers;
              this.envelope = envelope;
              this.bodyHandler = bodyHandler;
              this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;
            }
            utils.arrForEach(util_http.methodsWithoutBody, function(method) {
              PaginatedResource.prototype[method] = function(params, callback) {
                var self2 = this;
                client_resource[method](self2.rest, self2.path, self2.headers, params, self2.envelope, function(err, body, headers, unpacked, statusCode) {
                  self2.handlePage(err, body, headers, unpacked, statusCode, callback);
                });
              };
            });
            utils.arrForEach(util_http.methodsWithBody, function(method) {
              PaginatedResource.prototype[method] = function(params, body, callback) {
                var self2 = this;
                client_resource[method](self2.rest, self2.path, body, self2.headers, params, self2.envelope, function(err, resbody, headers, unpacked, statusCode) {
                  if (callback) {
                    self2.handlePage(err, resbody, headers, unpacked, statusCode, callback);
                  }
                });
              };
            });
            function returnErrOnly(err, body, useHPR) {
              return !(useHPR && (body || typeof err.code === "number"));
            }
            PaginatedResource.prototype.handlePage = function(err, body, headers, unpacked, statusCode, callback) {
              if (err && returnErrOnly(err, body, this.useHttpPaginatedResponse)) {
                util_logger.logAction(util_logger.LOG_ERROR, "PaginatedResource.handlePage()", "Unexpected error getting resource: err = " + utils.inspectError(err));
                callback(err);
                return;
              }
              var items, linkHeader, relParams;
              try {
                items = this.bodyHandler(body, headers, unpacked);
              } catch (e) {
                callback(err || e);
                return;
              }
              if (headers && (linkHeader = headers["Link"] || headers["link"])) {
                relParams = parseRelLinks(linkHeader);
              }
              if (this.useHttpPaginatedResponse) {
                callback(null, new HttpPaginatedResponse(this, items, headers, statusCode, relParams, err));
              } else {
                callback(null, new PaginatedResult(this, items, relParams));
              }
            };
            function PaginatedResult(resource, items, relParams) {
              this.resource = resource;
              this.items = items;
              if (relParams) {
                var self2 = this;
                if ("first" in relParams) {
                  this.first = function(cb) {
                    if (!cb && self2.resource.rest.options.promises) {
                      return utils.promisify(self2, "first", []);
                    }
                    self2.get(relParams.first, cb);
                  };
                }
                if ("current" in relParams) {
                  this.current = function(cb) {
                    if (!cb && self2.resource.rest.options.promises) {
                      return utils.promisify(self2, "current", []);
                    }
                    self2.get(relParams.current, cb);
                  };
                }
                this.next = function(cb) {
                  if (!cb && self2.resource.rest.options.promises) {
                    return utils.promisify(self2, "next", []);
                  }
                  if ("next" in relParams) {
                    self2.get(relParams.next, cb);
                  } else {
                    cb(null, null);
                  }
                };
                this.hasNext = function() {
                  return "next" in relParams;
                };
                this.isLast = function() {
                  return !this.hasNext();
                };
              }
            }
            PaginatedResult.prototype.get = function(params, callback) {
              var res = this.resource;
              client_resource.get(res.rest, res.path, res.headers, params, res.envelope, function(err, body, headers, unpacked, statusCode) {
                res.handlePage(err, body, headers, unpacked, statusCode, callback);
              });
            };
            function HttpPaginatedResponse(resource, items, headers, statusCode, relParams, err) {
              PaginatedResult.call(this, resource, items, relParams);
              this.statusCode = statusCode;
              this.success = statusCode < 300 && statusCode >= 200;
              this.headers = headers;
              this.errorCode = err && err.code;
              this.errorMessage = err && err.message;
            }
            utils.inherits(HttpPaginatedResponse, PaginatedResult);
            return PaginatedResource;
          }();
          var paginatedresource = paginatedresource_PaginatedResource;
          var pushchannelsubscription_PushChannelSubscription = function() {
            function PushChannelSubscription() {
              this.channel = void 0;
              this.deviceId = void 0;
              this.clientId = void 0;
            }
            PushChannelSubscription.prototype.toJSON = function() {
              return {
                channel: this.channel,
                deviceId: this.deviceId,
                clientId: this.clientId
              };
            };
            PushChannelSubscription.prototype.toString = function() {
              var result = "[PushChannelSubscription";
              if (this.channel)
                result += "; channel=" + this.channel;
              if (this.deviceId)
                result += "; deviceId=" + this.deviceId;
              if (this.clientId)
                result += "; clientId=" + this.clientId;
              result += "]";
              return result;
            };
            PushChannelSubscription.toRequestBody = utils.encodeBody;
            PushChannelSubscription.fromResponseBody = function(body, format) {
              if (format) {
                body = utils.decodeBody(body, format);
              }
              if (utils.isArray(body)) {
                return PushChannelSubscription.fromValuesArray(body);
              } else {
                return PushChannelSubscription.fromValues(body);
              }
            };
            PushChannelSubscription.fromValues = function(values) {
              return utils.mixin(new PushChannelSubscription(), values);
            };
            PushChannelSubscription.fromValuesArray = function(values) {
              var count = values.length, result = new Array(count);
              for (var i = 0; i < count; i++)
                result[i] = PushChannelSubscription.fromValues(values[i]);
              return result;
            };
            return PushChannelSubscription;
          }();
          var pushchannelsubscription = pushchannelsubscription_PushChannelSubscription;
          var push_Push = function() {
            var noop = function() {
            };
            function Push(rest) {
              this.rest = rest;
              this.admin = new Admin(rest);
            }
            function Admin(rest) {
              this.rest = rest;
              this.deviceRegistrations = new DeviceRegistrations(rest);
              this.channelSubscriptions = new ChannelSubscriptions(rest);
            }
            Admin.prototype.publish = function(recipient, payload, callback) {
              var rest = this.rest;
              var format = rest.options.useBinaryProtocol ? "msgpack" : "json", requestBody = utils.mixin({ recipient }, payload), headers = utils.defaultPostHeaders(format), params = {};
              if (typeof callback !== "function") {
                if (this.rest.options.promises) {
                  return utils.promisify(this, "publish", arguments);
                }
                callback = noop;
              }
              if (rest.options.headers)
                utils.mixin(headers, rest.options.headers);
              if (rest.options.pushFullWait)
                utils.mixin(params, { fullWait: "true" });
              requestBody = utils.encodeBody(requestBody, format);
              client_resource.post(rest, "/push/publish", requestBody, headers, params, false, function(err) {
                callback(err);
              });
            };
            function DeviceRegistrations(rest) {
              this.rest = rest;
            }
            DeviceRegistrations.prototype.save = function(device, callback) {
              var rest = this.rest;
              var format = rest.options.useBinaryProtocol ? "msgpack" : "json", requestBody = devicedetails.fromValues(device), headers = utils.defaultPostHeaders(format), params = {};
              if (typeof callback !== "function") {
                if (this.rest.options.promises) {
                  return utils.promisify(this, "save", arguments);
                }
                callback = noop;
              }
              if (rest.options.headers)
                utils.mixin(headers, rest.options.headers);
              if (rest.options.pushFullWait)
                utils.mixin(params, { fullWait: "true" });
              requestBody = utils.encodeBody(requestBody, format);
              client_resource.put(rest, "/push/deviceRegistrations/" + encodeURIComponent(device.id), requestBody, headers, params, false, function(err, body, headers2, unpacked) {
                callback(err, !err && devicedetails.fromResponseBody(body, !unpacked && format));
              });
            };
            DeviceRegistrations.prototype.get = function(deviceIdOrDetails, callback) {
              var rest = this.rest, format = rest.options.useBinaryProtocol ? "msgpack" : "json", headers = utils.defaultGetHeaders(format), deviceId = deviceIdOrDetails.id || deviceIdOrDetails;
              if (typeof callback !== "function") {
                if (this.rest.options.promises) {
                  return utils.promisify(this, "get", arguments);
                }
                callback = noop;
              }
              if (typeof deviceId !== "string" || !deviceId.length) {
                callback(new errorinfo("First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails", 4e4, 400));
                return;
              }
              if (rest.options.headers)
                utils.mixin(headers, rest.options.headers);
              client_resource.get(rest, "/push/deviceRegistrations/" + encodeURIComponent(deviceId), headers, {}, false, function(err, body, headers2, unpacked) {
                callback(err, !err && devicedetails.fromResponseBody(body, !unpacked && format));
              });
            };
            DeviceRegistrations.prototype.list = function(params, callback) {
              var rest = this.rest, format = rest.options.useBinaryProtocol ? "msgpack" : "json", envelope = util_http.supportsLinkHeaders ? void 0 : format, headers = utils.defaultGetHeaders(format);
              if (typeof callback !== "function") {
                if (this.rest.options.promises) {
                  return utils.promisify(this, "list", arguments);
                }
                callback = noop;
              }
              if (rest.options.headers)
                utils.mixin(headers, rest.options.headers);
              new paginatedresource(rest, "/push/deviceRegistrations", headers, envelope, function(body, headers2, unpacked) {
                return devicedetails.fromResponseBody(body, !unpacked && format);
              }).get(params, callback);
            };
            DeviceRegistrations.prototype.remove = function(deviceIdOrDetails, callback) {
              var rest = this.rest, format = rest.options.useBinaryProtocol ? "msgpack" : "json", headers = utils.defaultGetHeaders(format), params = {}, deviceId = deviceIdOrDetails.id || deviceIdOrDetails;
              if (typeof callback !== "function") {
                if (this.rest.options.promises) {
                  return utils.promisify(this, "remove", arguments);
                }
                callback = noop;
              }
              if (typeof deviceId !== "string" || !deviceId.length) {
                callback(new errorinfo("First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails", 4e4, 400));
                return;
              }
              if (rest.options.headers)
                utils.mixin(headers, rest.options.headers);
              if (rest.options.pushFullWait)
                utils.mixin(params, { fullWait: "true" });
              client_resource["delete"](rest, "/push/deviceRegistrations/" + encodeURIComponent(deviceId), headers, params, false, function(err) {
                callback(err);
              });
            };
            DeviceRegistrations.prototype.removeWhere = function(params, callback) {
              var rest = this.rest, format = rest.options.useBinaryProtocol ? "msgpack" : "json", headers = utils.defaultGetHeaders(format);
              if (typeof callback !== "function") {
                if (this.rest.options.promises) {
                  return utils.promisify(this, "removeWhere", arguments);
                }
                callback = noop;
              }
              if (rest.options.headers)
                utils.mixin(headers, rest.options.headers);
              if (rest.options.pushFullWait)
                utils.mixin(params, { fullWait: "true" });
              client_resource["delete"](rest, "/push/deviceRegistrations", headers, params, false, function(err) {
                callback(err);
              });
            };
            function ChannelSubscriptions(rest) {
              this.rest = rest;
            }
            ChannelSubscriptions.prototype.save = function(subscription, callback) {
              var rest = this.rest;
              var format = rest.options.useBinaryProtocol ? "msgpack" : "json", requestBody = pushchannelsubscription.fromValues(subscription), headers = utils.defaultPostHeaders(format), params = {};
              if (typeof callback !== "function") {
                if (this.rest.options.promises) {
                  return utils.promisify(this, "save", arguments);
                }
                callback = noop;
              }
              if (rest.options.headers)
                utils.mixin(headers, rest.options.headers);
              if (rest.options.pushFullWait)
                utils.mixin(params, { fullWait: "true" });
              requestBody = utils.encodeBody(requestBody, format);
              client_resource.post(rest, "/push/channelSubscriptions", requestBody, headers, params, false, function(err, body, headers2, unpacked) {
                callback(err, !err && pushchannelsubscription.fromResponseBody(body, !unpacked && format));
              });
            };
            ChannelSubscriptions.prototype.list = function(params, callback) {
              var rest = this.rest, format = rest.options.useBinaryProtocol ? "msgpack" : "json", envelope = util_http.supportsLinkHeaders ? void 0 : format, headers = utils.defaultGetHeaders(format);
              if (typeof callback !== "function") {
                if (this.rest.options.promises) {
                  return utils.promisify(this, "list", arguments);
                }
                callback = noop;
              }
              if (rest.options.headers)
                utils.mixin(headers, rest.options.headers);
              new paginatedresource(rest, "/push/channelSubscriptions", headers, envelope, function(body, headers2, unpacked) {
                return pushchannelsubscription.fromResponseBody(body, !unpacked && format);
              }).get(params, callback);
            };
            ChannelSubscriptions.prototype.removeWhere = function(params, callback) {
              var rest = this.rest, format = rest.options.useBinaryProtocol ? "msgpack" : "json", headers = utils.defaultGetHeaders(format);
              if (typeof callback !== "function") {
                if (this.rest.options.promises) {
                  return utils.promisify(this, "removeWhere", arguments);
                }
                callback = noop;
              }
              if (rest.options.headers)
                utils.mixin(headers, rest.options.headers);
              if (rest.options.pushFullWait)
                utils.mixin(params, { fullWait: "true" });
              client_resource["delete"](rest, "/push/channelSubscriptions", headers, params, false, function(err) {
                callback(err);
              });
            };
            ChannelSubscriptions.prototype.remove = ChannelSubscriptions.prototype.removeWhere;
            ChannelSubscriptions.prototype.listChannels = function(params, callback) {
              var rest = this.rest, format = rest.options.useBinaryProtocol ? "msgpack" : "json", envelope = util_http.supportsLinkHeaders ? void 0 : format, headers = utils.defaultGetHeaders(format);
              if (typeof callback !== "function") {
                if (this.rest.options.promises) {
                  return utils.promisify(this, "listChannels", arguments);
                }
                callback = noop;
              }
              if (rest.options.headers)
                utils.mixin(headers, rest.options.headers);
              if (rest.options.pushFullWait)
                utils.mixin(params, { fullWait: "true" });
              new paginatedresource(rest, "/push/channels", headers, envelope, function(body, headers2, unpacked) {
                var f = !unpacked && format;
                if (f) {
                  body = utils.decodeBody(body, format);
                }
                for (var i = 0; i < body.length; i++) {
                  body[i] = String(body[i]);
                }
                return body;
              }).get(params, callback);
            };
            return Push;
          }();
          var push = push_Push;
          var eventemitter_hasOwnProperty = Object.prototype.hasOwnProperty;
          var eventemitter_EventEmitter = function() {
            function EventEmitter() {
              this.any = [];
              this.events = Object.create(null);
              this.anyOnce = [];
              this.eventsOnce = Object.create(null);
            }
            function callListener(eventThis, listener, args) {
              try {
                listener.apply(eventThis, args);
              } catch (e) {
                util_logger.logAction(util_logger.LOG_ERROR, "EventEmitter.emit()", "Unexpected listener exception: " + e + "; stack = " + (e && e.stack));
              }
            }
            function removeListener(targetListeners, listener, eventFilter) {
              var listeners, idx, eventName, targetListenersIndex;
              for (targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {
                listeners = targetListeners[targetListenersIndex];
                if (eventFilter) {
                  listeners = listeners[eventFilter];
                }
                if (utils.isArray(listeners)) {
                  while ((idx = utils.arrIndexOf(listeners, listener)) !== -1) {
                    listeners.splice(idx, 1);
                  }
                  if (eventFilter && listeners.length === 0) {
                    delete targetListeners[targetListenersIndex][eventFilter];
                  }
                } else if (utils.isObject(listeners)) {
                  for (eventName in listeners) {
                    if (eventemitter_hasOwnProperty.call(listeners, eventName) && utils.isArray(listeners[eventName])) {
                      removeListener([listeners], listener, eventName);
                    }
                  }
                }
              }
            }
            EventEmitter.prototype.on = function(event, listener) {
              if (arguments.length == 1 && typeof event == "function") {
                this.any.push(event);
              } else if (utils.isEmptyArg(event)) {
                this.any.push(listener);
              } else if (utils.isArray(event)) {
                var self2 = this;
                utils.arrForEach(event, function(ev) {
                  self2.on(ev, listener);
                });
              } else {
                var listeners = this.events[event] || (this.events[event] = []);
                listeners.push(listener);
              }
            };
            EventEmitter.prototype.off = function(event, listener) {
              if (arguments.length == 0 || utils.isEmptyArg(event) && utils.isEmptyArg(listener)) {
                this.any = [];
                this.events = Object.create(null);
                this.anyOnce = [];
                this.eventsOnce = Object.create(null);
                return;
              }
              if (arguments.length == 1) {
                if (typeof event == "function") {
                  listener = event;
                  event = null;
                }
              }
              if (listener && utils.isEmptyArg(event)) {
                removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);
                return;
              }
              if (utils.isArray(event)) {
                var self2 = this;
                utils.arrForEach(event, function(ev) {
                  self2.off(ev, listener);
                });
              }
              if (listener) {
                removeListener([this.events, this.eventsOnce], listener, event);
              } else {
                delete this.events[event];
                delete this.eventsOnce[event];
              }
            };
            EventEmitter.prototype.listeners = function(event) {
              if (event) {
                var listeners = this.events[event] || [];
                if (this.eventsOnce[event])
                  Array.prototype.push.apply(listeners, this.eventsOnce[event]);
                return listeners.length ? listeners : null;
              }
              return this.any.length ? this.any : null;
            };
            EventEmitter.prototype.emit = function(event) {
              var args = Array.prototype.slice.call(arguments, 1);
              var eventThis = { event };
              var listeners = [];
              if (this.anyOnce.length) {
                Array.prototype.push.apply(listeners, this.anyOnce);
                this.anyOnce = [];
              }
              if (this.any.length) {
                Array.prototype.push.apply(listeners, this.any);
              }
              var eventsOnceListeners = this.eventsOnce[event];
              if (eventsOnceListeners) {
                Array.prototype.push.apply(listeners, eventsOnceListeners);
                delete this.eventsOnce[event];
              }
              var eventsListeners = this.events[event];
              if (eventsListeners) {
                Array.prototype.push.apply(listeners, eventsListeners);
              }
              utils.arrForEach(listeners, function(listener) {
                callListener(eventThis, listener, args);
              });
            };
            EventEmitter.prototype.once = function(event, listener) {
              var argCount = arguments.length, self2 = this;
              if ((argCount === 0 || argCount === 1 && typeof event !== "function") && platform.Promise) {
                return new platform.Promise(function(resolve) {
                  self2.once(event, resolve);
                });
              }
              if (arguments.length == 1 && typeof event == "function") {
                this.anyOnce.push(event);
              } else if (utils.isEmptyArg(event)) {
                this.anyOnce.push(listener);
              } else if (utils.isArray(event)) {
                var listenerWrapper = function() {
                  var args = Array.prototype.slice.call(arguments);
                  utils.arrForEach(event, function(ev) {
                    self2.off(ev, listenerWrapper);
                  });
                  listener.apply(this, args);
                };
                utils.arrForEach(event, function(ev) {
                  self2.on(ev, listenerWrapper);
                });
              } else {
                var listeners = this.eventsOnce[event] || (this.eventsOnce[event] = []);
                listeners.push(listener);
              }
            };
            EventEmitter.prototype.whenState = function(targetState, currentState, listener) {
              var eventThis = { event: targetState }, self2 = this, listenerArgs = Array.prototype.slice.call(arguments, 3);
              if (typeof targetState !== "string" || typeof currentState !== "string") {
                throw "whenState requires a valid event String argument";
              }
              if (typeof listener !== "function" && platform.Promise) {
                return new platform.Promise(function(resolve) {
                  EventEmitter.prototype.whenState.apply(self2, [targetState, currentState, resolve].concat(listenerArgs));
                });
              }
              if (targetState === currentState) {
                callListener(eventThis, listener, listenerArgs);
              } else {
                this.once(targetState, listener);
              }
            };
            return EventEmitter;
          }();
          var eventemitter = eventemitter_EventEmitter;
          var crypto_Crypto = function() {
            var crypto = __webpack_require__(2);
            var util = __webpack_require__(3);
            var DEFAULT_ALGORITHM = "aes";
            var DEFAULT_KEYLENGTH = 256;
            var DEFAULT_MODE = "cbc";
            var DEFAULT_BLOCKLENGTH = 16;
            function generateRandom(bytes, callback) {
              return crypto.randomBytes(bytes, callback);
            }
            function getPaddedLength(plaintextLength) {
              return plaintextLength + DEFAULT_BLOCKLENGTH & -DEFAULT_BLOCKLENGTH;
            }
            function validateCipherParams(params) {
              if (params.algorithm === "aes" && params.mode === "cbc") {
                if (params.keyLength === 128 || params.keyLength === 256) {
                  return;
                }
                throw new Error("Unsupported key length " + params.keyLength + " for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)");
              }
            }
            function normaliseBase64(string) {
              return string.replace("_", "/").replace("-", "+");
            }
            var emptyBlock = Buffer.alloc(DEFAULT_BLOCKLENGTH);
            function filledBuffer(length, value) {
              var result = Buffer.alloc(length);
              result.fill(value);
              return result;
            }
            var pkcs5Padding = [filledBuffer(16, 16)];
            for (var i = 1; i <= 16; i++)
              pkcs5Padding.push(filledBuffer(i, i));
            function toBuffer(bufferOrString) {
              return typeof bufferOrString == "string" ? Buffer.from(bufferOrString, "binary") : bufferOrString;
            }
            function Crypto() {
            }
            function CipherParams() {
              this.algorithm = null;
              this.keyLength = null;
              this.mode = null;
              this.key = null;
              this.iv = null;
            }
            Crypto.CipherParams = CipherParams;
            function isInstCipherParams(params) {
              return params.algorithm && params.key && params.keyLength && params.mode;
            }
            Crypto.getDefaultParams = function(params) {
              var key;
              if (typeof params === "function" || typeof params === "string") {
                util_logger.deprecated("Crypto.getDefaultParams(key, callback)", "Crypto.getDefaultParams({key: key})");
                if (typeof params === "function") {
                  Crypto.generateRandomKey(function(key2) {
                    params(null, Crypto.getDefaultParams({ key: key2 }));
                  });
                } else if (typeof arguments[1] === "function") {
                  arguments[1](null, Crypto.getDefaultParams({ key: params }));
                } else {
                  throw new Error("Invalid arguments for Crypto.getDefaultParams");
                }
                return;
              }
              if (!params.key) {
                throw new Error("Crypto.getDefaultParams: a key is required");
              }
              if (typeof params.key === "string") {
                key = bufferutils.base64Decode(normaliseBase64(params.key));
              } else {
                key = params.key;
              }
              var cipherParams = new CipherParams();
              cipherParams.key = key;
              cipherParams.algorithm = params.algorithm || DEFAULT_ALGORITHM;
              cipherParams.keyLength = key.length * 8;
              cipherParams.mode = params.mode || DEFAULT_MODE;
              if (params.keyLength && params.keyLength !== cipherParams.keyLength) {
                throw new Error("Crypto.getDefaultParams: a keyLength of " + params.keyLength + " was specified, but the key actually has length " + cipherParams.keyLength);
              }
              validateCipherParams(cipherParams);
              return cipherParams;
            };
            Crypto.generateRandomKey = function(keyLength, callback) {
              if (arguments.length == 1 && typeof keyLength == "function") {
                callback = keyLength;
                keyLength = void 0;
              }
              generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8, callback);
            };
            Crypto.getCipher = function(params) {
              var cipherParams = isInstCipherParams(params) ? params : Crypto.getDefaultParams(params);
              var iv = params.iv || generateRandom(DEFAULT_BLOCKLENGTH);
              return { cipherParams, cipher: new CBCCipher(cipherParams, iv) };
            };
            function CBCCipher(params, iv) {
              var algorithm = this.algorithm = params.algorithm + "-" + String(params.keyLength) + "-" + params.mode;
              var key = this.key = params.key;
              var iv = this.iv = iv;
              var key = this.key = params.key;
              this.encryptCipher = crypto.createCipheriv(algorithm, key, iv);
              this.blockLength = iv.length;
            }
            CBCCipher.prototype.encrypt = function(plaintext, callback) {
              util_logger.logAction(util_logger.LOG_MICRO, "CBCCipher.encrypt()", "");
              var plaintextLength = plaintext.length, paddedLength = getPaddedLength(plaintextLength), iv = this.getIv();
              var cipherOut = this.encryptCipher.update(Buffer.concat([plaintext, pkcs5Padding[paddedLength - plaintextLength]]));
              var ciphertext = Buffer.concat([iv, toBuffer(cipherOut)]);
              return callback(null, ciphertext);
            };
            CBCCipher.prototype.decrypt = function(ciphertext) {
              var blockLength = this.blockLength, decryptCipher = crypto.createDecipheriv(this.algorithm, this.key, ciphertext.slice(0, blockLength)), plaintext = toBuffer(decryptCipher.update(ciphertext.slice(blockLength))), final = decryptCipher.final();
              if (final && final.length)
                plaintext = Buffer.concat([plaintext, toBuffer(final)]);
              return plaintext;
            };
            CBCCipher.prototype.getIv = function() {
              if (this.iv) {
                var iv = this.iv;
                this.iv = null;
                return iv;
              }
              var randomBlock = generateRandom(DEFAULT_BLOCKLENGTH);
              return toBuffer(this.encryptCipher.update(randomBlock));
            };
            return Crypto;
          }();
          var util_crypto = crypto_Crypto;
          var message_Message = function() {
            function Message() {
              this.name = void 0;
              this.id = void 0;
              this.timestamp = void 0;
              this.clientId = void 0;
              this.connectionId = void 0;
              this.connectionKey = void 0;
              this.data = void 0;
              this.encoding = void 0;
              this.extras = void 0;
              this.size = void 0;
            }
            Message.prototype.toJSON = function() {
              var result = {
                name: this.name,
                id: this.id,
                clientId: this.clientId,
                connectionId: this.connectionId,
                connectionKey: this.connectionKey,
                encoding: this.encoding,
                extras: this.extras
              };
              var data = this.data;
              if (data && bufferutils.isBuffer(data)) {
                if (arguments.length > 0) {
                  var encoding = this.encoding;
                  result.encoding = encoding ? encoding + "/base64" : "base64";
                  data = bufferutils.base64Encode(data);
                } else {
                  data = bufferutils.toBuffer(data);
                }
              }
              result.data = data;
              return result;
            };
            Message.prototype.toString = function() {
              var result = "[Message";
              if (this.name)
                result += "; name=" + this.name;
              if (this.id)
                result += "; id=" + this.id;
              if (this.timestamp)
                result += "; timestamp=" + this.timestamp;
              if (this.clientId)
                result += "; clientId=" + this.clientId;
              if (this.connectionId)
                result += "; connectionId=" + this.connectionId;
              if (this.encoding)
                result += "; encoding=" + this.encoding;
              if (this.extras)
                result += "; extras =" + JSON.stringify(this.extras);
              if (this.data) {
                if (typeof this.data == "string")
                  result += "; data=" + this.data;
                else if (bufferutils.isBuffer(this.data))
                  result += "; data (buffer)=" + bufferutils.base64Encode(this.data);
                else
                  result += "; data (json)=" + JSON.stringify(this.data);
              }
              if (this.extras)
                result += "; extras=" + JSON.stringify(this.extras);
              result += "]";
              return result;
            };
            Message.encrypt = function(msg, options, callback) {
              var data = msg.data, encoding = msg.encoding, cipher = options.channelCipher;
              encoding = encoding ? encoding + "/" : "";
              if (!bufferutils.isBuffer(data)) {
                data = bufferutils.utf8Encode(String(data));
                encoding = encoding + "utf-8/";
              }
              cipher.encrypt(data, function(err, data2) {
                if (err) {
                  callback(err);
                  return;
                }
                msg.data = data2;
                msg.encoding = encoding + "cipher+" + cipher.algorithm;
                callback(null, msg);
              });
            };
            Message.encode = function(msg, options, callback) {
              var data = msg.data, encoding, nativeDataType = typeof data == "string" || bufferutils.isBuffer(data) || data === null || data === void 0;
              if (!nativeDataType) {
                if (utils.isObject(data) || utils.isArray(data)) {
                  msg.data = JSON.stringify(data);
                  msg.encoding = (encoding = msg.encoding) ? encoding + "/json" : "json";
                } else {
                  throw new errorinfo("Data type is unsupported", 40013, 400);
                }
              }
              if (options != null && options.cipher) {
                Message.encrypt(msg, options, callback);
              } else {
                callback(null, msg);
              }
            };
            Message.encodeArray = function(messages, options, callback) {
              var processed = 0;
              for (var i = 0; i < messages.length; i++) {
                Message.encode(messages[i], options, function(err, msg) {
                  if (err) {
                    callback(err);
                    return;
                  }
                  processed++;
                  if (processed == messages.length) {
                    callback(null, messages);
                  }
                });
              }
            };
            Message.serialize = utils.encodeBody;
            Message.decode = function(message, context) {
              if (!context || !context.channelOptions) {
                var channelOptions = context;
                context = {
                  channelOptions,
                  plugins: {},
                  baseEncodedPreviousPayload: void 0
                };
              }
              var lastPayload = message.data;
              var encoding = message.encoding;
              if (encoding) {
                var xforms = encoding.split("/"), lastProcessedEncodingIndex, encodingsToProcess = xforms.length, data = message.data;
                try {
                  while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {
                    var match = xforms[--encodingsToProcess].match(/([\-\w]+)(\+([\w\-]+))?/);
                    if (!match)
                      break;
                    var xform = match[1];
                    switch (xform) {
                      case "base64":
                        data = bufferutils.base64Decode(String(data));
                        if (lastProcessedEncodingIndex == xforms.length) {
                          lastPayload = data;
                        }
                        continue;
                      case "utf-8":
                        data = bufferutils.utf8Decode(data);
                        continue;
                      case "json":
                        data = JSON.parse(data);
                        continue;
                      case "cipher":
                        if (context.channelOptions != null && context.channelOptions.cipher) {
                          var xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;
                          if (xformAlgorithm != cipher.algorithm) {
                            throw new Error("Unable to decrypt message with given cipher; incompatible cipher params");
                          }
                          data = cipher.decrypt(data);
                          continue;
                        } else {
                          throw new Error("Unable to decrypt message; not an encrypted channel");
                        }
                      case "vcdiff":
                        if (!context.plugins || !context.plugins.vcdiff) {
                          throw new errorinfo("Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)", 40019, 400);
                        }
                        if (typeof Uint8Array === "undefined") {
                          throw new errorinfo("Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)", 40020, 400);
                        }
                        try {
                          var deltaBase = context.baseEncodedPreviousPayload;
                          if (typeof deltaBase === "string") {
                            deltaBase = bufferutils.utf8Encode(deltaBase);
                          }
                          deltaBase = bufferutils.toBuffer(deltaBase);
                          data = bufferutils.toBuffer(data);
                          data = bufferutils.typedArrayToBuffer(context.plugins.vcdiff.decode(data, deltaBase));
                          lastPayload = data;
                        } catch (e) {
                          throw new errorinfo("Vcdiff delta decode failed with " + e, 40018, 400);
                        }
                        continue;
                      default:
                        throw new Error("Unknown encoding");
                    }
                    break;
                  }
                } catch (e) {
                  throw new errorinfo("Error processing the " + xform + " encoding, decoder returned \u2018" + e.message + "\u2019", e.code || 40013, 400);
                } finally {
                  message.encoding = lastProcessedEncodingIndex <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join("/");
                  message.data = data;
                }
              }
              context.baseEncodedPreviousPayload = lastPayload;
            };
            Message.fromResponseBody = function(body, options, format) {
              if (format) {
                body = utils.decodeBody(body, format);
              }
              for (var i = 0; i < body.length; i++) {
                var msg = body[i] = Message.fromValues(body[i]);
                try {
                  Message.decode(msg, options);
                } catch (e) {
                  util_logger.logAction(util_logger.LOG_ERROR, "Message.fromResponseBody()", e.toString());
                }
              }
              return body;
            };
            Message.fromValues = function(values) {
              return utils.mixin(new Message(), values);
            };
            Message.fromValuesArray = function(values) {
              var count = values.length, result = new Array(count);
              for (var i = 0; i < count; i++)
                result[i] = Message.fromValues(values[i]);
              return result;
            };
            function normalizeCipherOptions(options) {
              if (options && options.cipher && !options.cipher.channelCipher) {
                if (!util_crypto)
                  throw new Error("Encryption not enabled; use ably.encryption.js instead");
                var cipher = util_crypto.getCipher(options.cipher);
                options.cipher = cipher.cipherParams;
                options.channelCipher = cipher.cipher;
              }
            }
            Message.fromEncoded = function(encoded, options) {
              var msg = Message.fromValues(encoded);
              normalizeCipherOptions(options);
              try {
                Message.decode(msg, options);
              } catch (e) {
                util_logger.logAction(util_logger.LOG_ERROR, "Message.fromEncoded()", e.toString());
              }
              return msg;
            };
            Message.fromEncodedArray = function(encodedArray, options) {
              normalizeCipherOptions(options);
              return utils.arrMap(encodedArray, function(encoded) {
                return Message.fromEncoded(encoded, options);
              });
            };
            function getMessageSize(msg) {
              var size = 0;
              if (msg.name) {
                size += msg.name.length;
              }
              if (msg.clientId) {
                size += msg.clientId.length;
              }
              if (msg.extras) {
                size += JSON.stringify(msg.extras).length;
              }
              if (msg.data) {
                size += utils.dataSizeBytes(msg.data);
              }
              return size;
            }
            ;
            Message.getMessagesSize = function(messages) {
              var msg, total = 0;
              for (var i = 0; i < messages.length; i++) {
                msg = messages[i];
                total += msg.size || (msg.size = getMessageSize(msg));
              }
              return total;
            };
            return Message;
          }();
          var types_message = message_Message;
          var presencemessage_PresenceMessage = function() {
            var msgpack = platform.msgpack;
            function toActionValue(actionString) {
              return utils.arrIndexOf(PresenceMessage.Actions, actionString);
            }
            function PresenceMessage() {
              this.action = void 0;
              this.id = void 0;
              this.timestamp = void 0;
              this.clientId = void 0;
              this.connectionId = void 0;
              this.data = void 0;
              this.encoding = void 0;
              this.size = void 0;
            }
            PresenceMessage.Actions = [
              "absent",
              "present",
              "enter",
              "leave",
              "update"
            ];
            PresenceMessage.prototype.isSynthesized = function() {
              return this.id.substring(this.connectionId.length, 0) !== this.connectionId;
            };
            PresenceMessage.prototype.parseId = function() {
              var parts = this.id.split(":");
              return {
                connectionId: parts[0],
                msgSerial: parseInt(parts[1], 10),
                index: parseInt(parts[2], 10)
              };
            };
            PresenceMessage.prototype.toJSON = function() {
              var result = {
                clientId: this.clientId,
                action: toActionValue(this.action),
                encoding: this.encoding
              };
              var data = this.data;
              if (data && bufferutils.isBuffer(data)) {
                if (arguments.length > 0) {
                  var encoding = this.encoding;
                  result.encoding = encoding ? encoding + "/base64" : "base64";
                  data = bufferutils.base64Encode(data);
                } else {
                  data = bufferutils.toBuffer(data);
                }
              }
              result.data = data;
              return result;
            };
            PresenceMessage.prototype.toString = function() {
              var result = "[PresenceMessage";
              result += "; action=" + this.action;
              if (this.id)
                result += "; id=" + this.id;
              if (this.timestamp)
                result += "; timestamp=" + this.timestamp;
              if (this.clientId)
                result += "; clientId=" + this.clientId;
              if (this.connectionId)
                result += "; connectionId=" + this.connectionId;
              if (this.encoding)
                result += "; encoding=" + this.encoding;
              if (this.data) {
                if (typeof this.data == "string")
                  result += "; data=" + this.data;
                else if (bufferutils.isBuffer(this.data))
                  result += "; data (buffer)=" + bufferutils.base64Encode(this.data);
                else
                  result += "; data (json)=" + JSON.stringify(this.data);
              }
              result += "]";
              return result;
            };
            PresenceMessage.encode = types_message.encode;
            PresenceMessage.decode = types_message.decode;
            PresenceMessage.fromResponseBody = function(body, options, format) {
              if (format) {
                body = utils.decodeBody(body, format);
              }
              for (var i = 0; i < body.length; i++) {
                var msg = body[i] = PresenceMessage.fromValues(body[i], true);
                try {
                  PresenceMessage.decode(msg, options);
                } catch (e) {
                  util_logger.logAction(util_logger.LOG_ERROR, "PresenceMessage.fromResponseBody()", e.toString());
                }
              }
              return body;
            };
            PresenceMessage.fromValues = function(values, stringifyAction) {
              if (stringifyAction) {
                values.action = PresenceMessage.Actions[values.action];
              }
              return utils.mixin(new PresenceMessage(), values);
            };
            PresenceMessage.fromValuesArray = function(values) {
              var count = values.length, result = new Array(count);
              for (var i = 0; i < count; i++)
                result[i] = PresenceMessage.fromValues(values[i]);
              return result;
            };
            PresenceMessage.fromEncoded = function(encoded, options) {
              var msg = PresenceMessage.fromValues(encoded, true);
              try {
                PresenceMessage.decode(msg, options);
              } catch (e) {
                util_logger.logAction(util_logger.LOG_ERROR, "PresenceMessage.fromEncoded()", e.toString());
              }
              return msg;
            };
            PresenceMessage.fromEncodedArray = function(encodedArray, options) {
              return utils.arrMap(encodedArray, function(encoded) {
                return PresenceMessage.fromEncoded(encoded, options);
              });
            };
            PresenceMessage.getMessagesSize = types_message.getMessagesSize;
            return PresenceMessage;
          }();
          var presencemessage = presencemessage_PresenceMessage;
          var presence_Presence = function() {
            function noop() {
            }
            function Presence(channel) {
              this.channel = channel;
              this.basePath = channel.basePath + "/presence";
            }
            utils.inherits(Presence, eventemitter);
            Presence.prototype.get = function(params, callback) {
              util_logger.logAction(util_logger.LOG_MICRO, "Presence.get()", "channel = " + this.channel.name);
              if (callback === void 0) {
                if (typeof params == "function") {
                  callback = params;
                  params = null;
                } else {
                  if (this.channel.rest.options.promises) {
                    return utils.promisify(this, "get", arguments);
                  }
                  callback = noop;
                }
              }
              var rest = this.channel.rest, format = rest.options.useBinaryProtocol ? "msgpack" : "json", envelope = util_http.supportsLinkHeaders ? void 0 : format, headers = utils.defaultGetHeaders(format);
              if (rest.options.headers)
                utils.mixin(headers, rest.options.headers);
              var options = this.channel.channelOptions;
              new paginatedresource(rest, this.basePath, headers, envelope, function(body, headers2, unpacked) {
                return presencemessage.fromResponseBody(body, options, !unpacked && format);
              }).get(params, callback);
            };
            Presence.prototype.history = function(params, callback) {
              util_logger.logAction(util_logger.LOG_MICRO, "Presence.history()", "channel = " + this.channel.name);
              this._history(params, callback);
            };
            Presence.prototype._history = function(params, callback) {
              if (callback === void 0) {
                if (typeof params == "function") {
                  callback = params;
                  params = null;
                } else {
                  if (this.channel.rest.options.promises) {
                    return utils.promisify(this, "_history", arguments);
                  }
                  callback = noop;
                }
              }
              var rest = this.channel.rest, format = rest.options.useBinaryProtocol ? "msgpack" : "json", envelope = util_http.supportsLinkHeaders ? void 0 : format, headers = utils.defaultGetHeaders(format), channel = this.channel;
              if (rest.options.headers)
                utils.mixin(headers, rest.options.headers);
              var options = this.channel.channelOptions;
              new paginatedresource(rest, this.basePath + "/history", headers, envelope, function(body, headers2, unpacked) {
                return presencemessage.fromResponseBody(body, options, !unpacked && format);
              }).get(params, callback);
            };
            return Presence;
          }();
          var client_presence = presence_Presence;
          var channel_Channel = function() {
            function noop() {
            }
            var MSG_ID_ENTROPY_BYTES = 9;
            function Channel(rest, name, channelOptions) {
              util_logger.logAction(util_logger.LOG_MINOR, "Channel()", "started; name = " + name);
              eventemitter.call(this);
              this.rest = rest;
              this.name = name;
              this.basePath = "/channels/" + encodeURIComponent(name);
              this.presence = new client_presence(this);
              this.setOptions(channelOptions);
            }
            utils.inherits(Channel, eventemitter);
            Channel.prototype.setOptions = function(options) {
              this.channelOptions = options = options || {};
              if (options.cipher) {
                if (!util_crypto)
                  throw new Error("Encryption not enabled; use ably.encryption.js instead");
                var cipher = util_crypto.getCipher(options.cipher);
                options.cipher = cipher.cipherParams;
                options.channelCipher = cipher.cipher;
              } else if ("cipher" in options) {
                options.cipher = null;
                options.channelCipher = null;
              }
            };
            Channel.prototype.history = function(params, callback) {
              util_logger.logAction(util_logger.LOG_MICRO, "Channel.history()", "channel = " + this.name);
              if (callback === void 0) {
                if (typeof params == "function") {
                  callback = params;
                  params = null;
                } else {
                  if (this.rest.options.promises) {
                    return utils.promisify(this, "history", arguments);
                  }
                  callback = noop;
                }
              }
              this._history(params, callback);
            };
            Channel.prototype._history = function(params, callback) {
              var rest = this.rest, format = rest.options.useBinaryProtocol ? "msgpack" : "json", envelope = util_http.supportsLinkHeaders ? void 0 : format, headers = utils.defaultGetHeaders(format), channel = this;
              if (rest.options.headers)
                utils.mixin(headers, rest.options.headers);
              var options = this.channelOptions;
              new paginatedresource(rest, this.basePath + "/messages", headers, envelope, function(body, headers2, unpacked) {
                return types_message.fromResponseBody(body, options, !unpacked && format);
              }).get(params, callback);
            };
            function allEmptyIds(messages) {
              return utils.arrEvery(messages, function(message) {
                return !message.id;
              });
            }
            Channel.prototype.publish = function() {
              var argCount = arguments.length, first = arguments[0], second = arguments[1], callback = arguments[argCount - 1], messages, params, self2 = this;
              if (typeof callback !== "function") {
                if (this.rest.options.promises) {
                  return utils.promisify(this, "publish", arguments);
                }
                callback = noop;
              }
              if (typeof first === "string" || first === null) {
                messages = [types_message.fromValues({ name: first, data: second })];
                params = arguments[2];
              } else if (utils.isObject(first)) {
                messages = [types_message.fromValues(first)];
                params = arguments[1];
              } else if (utils.isArray(first)) {
                messages = types_message.fromValuesArray(first);
                params = arguments[1];
              } else {
                throw new errorinfo("The single-argument form of publish() expects a message object or an array of message objects", 40013, 400);
              }
              if (typeof params !== "object" || !params) {
                params = {};
              }
              var rest = this.rest, options = rest.options, format = options.useBinaryProtocol ? "msgpack" : "json", idempotentRestPublishing = rest.options.idempotentRestPublishing, headers = utils.defaultPostHeaders(format);
              if (options.headers)
                utils.mixin(headers, options.headers);
              if (idempotentRestPublishing && allEmptyIds(messages)) {
                var msgIdBase = utils.randomString(MSG_ID_ENTROPY_BYTES);
                utils.arrForEach(messages, function(message, index) {
                  message.id = msgIdBase + ":" + index.toString();
                });
              }
              types_message.encodeArray(messages, this.channelOptions, function(err) {
                if (err) {
                  callback(err);
                  return;
                }
                var size = types_message.getMessagesSize(messages), maxMessageSize = options.maxMessageSize;
                if (size > maxMessageSize) {
                  callback(new errorinfo("Maximum size of messages that can be published at once exceeded ( was " + size + " bytes; limit is " + maxMessageSize + " bytes)", 40009, 400));
                  return;
                }
                self2._publish(types_message.serialize(messages, format), headers, params, callback);
              });
            };
            Channel.prototype._publish = function(requestBody, headers, params, callback) {
              client_resource.post(this.rest, this.basePath + "/messages", requestBody, headers, params, false, callback);
            };
            return Channel;
          }();
          var client_channel = channel_Channel;
          var stats_Stats = function() {
            function MessageCount(values) {
              this.count = values && values.count || 0;
              this.data = values && values.data || 0;
              this.uncompressedData = values && values.uncompressedData || 0;
              this.failed = values && values.failed || 0;
              this.refused = values && values.refused || 0;
            }
            function MessageCategory(values) {
              var self2 = this;
              MessageCount.call(this, values);
              this.category = void 0;
              if (values && values.category) {
                this.category = {};
                utils.forInOwnNonNullProps(values.category, function(prop) {
                  self2.category[prop] = new MessageCount(values.category[prop]);
                });
              }
            }
            function ResourceCount(values) {
              this.peak = values && values.peak || 0;
              this.min = values && values.min || 0;
              this.mean = values && values.mean || 0;
              this.opened = values && values.opened || 0;
              this.refused = values && values.refused || 0;
            }
            function RequestCount(values) {
              this.succeeded = values && values.succeeded || 0;
              this.failed = values && values.failed || 0;
              this.refused = values && values.refused || 0;
            }
            function ConnectionTypes(values) {
              this.plain = new ResourceCount(values && values.plain);
              this.tls = new ResourceCount(values && values.tls);
              this.all = new ResourceCount(values && values.all);
            }
            function MessageTypes(values) {
              this.messages = new MessageCategory(values && values.messages);
              this.presence = new MessageCategory(values && values.presence);
              this.all = new MessageCategory(values && values.all);
            }
            function MessageTraffic(values) {
              this.realtime = new MessageTypes(values && values.realtime);
              this.rest = new MessageTypes(values && values.rest);
              this.webhook = new MessageTypes(values && values.webhook);
              this.sharedQueue = new MessageTypes(values && values.sharedQueue);
              this.externalQueue = new MessageTypes(values && values.externalQueue);
              this.httpEvent = new MessageTypes(values && values.httpEvent);
              this.push = new MessageTypes(values && values.push);
              this.all = new MessageTypes(values && values.all);
            }
            function MessageDirections(values) {
              this.all = new MessageTypes(values && values.all);
              this.inbound = new MessageTraffic(values && values.inbound);
              this.outbound = new MessageTraffic(values && values.outbound);
            }
            function XchgMessages(values) {
              this.all = new MessageTypes(values && values.all);
              this.producerPaid = new MessageDirections(values && values.producerPaid);
              this.consumerPaid = new MessageDirections(values && values.consumerPaid);
            }
            function PushStats(values) {
              this.messages = values && values.messages || 0;
              var notifications = values && values.notifications;
              this.notifications = {
                invalid: notifications && notifications.invalid || 0,
                attempted: notifications && notifications.attempted || 0,
                successful: notifications && notifications.successful || 0,
                failed: notifications && notifications.failed || 0
              };
              this.directPublishes = values && values.directPublishes || 0;
            }
            function ProcessedCount(values) {
              this.succeeded = values && values.succeeded || 0;
              this.skipped = values && values.skipped || 0;
              this.failed = values && values.failed || 0;
            }
            function ProcessedMessages(values) {
              var self2 = this;
              this.delta = void 0;
              if (values && values.delta) {
                this.delta = {};
                utils.forInOwnNonNullProps(values.delta, function(prop) {
                  self2.delta[prop] = new ProcessedCount(values.delta[prop]);
                });
              }
            }
            function Stats(values) {
              MessageDirections.call(this, values);
              this.persisted = new MessageTypes(values && values.persisted);
              this.connections = new ConnectionTypes(values && values.connections);
              this.channels = new ResourceCount(values && values.channels);
              this.apiRequests = new RequestCount(values && values.apiRequests);
              this.tokenRequests = new RequestCount(values && values.tokenRequests);
              this.xchgProducer = new XchgMessages(values && values.xchgProducer);
              this.xchgConsumer = new XchgMessages(values && values.xchgConsumer);
              this.push = new PushStats(values && values.pushStats);
              this.processed = new ProcessedMessages(values && values.processed);
              this.inProgress = values && values.inProgress || void 0;
              this.unit = values && values.unit || void 0;
              this.intervalId = values && values.intervalId || void 0;
            }
            Stats.fromValues = function(values) {
              return new Stats(values);
            };
            return Stats;
          }();
          var stats = stats_Stats;
          var rest_Rest = function() {
            var noop = function() {
            };
            var msgpack = platform.msgpack;
            function Rest(options) {
              if (!(this instanceof Rest)) {
                return new Rest(options);
              }
              if (!options) {
                var msg = "no options provided";
                util_logger.logAction(util_logger.LOG_ERROR, "Rest()", msg);
                throw new Error(msg);
              }
              options = util_defaults.objectifyOptions(options);
              if (options.log) {
                util_logger.setLog(options.log.level, options.log.handler);
              }
              util_logger.logAction(util_logger.LOG_MICRO, "Rest()", "initialized with clientOptions " + utils.inspect(options));
              this.options = util_defaults.normaliseOptions(options);
              if (options.key) {
                var keyMatch = options.key.match(/^([^:\s]+):([^:.\s]+)$/);
                if (!keyMatch) {
                  var msg = "invalid key parameter";
                  util_logger.logAction(util_logger.LOG_ERROR, "Rest()", msg);
                  throw new Error(msg);
                }
                options.keyName = keyMatch[1];
                options.keySecret = keyMatch[2];
              }
              if ("clientId" in options) {
                if (!(typeof options.clientId === "string" || options.clientId === null))
                  throw new errorinfo("clientId must be either a string or null", 40012, 400);
                else if (options.clientId === "*")
                  throw new errorinfo('Can\u2019t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: "*"}})', 40012, 400);
              }
              util_logger.logAction(util_logger.LOG_MINOR, "Rest()", "started; version = " + util_defaults.libstring);
              this.baseUri = this.authority = function(host) {
                return util_defaults.getHttpScheme(options) + host + ":" + util_defaults.getPort(options, false);
              };
              this._currentFallback = null;
              this.serverTimeOffset = null;
              this.auth = new client_auth(this, options);
              this.channels = new Channels(this);
              this.push = new push(this);
            }
            Rest.prototype.stats = function(params, callback) {
              if (callback === void 0) {
                if (typeof params == "function") {
                  callback = params;
                  params = null;
                } else {
                  if (this.options.promises) {
                    return utils.promisify(this, "stats", arguments);
                  }
                  callback = noop;
                }
              }
              var headers = utils.defaultGetHeaders(), format = this.options.useBinaryProtocol ? "msgpack" : "json", envelope = util_http.supportsLinkHeaders ? void 0 : format;
              if (this.options.headers)
                utils.mixin(headers, this.options.headers);
              new paginatedresource(this, "/stats", headers, envelope, function(body, headers2, unpacked) {
                var statsValues = unpacked ? body : JSON.parse(body);
                for (var i = 0; i < statsValues.length; i++)
                  statsValues[i] = stats.fromValues(statsValues[i]);
                return statsValues;
              }).get(params, callback);
            };
            Rest.prototype.time = function(params, callback) {
              if (callback === void 0) {
                if (typeof params == "function") {
                  callback = params;
                  params = null;
                } else {
                  if (this.options.promises) {
                    return utils.promisify(this, "time", arguments);
                  }
                  callback = noop;
                }
              }
              var headers = utils.defaultGetHeaders();
              if (this.options.headers)
                utils.mixin(headers, this.options.headers);
              var self2 = this;
              var timeUri = function(host) {
                return self2.authority(host) + "/time";
              };
              util_http.get(this, timeUri, headers, params, function(err, res, headers2, unpacked) {
                if (err) {
                  callback(err);
                  return;
                }
                if (!unpacked)
                  res = JSON.parse(res);
                var time = res[0];
                if (!time) {
                  err = new Error("Internal error (unexpected result type from GET /time)");
                  err.statusCode = 500;
                  callback(err);
                  return;
                }
                self2.serverTimeOffset = time - utils.now();
                callback(null, time);
              });
            };
            Rest.prototype.request = function(method, path, params, body, customHeaders, callback) {
              var useBinary = this.options.useBinaryProtocol, encoder = useBinary ? msgpack.encode : JSON.stringify, decoder = useBinary ? msgpack.decode : JSON.parse, format = useBinary ? "msgpack" : "json", envelope = util_http.supportsLinkHeaders ? void 0 : format;
              params = params || {};
              method = method.toLowerCase();
              var headers = method == "get" ? utils.defaultGetHeaders(format) : utils.defaultPostHeaders(format);
              if (callback === void 0) {
                if (this.options.promises) {
                  return utils.promisify(this, "request", [method, path, params, body, customHeaders]);
                }
                callback = noop;
              }
              if (typeof body !== "string") {
                body = encoder(body);
              }
              if (this.options.headers) {
                utils.mixin(headers, this.options.headers);
              }
              if (customHeaders) {
                utils.mixin(headers, customHeaders);
              }
              var paginatedResource = new paginatedresource(this, path, headers, envelope, function(resbody, headers2, unpacked) {
                return utils.ensureArray(unpacked ? resbody : decoder(resbody));
              }, true);
              if (!utils.arrIn(util_http.methods, method)) {
                throw new errorinfo("Unsupported method " + method, 40500, 405);
              }
              if (utils.arrIn(util_http.methodsWithBody, method)) {
                paginatedResource[method](params, body, callback);
              } else {
                paginatedResource[method](params, callback);
              }
            };
            Rest.prototype.setLog = function(logOptions) {
              util_logger.setLog(logOptions.level, logOptions.handler);
            };
            function Channels(rest) {
              this.rest = rest;
              this.all = Object.create(null);
            }
            Channels.prototype.get = function(name, channelOptions) {
              name = String(name);
              var channel = this.all[name];
              if (!channel) {
                this.all[name] = channel = new client_channel(this.rest, name, channelOptions);
              } else if (channelOptions) {
                channel.setOptions(channelOptions);
              }
              return channel;
            };
            Channels.prototype.release = function(name) {
              delete this.all[String(name)];
            };
            return Rest;
          }();
          rest_Rest.Promise = function(options) {
            options = util_defaults.objectifyOptions(options);
            options.promises = true;
            return new rest_Rest(options);
          };
          rest_Rest.Callbacks = rest_Rest;
          var client_rest = rest_Rest;
          var protocolmessage_ProtocolMessage = function() {
            function ProtocolMessage() {
              this.action = void 0;
              this.flags = void 0;
              this.id = void 0;
              this.timestamp = void 0;
              this.count = void 0;
              this.error = void 0;
              this.connectionId = void 0;
              this.connectionKey = void 0;
              this.connectionSerial = void 0;
              this.channel = void 0;
              this.channelSerial = void 0;
              this.msgSerial = void 0;
              this.messages = void 0;
              this.presence = void 0;
              this.auth = void 0;
              this.params = void 0;
            }
            var actions = ProtocolMessage.Action = {
              "HEARTBEAT": 0,
              "ACK": 1,
              "NACK": 2,
              "CONNECT": 3,
              "CONNECTED": 4,
              "DISCONNECT": 5,
              "DISCONNECTED": 6,
              "CLOSE": 7,
              "CLOSED": 8,
              "ERROR": 9,
              "ATTACH": 10,
              "ATTACHED": 11,
              "DETACH": 12,
              "DETACHED": 13,
              "PRESENCE": 14,
              "MESSAGE": 15,
              "SYNC": 16,
              "AUTH": 17
            };
            ProtocolMessage.channelModes = ["PRESENCE", "PUBLISH", "SUBSCRIBE", "PRESENCE_SUBSCRIBE"];
            ProtocolMessage.ActionName = [];
            utils.arrForEach(utils.keysArray(ProtocolMessage.Action, true), function(name) {
              ProtocolMessage.ActionName[actions[name]] = name;
            });
            var flags = {
              "HAS_PRESENCE": 1 << 0,
              "HAS_BACKLOG": 1 << 1,
              "RESUMED": 1 << 2,
              "TRANSIENT": 1 << 4,
              "ATTACH_RESUME": 1 << 5,
              "PRESENCE": 1 << 16,
              "PUBLISH": 1 << 17,
              "SUBSCRIBE": 1 << 18,
              "PRESENCE_SUBSCRIBE": 1 << 19
            };
            var flagNames = utils.keysArray(flags);
            flags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;
            ProtocolMessage.prototype.hasFlag = function(flag) {
              return (this.flags & flags[flag]) > 0;
            };
            ProtocolMessage.prototype.setFlag = function(flag) {
              return this.flags = this.flags | flags[flag];
            };
            ProtocolMessage.prototype.getMode = function() {
              return this.flags && this.flags & flags.MODE_ALL;
            };
            ProtocolMessage.prototype.encodeModesToFlags = function(modes) {
              var self2 = this;
              utils.arrForEach(modes, function(mode) {
                self2.setFlag(mode);
              });
            };
            ProtocolMessage.prototype.decodeModesFromFlags = function() {
              var modes = [], self2 = this;
              utils.arrForEach(ProtocolMessage.channelModes, function(mode) {
                if (self2.hasFlag(mode)) {
                  modes.push(mode);
                }
              });
              return modes.length > 0 ? modes : void 0;
            };
            ProtocolMessage.serialize = utils.encodeBody;
            ProtocolMessage.deserialize = function(serialized, format) {
              var deserialized = utils.decodeBody(serialized, format);
              return ProtocolMessage.fromDeserialized(deserialized);
            };
            ProtocolMessage.fromDeserialized = function(deserialized) {
              var error = deserialized.error;
              if (error)
                deserialized.error = errorinfo.fromValues(error);
              var messages = deserialized.messages;
              if (messages)
                for (var i = 0; i < messages.length; i++)
                  messages[i] = types_message.fromValues(messages[i]);
              var presence = deserialized.presence;
              if (presence)
                for (var i = 0; i < presence.length; i++)
                  presence[i] = presencemessage.fromValues(presence[i], true);
              return utils.mixin(new ProtocolMessage(), deserialized);
            };
            ProtocolMessage.fromValues = function(values) {
              return utils.mixin(new ProtocolMessage(), values);
            };
            function toStringArray(array) {
              var result = [];
              if (array) {
                for (var i = 0; i < array.length; i++) {
                  result.push(array[i].toString());
                }
              }
              return "[ " + result.join(", ") + " ]";
            }
            var simpleAttributes = "id channel channelSerial connectionId connectionKey connectionSerial count msgSerial timestamp".split(" ");
            ProtocolMessage.stringify = function(msg) {
              var result = "[ProtocolMessage";
              if (msg.action !== void 0)
                result += "; action=" + ProtocolMessage.ActionName[msg.action] || false;
              var attribute;
              for (var attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {
                attribute = simpleAttributes[attribIndex];
                if (msg[attribute] !== void 0)
                  result += "; " + attribute + "=" + msg[attribute];
              }
              if (msg.messages)
                result += "; messages=" + toStringArray(types_message.fromValuesArray(msg.messages));
              if (msg.presence)
                result += "; presence=" + toStringArray(presencemessage.fromValuesArray(msg.presence));
              if (msg.error)
                result += "; error=" + errorinfo.fromValues(msg.error).toString();
              if (msg.auth && msg.auth.accessToken)
                result += "; token=" + msg.auth.accessToken;
              if (msg.flags)
                result += "; flags=" + utils.arrFilter(flagNames, function(flag) {
                  return msg.hasFlag(flag);
                }).join(",");
              if (msg.params) {
                var stringifiedParams = "";
                utils.forInOwnNonNullProps(msg.params, function(prop) {
                  if (stringifiedParams.length > 0) {
                    stringifiedParams += "; ";
                  }
                  stringifiedParams += prop + "=" + msg.params[prop];
                });
                if (stringifiedParams.length > 0) {
                  result += "; params=[" + stringifiedParams + "]";
                }
              }
              result += "]";
              return result;
            };
            ProtocolMessage.isDuplicate = function(a, b) {
              if (a && b) {
                if ((a.action === actions.MESSAGE || a.action === actions.PRESENCE) && a.action === b.action && a.channel === b.channel && a.id === b.id) {
                  if (a.action === actions.PRESENCE) {
                    return true;
                  } else if (a.messages.length === b.messages.length) {
                    for (var i = 0; i < a.messages.length; i++) {
                      var aMessage = a.messages[i];
                      var bMessage = b.messages[i];
                      if ((aMessage.extras && aMessage.extras.delta && aMessage.extras.delta.format) !== (bMessage.extras && bMessage.extras.delta && bMessage.extras.delta.format)) {
                        return false;
                      }
                    }
                    return true;
                  }
                }
              }
              return false;
            };
            return ProtocolMessage;
          }();
          var protocolmessage = protocolmessage_ProtocolMessage;
          var messagequeue_MessageQueue = function() {
            function MessageQueue() {
              eventemitter.call(this);
              this.messages = [];
            }
            utils.inherits(MessageQueue, eventemitter);
            MessageQueue.prototype.count = function() {
              return this.messages.length;
            };
            MessageQueue.prototype.push = function(message) {
              this.messages.push(message);
            };
            MessageQueue.prototype.shift = function() {
              return this.messages.shift();
            };
            MessageQueue.prototype.last = function() {
              return this.messages[this.messages.length - 1];
            };
            MessageQueue.prototype.copyAll = function() {
              return this.messages.slice();
            };
            MessageQueue.prototype.append = function(messages) {
              this.messages.push.apply(this.messages, messages);
            };
            MessageQueue.prototype.prepend = function(messages) {
              this.messages.unshift.apply(this.messages, messages);
            };
            MessageQueue.prototype.completeMessages = function(serial, count, err) {
              util_logger.logAction(util_logger.LOG_MICRO, "MessageQueue.completeMessages()", "serial = " + serial + "; count = " + count);
              err = err || null;
              var messages = this.messages;
              var first = messages[0];
              if (first) {
                var startSerial = first.message.msgSerial;
                var endSerial = serial + count;
                if (endSerial > startSerial) {
                  var completeMessages = messages.splice(0, endSerial - startSerial);
                  for (var i = 0; i < completeMessages.length; i++) {
                    completeMessages[i].callback(err);
                  }
                }
                if (messages.length == 0)
                  this.emit("idle");
              }
            };
            MessageQueue.prototype.completeAllMessages = function(err) {
              this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);
            };
            MessageQueue.prototype.clear = function() {
              util_logger.logAction(util_logger.LOG_MICRO, "MessageQueue.clear()", "clearing " + this.messages.length + " messages");
              this.messages = [];
              this.emit("idle");
            };
            return MessageQueue;
          }();
          var messagequeue = messagequeue_MessageQueue;
          var protocol_Protocol = function() {
            var actions = protocolmessage.Action;
            function Protocol(transport) {
              eventemitter.call(this);
              this.transport = transport;
              this.messageQueue = new messagequeue();
              var self2 = this;
              transport.on("ack", function(serial, count) {
                self2.onAck(serial, count);
              });
              transport.on("nack", function(serial, count, err) {
                self2.onNack(serial, count, err);
              });
            }
            utils.inherits(Protocol, eventemitter);
            Protocol.prototype.onAck = function(serial, count) {
              util_logger.logAction(util_logger.LOG_MICRO, "Protocol.onAck()", "serial = " + serial + "; count = " + count);
              this.messageQueue.completeMessages(serial, count);
            };
            Protocol.prototype.onNack = function(serial, count, err) {
              util_logger.logAction(util_logger.LOG_ERROR, "Protocol.onNack()", "serial = " + serial + "; count = " + count + "; err = " + utils.inspectError(err));
              if (!err) {
                err = new errorinfo("Unable to send message; channel not responding", 50001, 500);
              }
              this.messageQueue.completeMessages(serial, count, err);
            };
            Protocol.prototype.onceIdle = function(listener) {
              var messageQueue = this.messageQueue;
              if (messageQueue.count() === 0) {
                listener();
                return;
              }
              messageQueue.once("idle", listener);
            };
            Protocol.prototype.send = function(pendingMessage) {
              if (pendingMessage.ackRequired) {
                this.messageQueue.push(pendingMessage);
              }
              if (util_logger.shouldLog(util_logger.LOG_MICRO)) {
                util_logger.logAction(util_logger.LOG_MICRO, "Protocol.send()", "sending msg; " + protocolmessage.stringify(pendingMessage.message));
              }
              pendingMessage.sendAttempted = true;
              this.transport.send(pendingMessage.message);
            };
            Protocol.prototype.getTransport = function() {
              return this.transport;
            };
            Protocol.prototype.getPendingMessages = function() {
              return this.messageQueue.copyAll();
            };
            Protocol.prototype.clearPendingMessages = function() {
              return this.messageQueue.clear();
            };
            Protocol.prototype.finish = function() {
              var transport = this.transport;
              this.onceIdle(function() {
                transport.disconnect();
              });
            };
            function PendingMessage(message, callback) {
              this.message = message;
              this.callback = callback;
              this.merged = false;
              var action = message.action;
              this.sendAttempted = false;
              this.ackRequired = action == actions.MESSAGE || action == actions.PRESENCE;
            }
            Protocol.PendingMessage = PendingMessage;
            return Protocol;
          }();
          var protocol = protocol_Protocol;
          var ConnectionStateChange = function() {
            function ConnectionStateChange2(previous, current, retryIn, reason) {
              this.previous = previous;
              this.current = current;
              if (retryIn)
                this.retryIn = retryIn;
              if (reason)
                this.reason = reason;
            }
            return ConnectionStateChange2;
          }();
          var connectionstatechange = ConnectionStateChange;
          var ConnectionError = {
            disconnected: errorinfo.fromValues({
              statusCode: 400,
              code: 80003,
              message: "Connection to server temporarily unavailable"
            }),
            suspended: errorinfo.fromValues({
              statusCode: 400,
              code: 80002,
              message: "Connection to server unavailable"
            }),
            failed: errorinfo.fromValues({
              statusCode: 400,
              code: 8e4,
              message: "Connection failed or disconnected by server"
            }),
            closing: errorinfo.fromValues({
              statusCode: 400,
              code: 80017,
              message: "Connection closing"
            }),
            closed: errorinfo.fromValues({
              statusCode: 400,
              code: 80017,
              message: "Connection closed"
            }),
            unknownConnectionErr: errorinfo.fromValues({
              statusCode: 500,
              code: 50002,
              message: "Internal connection error"
            }),
            unknownChannelErr: errorinfo.fromValues({
              statusCode: 500,
              code: 50001,
              message: "Internal channel error"
            })
          };
          ConnectionError.isRetriable = function(err) {
            if (!err.statusCode || !err.code || err.statusCode >= 500) {
              return true;
            }
            var retriable = false;
            utils.valuesArray(ConnectionError).forEach(function(connErr) {
              if (connErr.code && connErr.code == err.code) {
                retriable = true;
              }
            });
            return retriable;
          };
          var connectionerror = ConnectionError;
          var errorreporter_ErrorReporter = function() {
            function ErrorReporter() {
            }
            var levels = ErrorReporter.levels = [
              "fatal",
              "error",
              "warning",
              "info",
              "debug"
            ];
            ErrorReporter.report = function(level, message, fingerprint, tags) {
              var eventId = utils.randomHexString(16);
              var event = {
                event_id: eventId,
                tags: utils.mixin({
                  ablyAgent: util_defaults.agent
                }, tags),
                platform: "javascript",
                level,
                release: util_defaults.version,
                fingerprint: fingerprint && [fingerprint],
                message,
                request: {
                  headers: {
                    "User-Agent": platform.userAgent
                  },
                  url: platform.currentUrl
                }
              };
              util_logger.logAction(util_logger.LOG_MICRO, "ErrorReporter", "POSTing to error reporter: " + message);
              util_http.postUri(null, util_defaults.errorReportingUrl, util_defaults.errorReportingHeaders, JSON.stringify(event), {}, function(err, res) {
                util_logger.logAction(util_logger.LOG_MICRO, "ErrorReporter", "POSTing to error reporter resulted in: " + (err ? utils.inspectError(err) : utils.inspectBody(res)));
              });
            };
            return ErrorReporter;
          }();
          var errorreporter = errorreporter_ErrorReporter;
          var webstorage_WebStorage = function() {
            var sessionSupported, localSupported, test = "ablyjs-storage-test";
            try {
              global.sessionStorage.setItem(test, test);
              global.sessionStorage.removeItem(test);
              sessionSupported = true;
            } catch (e) {
              sessionSupported = false;
            }
            try {
              global.localStorage.setItem(test, test);
              global.localStorage.removeItem(test);
              localSupported = true;
            } catch (e) {
              localSupported = false;
            }
            function WebStorage() {
            }
            function storageInterface(session) {
              return session ? global.sessionStorage : global.localStorage;
            }
            function set(name, value, ttl, session) {
              var wrappedValue = { value };
              if (ttl) {
                wrappedValue.expires = utils.now() + ttl;
              }
              return storageInterface(session).setItem(name, JSON.stringify(wrappedValue));
            }
            function get(name, session) {
              var rawItem = storageInterface(session).getItem(name);
              if (!rawItem)
                return null;
              var wrappedValue = JSON.parse(rawItem);
              if (wrappedValue.expires && wrappedValue.expires < utils.now()) {
                storageInterface(session).removeItem(name);
                return null;
              }
              return wrappedValue.value;
            }
            function remove(name, session) {
              return storageInterface(session).removeItem(name);
            }
            if (localSupported) {
              WebStorage.set = function(name, value, ttl) {
                return set(name, value, ttl, false);
              };
              WebStorage.get = function(name) {
                return get(name, false);
              };
              WebStorage.remove = function(name) {
                return remove(name, false);
              };
            }
            if (sessionSupported) {
              WebStorage.setSession = function(name, value, ttl) {
                return set(name, value, ttl, true);
              };
              WebStorage.getSession = function(name) {
                return get(name, true);
              };
              WebStorage.removeSession = function(name) {
                return remove(name, true);
              };
            }
            return WebStorage;
          }();
          var webstorage = webstorage_WebStorage;
          var transport_Transport = function() {
            var actions = protocolmessage.Action;
            var closeMessage = protocolmessage.fromValues({ action: actions.CLOSE });
            var disconnectMessage = protocolmessage.fromValues({ action: actions.DISCONNECT });
            var noop = function() {
            };
            function Transport(connectionManager, auth, params) {
              eventemitter.call(this);
              this.connectionManager = connectionManager;
              connectionManager.registerProposedTransport(this);
              this.auth = auth;
              this.params = params;
              this.timeouts = params.options.timeouts;
              this.format = params.format;
              this.isConnected = false;
              this.isFinished = false;
              this.isDisposed = false;
              this.maxIdleInterval = null;
              this.idleTimer = null;
              this.lastActivity = null;
            }
            utils.inherits(Transport, eventemitter);
            Transport.prototype.connect = function() {
            };
            Transport.prototype.close = function() {
              if (this.isConnected) {
                this.requestClose();
              }
              this.finish("closed", connectionerror.closed);
            };
            Transport.prototype.disconnect = function(err) {
              if (this.isConnected) {
                this.requestDisconnect();
              }
              this.finish("disconnected", err || connectionerror.disconnected);
            };
            Transport.prototype.fail = function(err) {
              if (this.isConnected) {
                this.requestDisconnect();
              }
              this.finish("failed", err || connectionerror.failed);
            };
            Transport.prototype.finish = function(event, err) {
              if (this.isFinished) {
                return;
              }
              this.isFinished = true;
              this.isConnected = false;
              this.maxIdleInterval = null;
              clearTimeout(this.idleTimer);
              this.idleTimer = null;
              this.emit(event, err);
              this.dispose();
            };
            Transport.prototype.onProtocolMessage = function(message) {
              if (util_logger.shouldLog(util_logger.LOG_MICRO)) {
                util_logger.logAction(util_logger.LOG_MICRO, "Transport.onProtocolMessage()", "received on " + this.shortName + ": " + protocolmessage.stringify(message) + "; connectionId = " + this.connectionManager.connectionId);
              }
              this.onActivity();
              switch (message.action) {
                case actions.HEARTBEAT:
                  util_logger.logAction(util_logger.LOG_MICRO, "Transport.onProtocolMessage()", this.shortName + " heartbeat; connectionId = " + this.connectionManager.connectionId);
                  this.emit("heartbeat", message.id);
                  break;
                case actions.CONNECTED:
                  this.onConnect(message);
                  this.emit("connected", message.error, message.connectionId, message.connectionDetails, message);
                  break;
                case actions.CLOSED:
                  this.onClose(message);
                  break;
                case actions.DISCONNECTED:
                  this.onDisconnect(message);
                  break;
                case actions.ACK:
                  this.emit("ack", message.msgSerial, message.count);
                  break;
                case actions.NACK:
                  this.emit("nack", message.msgSerial, message.count, message.error);
                  break;
                case actions.SYNC:
                  if (message.connectionId !== void 0) {
                    this.emit("sync", message.connectionId, message);
                    break;
                  }
                  this.connectionManager.onChannelMessage(message, this);
                  break;
                case actions.AUTH:
                  this.auth.authorize(function(err) {
                    if (err) {
                      util_logger.logAction(util_logger.LOG_ERROR, "Transport.onProtocolMessage()", "Ably requested re-authentication, but unable to obtain a new token: " + utils.inspectError(err));
                    }
                  });
                  break;
                case actions.ERROR:
                  util_logger.logAction(util_logger.LOG_MINOR, "Transport.onProtocolMessage()", "received error action; connectionId = " + this.connectionManager.connectionId + "; err = " + utils.inspect(message.error) + (message.channel ? ", channel: " + message.channel : ""));
                  if (message.channel === void 0) {
                    this.onFatalError(message);
                    break;
                  }
                  this.connectionManager.onChannelMessage(message, this);
                  break;
                default:
                  this.connectionManager.onChannelMessage(message, this);
              }
            };
            Transport.prototype.onConnect = function(message) {
              this.isConnected = true;
              var maxPromisedIdle = message.connectionDetails.maxIdleInterval;
              if (maxPromisedIdle) {
                this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;
                this.onActivity();
              }
            };
            Transport.prototype.onDisconnect = function(message) {
              var err = message && message.error;
              util_logger.logAction(util_logger.LOG_MINOR, "Transport.onDisconnect()", "err = " + utils.inspectError(err));
              this.finish("disconnected", err);
            };
            Transport.prototype.onFatalError = function(message) {
              var err = message && message.error;
              util_logger.logAction(util_logger.LOG_MINOR, "Transport.onFatalError()", "err = " + utils.inspectError(err));
              this.finish("failed", err);
            };
            Transport.prototype.onClose = function(message) {
              var err = message && message.error;
              util_logger.logAction(util_logger.LOG_MINOR, "Transport.onClose()", "err = " + utils.inspectError(err));
              this.finish("closed", err);
            };
            Transport.prototype.requestClose = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "Transport.requestClose()", "");
              this.send(closeMessage);
            };
            Transport.prototype.requestDisconnect = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "Transport.requestDisconnect()", "");
              this.send(disconnectMessage);
            };
            Transport.prototype.ping = function(id) {
              var msg = { action: protocolmessage.Action.HEARTBEAT };
              if (id)
                msg.id = id;
              this.send(protocolmessage.fromValues(msg));
            };
            Transport.prototype.dispose = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "Transport.dispose()", "");
              this.isDisposed = true;
              this.off();
            };
            Transport.prototype.onActivity = function() {
              if (!this.maxIdleInterval) {
                return;
              }
              this.lastActivity = this.connectionManager.lastActivity = utils.now();
              this.setIdleTimer(this.maxIdleInterval + 100);
            };
            Transport.prototype.setIdleTimer = function(timeout) {
              var self2 = this;
              if (!this.idleTimer) {
                this.idleTimer = setTimeout(function() {
                  self2.onIdleTimerExpire();
                }, timeout);
              }
            };
            Transport.prototype.onIdleTimerExpire = function() {
              this.idleTimer = null;
              var sinceLast = utils.now() - this.lastActivity, timeRemaining = this.maxIdleInterval - sinceLast;
              if (timeRemaining <= 0) {
                var msg = "No activity seen from realtime in " + sinceLast + "ms; assuming connection has dropped";
                util_logger.logAction(util_logger.LOG_ERROR, "Transport.onIdleTimerExpire()", msg);
                this.disconnect(new errorinfo(msg, 80003, 408));
              } else {
                this.setIdleTimer(timeRemaining + 100);
              }
            };
            Transport.prototype.onAuthUpdated = function() {
            };
            return Transport;
          }();
          var transport_transport = transport_Transport;
          var comettransport_CometTransport = function() {
            var REQ_SEND = 0, REQ_RECV = 1, REQ_RECV_POLL = 2, REQ_RECV_STREAM = 3;
            function shouldBeErrorAction(err) {
              var UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];
              if (err.code) {
                if (client_auth.isTokenErr(err))
                  return false;
                if (utils.arrIn(UNRESOLVABLE_ERROR_CODES, err.code))
                  return true;
                return err.code >= 4e4 && err.code < 5e4;
              } else {
                return false;
              }
            }
            function protocolMessageFromRawError(err) {
              if (shouldBeErrorAction(err)) {
                return [protocolmessage.fromValues({ action: protocolmessage.Action.ERROR, error: err })];
              } else {
                return [protocolmessage.fromValues({ action: protocolmessage.Action.DISCONNECTED, error: err })];
              }
            }
            function CometTransport(connectionManager, auth, params) {
              params.format = void 0;
              params.heartbeats = true;
              transport_transport.call(this, connectionManager, auth, params);
              this.stream = "stream" in params ? params.stream : true;
              this.sendRequest = null;
              this.recvRequest = null;
              this.pendingCallback = null;
              this.pendingItems = null;
            }
            utils.inherits(CometTransport, transport_transport);
            CometTransport.REQ_SEND = REQ_SEND;
            CometTransport.REQ_RECV = REQ_RECV;
            CometTransport.REQ_RECV_POLL = REQ_RECV_POLL;
            CometTransport.REQ_RECV_STREAM = REQ_RECV_STREAM;
            CometTransport.prototype.connect = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "CometTransport.connect()", "starting");
              transport_transport.prototype.connect.call(this);
              var self2 = this, params = this.params, options = params.options;
              var host = util_defaults.getHost(options, params.host);
              var port = util_defaults.getPort(options);
              var cometScheme = options.tls ? "https://" : "http://";
              this.baseUri = cometScheme + host + ":" + port + "/comet/";
              var connectUri = this.baseUri + "connect";
              util_logger.logAction(util_logger.LOG_MINOR, "CometTransport.connect()", "uri: " + connectUri);
              this.auth.getAuthParams(function(err, authParams) {
                if (err) {
                  self2.disconnect(err);
                  return;
                }
                if (self2.isDisposed) {
                  return;
                }
                self2.authParams = authParams;
                var connectParams = self2.params.getConnectParams(authParams);
                if ("stream" in connectParams)
                  self2.stream = connectParams.stream;
                util_logger.logAction(util_logger.LOG_MINOR, "CometTransport.connect()", "connectParams:" + utils.toQueryString(connectParams));
                var preconnected = false, connectRequest = self2.recvRequest = self2.createRequest(connectUri, null, connectParams, null, self2.stream ? REQ_RECV_STREAM : REQ_RECV);
                connectRequest.on("data", function(data) {
                  if (!self2.recvRequest) {
                    return;
                  }
                  if (!preconnected) {
                    preconnected = true;
                    self2.emit("preconnect");
                  }
                  self2.onData(data);
                });
                connectRequest.on("complete", function(err2, _body, headers) {
                  if (!self2.recvRequest) {
                    err2 = err2 || new errorinfo("Request cancelled", 80003, 400);
                  }
                  self2.recvRequest = null;
                  if (!preconnected && !err2) {
                    preconnected = true;
                    self2.emit("preconnect");
                  }
                  self2.onActivity();
                  if (err2) {
                    if (err2.code) {
                      self2.onData(protocolMessageFromRawError(err2));
                    } else {
                      self2.disconnect(err2);
                    }
                    return;
                  }
                  utils.nextTick(function() {
                    self2.recv();
                  });
                });
                connectRequest.exec();
              });
            };
            CometTransport.prototype.requestClose = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "CometTransport.requestClose()");
              this._requestCloseOrDisconnect(true);
            };
            CometTransport.prototype.requestDisconnect = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "CometTransport.requestDisconnect()");
              this._requestCloseOrDisconnect(false);
            };
            CometTransport.prototype._requestCloseOrDisconnect = function(closing) {
              var closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;
              if (closeOrDisconnectUri) {
                var self2 = this, request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, REQ_SEND);
                request.on("complete", function(err) {
                  if (err) {
                    util_logger.logAction(util_logger.LOG_ERROR, "CometTransport.request" + (closing ? "Close()" : "Disconnect()"), "request returned err = " + utils.inspectError(err));
                    self2.finish("disconnected", err);
                  }
                });
                request.exec();
              }
            };
            CometTransport.prototype.dispose = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "CometTransport.dispose()", "");
              if (!this.isDisposed) {
                this.isDisposed = true;
                if (this.recvRequest) {
                  util_logger.logAction(util_logger.LOG_MINOR, "CometTransport.dispose()", "aborting recv request");
                  this.recvRequest.abort();
                  this.recvRequest = null;
                }
                this.finish("disconnected", connectionerror.disconnected);
                var self2 = this;
                utils.nextTick(function() {
                  self2.emit("disposed");
                });
              }
            };
            CometTransport.prototype.onConnect = function(message) {
              if (this.isDisposed) {
                return;
              }
              var connectionStr = message.connectionKey;
              transport_transport.prototype.onConnect.call(this, message);
              var baseConnectionUri = this.baseUri + connectionStr;
              util_logger.logAction(util_logger.LOG_MICRO, "CometTransport.onConnect()", "baseUri = " + baseConnectionUri + "; connectionKey = " + message.connectionKey);
              this.sendUri = baseConnectionUri + "/send";
              this.recvUri = baseConnectionUri + "/recv";
              this.closeUri = baseConnectionUri + "/close";
              this.disconnectUri = baseConnectionUri + "/disconnect";
            };
            CometTransport.prototype.send = function(message) {
              if (this.sendRequest) {
                this.pendingItems = this.pendingItems || [];
                this.pendingItems.push(message);
                return;
              }
              var pendingItems = this.pendingItems || [];
              pendingItems.push(message);
              this.pendingItems = null;
              this.sendItems(pendingItems);
            };
            CometTransport.prototype.sendAnyPending = function() {
              var pendingItems = this.pendingItems;
              if (!pendingItems) {
                return;
              }
              this.pendingItems = null;
              this.sendItems(pendingItems);
            };
            CometTransport.prototype.sendItems = function(items) {
              var self2 = this, sendRequest = this.sendRequest = self2.createRequest(self2.sendUri, null, self2.authParams, this.encodeRequest(items), REQ_SEND);
              sendRequest.on("complete", function(err, data) {
                if (err)
                  util_logger.logAction(util_logger.LOG_ERROR, "CometTransport.sendItems()", "on complete: err = " + utils.inspectError(err));
                self2.sendRequest = null;
                if (err) {
                  if (err.code) {
                    self2.onData(protocolMessageFromRawError(err));
                  } else {
                    self2.disconnect(err);
                  }
                  return;
                }
                if (data) {
                  self2.onData(data);
                }
                if (self2.pendingItems) {
                  utils.nextTick(function() {
                    if (!self2.sendRequest) {
                      self2.sendAnyPending();
                    }
                  });
                }
              });
              sendRequest.exec();
            };
            CometTransport.prototype.recv = function() {
              if (this.recvRequest)
                return;
              if (!this.isConnected)
                return;
              var self2 = this, recvRequest = this.recvRequest = this.createRequest(this.recvUri, null, this.authParams, null, self2.stream ? REQ_RECV_STREAM : REQ_RECV_POLL);
              recvRequest.on("data", function(data) {
                self2.onData(data);
              });
              recvRequest.on("complete", function(err) {
                self2.recvRequest = null;
                self2.onActivity();
                if (err) {
                  if (err.code) {
                    self2.onData(protocolMessageFromRawError(err));
                  } else {
                    self2.disconnect(err);
                  }
                  return;
                }
                utils.nextTick(function() {
                  self2.recv();
                });
              });
              recvRequest.exec();
            };
            CometTransport.prototype.onData = function(responseData) {
              try {
                var items = this.decodeResponse(responseData);
                if (items && items.length)
                  for (var i = 0; i < items.length; i++)
                    this.onProtocolMessage(protocolmessage.fromDeserialized(items[i]));
              } catch (e) {
                util_logger.logAction(util_logger.LOG_ERROR, "CometTransport.onData()", "Unexpected exception handing channel event: " + e.stack);
              }
            };
            CometTransport.prototype.encodeRequest = function(requestItems) {
              return JSON.stringify(requestItems);
            };
            CometTransport.prototype.decodeResponse = function(responseData) {
              if (typeof responseData == "string")
                responseData = JSON.parse(responseData);
              return responseData;
            };
            CometTransport.prototype.onAuthUpdated = function(tokenDetails) {
              this.authParams = { access_token: tokenDetails.token };
            };
            return CometTransport;
          }();
          var comettransport = comettransport_CometTransport;
          var nodecomettransport_NodeCometTransport = function(connectionManager) {
            var http = __webpack_require__(5);
            var https = __webpack_require__(6);
            var url = __webpack_require__(25);
            var util = __webpack_require__(3);
            var noop = function() {
            };
            var shortName = "comet";
            function NodeCometTransport(connectionManager2, auth, params) {
              comettransport.call(this, connectionManager2, auth, params);
              this.httpAgent = null;
              this.httpsAgent = null;
              this.pendingRequests = 0;
              this.shortName = shortName;
            }
            util.inherits(NodeCometTransport, comettransport);
            NodeCometTransport.isAvailable = function() {
              return true;
            };
            connectionManager.supportedTransports[shortName] = NodeCometTransport;
            NodeCometTransport.tryConnect = function(connectionManager2, auth, params, callback) {
              var transport = new NodeCometTransport(connectionManager2, auth, params);
              var errorCb = function(err) {
                callback({ event: this.event, error: err });
              };
              transport.on(["failed", "disconnected"], errorCb);
              transport.on("preconnect", function() {
                util_logger.logAction(util_logger.LOG_MINOR, "NodeCometTransport.tryConnect()", "viable transport " + transport);
                transport.off(["failed", "disconnected"], errorCb);
                callback(null, transport);
              });
              transport.connect();
            };
            NodeCometTransport.prototype.toString = function() {
              return "NodeCometTransport; uri=" + this.baseUri + "; isConnected=" + this.isConnected + "; format=" + this.format + "; stream=" + this.stream;
            };
            NodeCometTransport.prototype.getAgent = function(tls) {
              var prop = tls ? "httpsAgent" : "httpAgent", agent2 = this[prop];
              if (!agent2)
                agent2 = this[prop] = new (tls ? https : http).Agent({ keepAlive: true });
              return agent2;
            };
            NodeCometTransport.prototype.dispose = function() {
              var self2 = this;
              this.onceNoPending(function() {
                if (self2.httpAgent)
                  self2.httpAgent.destroy();
                if (self2.httpsAgent)
                  self2.httpsAgent.destroy();
              });
              comettransport.prototype.dispose.call(this);
            };
            NodeCometTransport.prototype.request = function(uri, params, body, requestMode, callback) {
              var req = this.createRequest(uri, params, body, requestMode);
              req.once("complete", callback);
              req.exec();
              return req;
            };
            NodeCometTransport.prototype.createRequest = function(uri, headers, params, body, requestMode) {
              return new Request2(uri, headers, params, body, requestMode, this.format, this.timeouts, this);
            };
            NodeCometTransport.prototype.addPending = function() {
              ++this.pendingRequests;
            };
            NodeCometTransport.prototype.removePending = function() {
              if (--this.pendingRequests <= 0) {
                this.emit("nopending");
              }
            };
            NodeCometTransport.prototype.onceNoPending = function(listener) {
              if (this.pendingRequests == 0) {
                listener();
                return;
              }
              this.once("nopending", listener);
            };
            function Request2(uri, headers, params, body, requestMode, format, timeouts, transport) {
              eventemitter.call(this);
              if (typeof uri == "string")
                uri = url.parse(uri);
              var tls = uri.protocol == "https:";
              this.client = tls ? https : http;
              this.requestMode = requestMode;
              this.timeouts = timeouts;
              this.transport = transport;
              this.requestComplete = false;
              this.req = this.res = null;
              var method = "GET", contentType = format == "msgpack" ? "application/x-msgpack" : "application/json";
              headers = headers ? utils.mixin({}, headers) : {};
              headers["accept"] = contentType;
              if (body) {
                method = "POST";
                if (!Buffer.isBuffer(body)) {
                  if (typeof body == "object")
                    body = JSON.stringify(body);
                  body = Buffer.from(body);
                }
                this.body = body;
                headers["Content-Length"] = body.length;
                headers["Content-Type"] = contentType;
              }
              var requestOptions = this.requestOptions = {
                hostname: uri.hostname,
                port: uri.port,
                path: uri.path + utils.toQueryString(params),
                method,
                headers
              };
              if (transport)
                requestOptions.agent = transport.getAgent(tls);
            }
            utils.inherits(Request2, eventemitter);
            Request2.prototype.exec = function() {
              var timeout = this.requestMode == comettransport.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout, self2 = this;
              var timer = this.timer = setTimeout(function() {
                self2.abort();
              }, timeout), req = this.req = this.client.request(this.requestOptions);
              req.on("error", this.onReqError = function(err) {
                err = new errorinfo("Request error: " + err.message, null, 400);
                clearTimeout(timer);
                self2.timer = null;
                self2.complete(err);
              });
              req.on("response", function(res) {
                clearTimeout(timer);
                self2.timer = null;
                var statusCode = res.statusCode;
                if (statusCode == 204) {
                  res.resume();
                  self2.complete();
                  return;
                }
                res.on("error", self2.onResError = function(err) {
                  err = new errorinfo("Response error: " + err.message, null, 400);
                  self2.complete(err);
                });
                self2.res = res;
                if (self2.requestMode == comettransport.REQ_RECV_STREAM && statusCode < 400) {
                  self2.readStream();
                } else {
                  self2.readFully();
                }
              });
              if (this.transport)
                this.transport.addPending();
              req.end(this.body);
            };
            Request2.prototype.readStream = function() {
              var res = this.res, headers = res.headers, self2 = this;
              this.chunks = [];
              this.streamComplete = false;
              function onChunk(chunk) {
                try {
                  chunk = JSON.parse(chunk);
                } catch (e) {
                  var msg = "Malformed response body from server: " + e.message;
                  util_logger.logAction(util_logger.LOG_ERROR, "NodeCometTransport.Request.readStream()", msg);
                  self2.complete(new errorinfo(msg, null, 400));
                  return;
                }
                self2.emit("data", chunk);
              }
              res.on("data", this.ondata = function(data) {
                var newChunks = String(data).split("\n"), chunks = self2.chunks;
                if (newChunks.length > 1 && chunks.length > 0) {
                  chunks.push(newChunks.shift());
                  self2.chunks = [];
                  onChunk(chunks.join(""));
                }
                var trailingNewChunk = newChunks.pop();
                if (trailingNewChunk.length) {
                  self2.chunks.push(trailingNewChunk);
                }
                newChunks.map(onChunk);
              });
              res.on("end", function() {
                self2.streamComplete = true;
                process.nextTick(function() {
                  self2.complete();
                });
              });
            };
            Request2.prototype.readFully = function() {
              var res = this.res, chunks = [], self2 = this;
              res.on("data", function(chunk) {
                chunks.push(chunk);
              });
              res.on("end", function() {
                process.nextTick(function() {
                  var body = Buffer.concat(chunks), statusCode = res.statusCode;
                  try {
                    body = JSON.parse(String(body));
                  } catch (e) {
                    var msg = "Malformed response body from server: " + e.message;
                    util_logger.logAction(util_logger.LOG_ERROR, "NodeCometTransport.Request.readFully()", msg);
                    self2.complete(new errorinfo(msg, null, 400));
                    return;
                  }
                  if (statusCode < 400 || utils.isArray(body)) {
                    self2.complete(null, body);
                    return;
                  }
                  var err = body.error && errorinfo.fromValues(body.error);
                  if (!err) {
                    err = new errorinfo("Error response received from server: " + statusCode + ", body was: " + utils.inspect(body), null, statusCode);
                  }
                  self2.complete(err);
                });
              });
            };
            Request2.prototype.complete = function(err, body) {
              if (!this.requestComplete) {
                this.requestComplete = true;
                if (body)
                  this.emit("data", body);
                this.emit("complete", err, body);
                if (err) {
                  if (this.ondata && !this.streamComplete) {
                    if (this.ondata && this.res)
                      this.res.removeListener("data", this.ondata);
                  }
                }
                if (this.transport) {
                  this.transport.removePending();
                }
              }
            };
            Request2.prototype.abort = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "NodeCometTransport.Request.abort()", "");
              var timer = this.timer;
              if (timer) {
                clearTimeout(timer);
                this.timer = null;
              }
              var req = this.req;
              if (req) {
                util_logger.logAction(util_logger.LOG_MINOR, "NodeCometTransport.Request.abort()", "aborting request");
                req.removeListener("error", this.onReqError);
                req.on("error", noop);
                req.abort();
                this.req = null;
              }
              this.complete({ statusCode: 400, code: 80003, message: "Cancelled" });
            };
            return NodeCometTransport;
          };
          var nodecomettransport = nodecomettransport_NodeCometTransport;
          var lib_transport = [
            nodecomettransport
          ];
          var websockettransport_WebSocketTransport = function(connectionManager) {
            var WebSocket = platform.WebSocket;
            var shortName = "web_socket";
            function WebSocketTransport(connectionManager2, auth, params) {
              this.shortName = shortName;
              params.heartbeats = platform.useProtocolHeartbeats;
              transport_transport.call(this, connectionManager2, auth, params);
              this.wsHost = util_defaults.getHost(params.options, params.host, true);
            }
            utils.inherits(WebSocketTransport, transport_transport);
            WebSocketTransport.isAvailable = function() {
              return !!WebSocket;
            };
            if (WebSocketTransport.isAvailable())
              connectionManager.supportedTransports[shortName] = WebSocketTransport;
            WebSocketTransport.tryConnect = function(connectionManager2, auth, params, callback) {
              var transport = new WebSocketTransport(connectionManager2, auth, params);
              var errorCb = function(err) {
                callback({ event: this.event, error: err });
              };
              transport.on(["failed", "disconnected"], errorCb);
              transport.on("wsopen", function() {
                util_logger.logAction(util_logger.LOG_MINOR, "WebSocketTransport.tryConnect()", "viable transport " + transport);
                transport.off(["failed", "disconnected"], errorCb);
                callback(null, transport);
              });
              transport.connect();
            };
            WebSocketTransport.prototype.createWebSocket = function(uri, connectParams) {
              this.uri = uri + utils.toQueryString(connectParams);
              return new WebSocket(this.uri);
            };
            WebSocketTransport.prototype.toString = function() {
              return "WebSocketTransport; uri=" + this.uri;
            };
            WebSocketTransport.prototype.connect = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "WebSocketTransport.connect()", "starting");
              transport_transport.prototype.connect.call(this);
              var self2 = this, params = this.params, options = params.options;
              var wsScheme = options.tls ? "wss://" : "ws://";
              var wsUri = wsScheme + this.wsHost + ":" + util_defaults.getPort(options) + "/";
              util_logger.logAction(util_logger.LOG_MINOR, "WebSocketTransport.connect()", "uri: " + wsUri);
              this.auth.getAuthParams(function(err, authParams) {
                if (self2.isDisposed) {
                  return;
                }
                var paramStr = "";
                for (var param in authParams)
                  paramStr += " " + param + ": " + authParams[param] + ";";
                util_logger.logAction(util_logger.LOG_MINOR, "WebSocketTransport.connect()", "authParams:" + paramStr + " err: " + err);
                if (err) {
                  self2.disconnect(err);
                  return;
                }
                var connectParams = params.getConnectParams(authParams);
                try {
                  var wsConnection = self2.wsConnection = self2.createWebSocket(wsUri, connectParams);
                  wsConnection.binaryType = platform.binaryType;
                  wsConnection.onopen = function() {
                    self2.onWsOpen();
                  };
                  wsConnection.onclose = function(ev) {
                    self2.onWsClose(ev);
                  };
                  wsConnection.onmessage = function(ev) {
                    self2.onWsData(ev.data);
                  };
                  wsConnection.onerror = function(ev) {
                    self2.onWsError(ev);
                  };
                  if (wsConnection.on) {
                    wsConnection.on("ping", function() {
                      self2.onActivity();
                    });
                  }
                } catch (e) {
                  util_logger.logAction(util_logger.LOG_ERROR, "WebSocketTransport.connect()", "Unexpected exception creating websocket: err = " + (e.stack || e.message));
                  self2.disconnect(e);
                }
              });
            };
            WebSocketTransport.prototype.send = function(message) {
              var wsConnection = this.wsConnection;
              if (!wsConnection) {
                util_logger.logAction(util_logger.LOG_ERROR, "WebSocketTransport.send()", "No socket connection");
                return;
              }
              try {
                wsConnection.send(protocolmessage.serialize(message, this.params.format));
              } catch (e) {
                var msg = "Exception from ws connection when trying to send: " + utils.inspectError(e);
                util_logger.logAction(util_logger.LOG_ERROR, "WebSocketTransport.send()", msg);
                this.finish("disconnected", new errorinfo(msg, 5e4, 500));
              }
            };
            WebSocketTransport.prototype.onWsData = function(data) {
              util_logger.logAction(util_logger.LOG_MICRO, "WebSocketTransport.onWsData()", "data received; length = " + data.length + "; type = " + typeof data);
              try {
                this.onProtocolMessage(protocolmessage.deserialize(data, this.format));
              } catch (e) {
                util_logger.logAction(util_logger.LOG_ERROR, "WebSocketTransport.onWsData()", "Unexpected exception handing channel message: " + e.stack);
              }
            };
            WebSocketTransport.prototype.onWsOpen = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "WebSocketTransport.onWsOpen()", "opened WebSocket");
              this.emit("wsopen");
            };
            WebSocketTransport.prototype.onWsClose = function(ev) {
              var wasClean, code, reason;
              if (typeof ev == "object") {
                wasClean = ev.wasClean;
                code = ev.code;
              } else {
                code = ev;
                wasClean = code == 1e3;
              }
              delete this.wsConnection;
              if (wasClean) {
                util_logger.logAction(util_logger.LOG_MINOR, "WebSocketTransport.onWsClose()", "Cleanly closed WebSocket");
                var err = new errorinfo("Websocket closed", 80003, 400);
                this.finish("disconnected", err);
              } else {
                var msg = "Unclean disconnection of WebSocket ; code = " + code, err = new errorinfo(msg, 80003, 400);
                util_logger.logAction(util_logger.LOG_MINOR, "WebSocketTransport.onWsClose()", msg);
                this.finish("disconnected", err);
              }
              this.emit("disposed");
            };
            WebSocketTransport.prototype.onWsError = function(err) {
              util_logger.logAction(util_logger.LOG_MINOR, "WebSocketTransport.onError()", "Error from WebSocket: " + err.message);
              var self2 = this;
              utils.nextTick(function() {
                self2.disconnect(err);
              });
            };
            WebSocketTransport.prototype.dispose = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "WebSocketTransport.dispose()", "");
              this.isDisposed = true;
              var wsConnection = this.wsConnection;
              if (wsConnection) {
                wsConnection.onmessage = function() {
                };
                delete this.wsConnection;
                utils.nextTick(function() {
                  util_logger.logAction(util_logger.LOG_MICRO, "WebSocketTransport.dispose()", "closing websocket");
                  wsConnection.close();
                });
              }
            };
            return WebSocketTransport;
          };
          var websockettransport = websockettransport_WebSocketTransport;
          var connectionmanager_ConnectionManager = function() {
            var haveWebStorage = !!(typeof webstorage !== "undefined" && webstorage.get);
            var haveSessionStorage = !!(typeof webstorage !== "undefined" && webstorage.getSession);
            var actions = protocolmessage.Action;
            var PendingMessage = protocol.PendingMessage;
            var noop = function() {
            };
            var transportPreferenceOrder = util_defaults.transportPreferenceOrder;
            var optimalTransport = transportPreferenceOrder[transportPreferenceOrder.length - 1];
            var transportPreferenceName = "ably-transport-preference";
            var sessionRecoveryName = "ably-connection-recovery";
            function getSessionRecoverData() {
              return haveSessionStorage && webstorage.getSession(sessionRecoveryName);
            }
            function setSessionRecoverData(value) {
              return haveSessionStorage && webstorage.setSession(sessionRecoveryName, value);
            }
            function clearSessionRecoverData() {
              return haveSessionStorage && webstorage.removeSession(sessionRecoveryName);
            }
            function betterTransportThan(a, b) {
              return utils.arrIndexOf(transportPreferenceOrder, a.shortName) > utils.arrIndexOf(transportPreferenceOrder, b.shortName);
            }
            function TransportParams(options, host, mode, connectionKey) {
              this.options = options;
              this.host = host;
              this.mode = mode;
              this.connectionKey = connectionKey;
              this.format = options.useBinaryProtocol ? "msgpack" : "json";
              this.connectionSerial = void 0;
              this.timeSerial = void 0;
            }
            TransportParams.prototype.getConnectParams = function(authParams) {
              var params = authParams ? utils.copy(authParams) : {};
              var options = this.options;
              switch (this.mode) {
                case "upgrade":
                  params.upgrade = this.connectionKey;
                  break;
                case "resume":
                  params.resume = this.connectionKey;
                  if (this.timeSerial !== void 0) {
                    params.timeSerial = this.timeSerial;
                  } else if (this.connectionSerial !== void 0) {
                    params.connectionSerial = this.connectionSerial;
                  }
                  break;
                case "recover":
                  var match = options.recover.split(":");
                  if (match) {
                    params.recover = match[0];
                    var recoverSerial = match[1];
                    if (isNaN(recoverSerial)) {
                      params.timeSerial = recoverSerial;
                    } else {
                      params.connectionSerial = recoverSerial;
                    }
                  }
                  break;
                default:
              }
              if (options.clientId !== void 0) {
                params.clientId = options.clientId;
              }
              if (options.echoMessages === false) {
                params.echo = "false";
              }
              if (this.format !== void 0) {
                params.format = this.format;
              }
              if (this.stream !== void 0) {
                params.stream = this.stream;
              }
              if (this.heartbeats !== void 0) {
                params.heartbeats = this.heartbeats;
              }
              params.v = util_defaults.apiVersion;
              params.agent = util_defaults.agent;
              if (options.transportParams !== void 0) {
                utils.mixin(params, options.transportParams);
              }
              return params;
            };
            TransportParams.prototype.toString = function() {
              var result = "[mode=" + this.mode;
              if (this.host) {
                result += ",host=" + this.host;
              }
              if (this.connectionKey) {
                result += ",connectionKey=" + this.connectionKey;
              }
              if (this.connectionSerial !== void 0) {
                result += ",connectionSerial=" + this.connectionSerial;
              }
              if (this.timeSerial) {
                result += ",timeSerial=" + this.timeSerial;
              }
              if (this.format) {
                result += ",format=" + this.format;
              }
              result += "]";
              return result;
            };
            function ConnectionManager(realtime, options) {
              eventemitter.call(this);
              this.realtime = realtime;
              this.options = options;
              var timeouts = options.timeouts;
              var self2 = this;
              var connectingTimeout = timeouts.preferenceConnectTimeout + timeouts.realtimeRequestTimeout;
              this.states = {
                initialized: { state: "initialized", terminal: false, queueEvents: true, sendEvents: false, failState: "disconnected" },
                connecting: { state: "connecting", terminal: false, queueEvents: true, sendEvents: false, retryDelay: connectingTimeout, failState: "disconnected" },
                connected: { state: "connected", terminal: false, queueEvents: false, sendEvents: true, failState: "disconnected" },
                synchronizing: { state: "connected", terminal: false, queueEvents: true, sendEvents: false, forceQueueEvents: true, failState: "disconnected" },
                disconnected: { state: "disconnected", terminal: false, queueEvents: true, sendEvents: false, retryDelay: timeouts.disconnectedRetryTimeout, failState: "disconnected" },
                suspended: { state: "suspended", terminal: false, queueEvents: false, sendEvents: false, retryDelay: timeouts.suspendedRetryTimeout, failState: "suspended" },
                closing: { state: "closing", terminal: false, queueEvents: false, sendEvents: false, retryDelay: timeouts.realtimeRequestTimeout, failState: "closed" },
                closed: { state: "closed", terminal: true, queueEvents: false, sendEvents: false, failState: "closed" },
                failed: { state: "failed", terminal: true, queueEvents: false, sendEvents: false, failState: "failed" }
              };
              this.state = this.states.initialized;
              this.errorReason = null;
              this.queuedMessages = new messagequeue();
              this.msgSerial = 0;
              this.connectionDetails = void 0;
              this.connectionId = void 0;
              this.connectionKey = void 0;
              this.timeSerial = void 0;
              this.connectionSerial = void 0;
              this.connectionStateTtl = timeouts.connectionStateTtl;
              this.maxIdleInterval = null;
              this.transports = utils.intersect(options.transports || util_defaults.defaultTransports, ConnectionManager.supportedTransports);
              this.baseTransport = utils.intersect(util_defaults.baseTransportOrder, this.transports)[0];
              this.upgradeTransports = utils.intersect(this.transports, util_defaults.upgradeTransports);
              this.transportPreference = null;
              this.httpHosts = util_defaults.getHosts(options);
              this.activeProtocol = null;
              this.proposedTransports = [];
              this.pendingTransports = [];
              this.host = null;
              this.lastAutoReconnectAttempt = null;
              this.lastActivity = null;
              this.mostRecentMsg = null;
              this.forceFallbackHost = false;
              this.connectCounter = 0;
              util_logger.logAction(util_logger.LOG_MINOR, "Realtime.ConnectionManager()", "started");
              util_logger.logAction(util_logger.LOG_MICRO, "Realtime.ConnectionManager()", "requested transports = [" + (options.transports || util_defaults.defaultTransports) + "]");
              util_logger.logAction(util_logger.LOG_MICRO, "Realtime.ConnectionManager()", "available transports = [" + this.transports + "]");
              util_logger.logAction(util_logger.LOG_MICRO, "Realtime.ConnectionManager()", "http hosts = [" + this.httpHosts + "]");
              if (!this.transports.length) {
                var msg = "no requested transports available";
                util_logger.logAction(util_logger.LOG_ERROR, "realtime.ConnectionManager()", msg);
                throw new Error(msg);
              }
              var addEventListener = platform.addEventListener;
              if (addEventListener) {
                if (haveSessionStorage && typeof options.recover === "function") {
                  addEventListener("beforeunload", this.persistConnection.bind(this));
                }
                if (options.closeOnUnload === true) {
                  addEventListener("beforeunload", function() {
                    util_logger.logAction(util_logger.LOG_MAJOR, "Realtime.ConnectionManager()", "beforeunload event has triggered the connection to close as closeOnUnload is true");
                    self2.requestState({ state: "closing" });
                  });
                }
                addEventListener("online", function() {
                  if (self2.state == self2.states.disconnected || self2.state == self2.states.suspended) {
                    util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager caught browser \u2018online\u2019 event", "reattempting connection");
                    self2.requestState({ state: "connecting" });
                  }
                });
                addEventListener("offline", function() {
                  if (self2.state == self2.states.connected) {
                    util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager caught browser \u2018offline\u2019 event", "disconnecting active transport");
                    self2.disconnectAllTransports();
                  }
                });
              }
            }
            utils.inherits(ConnectionManager, eventemitter);
            ConnectionManager.supportedTransports = {};
            websockettransport(ConnectionManager);
            utils.arrForEach(lib_transport, function(initFn) {
              initFn(ConnectionManager);
            });
            ConnectionManager.prototype.createTransportParams = function(host, mode) {
              var params = new TransportParams(this.options, host, mode, this.connectionKey);
              if (this.timeSerial) {
                params.timeSerial = this.timeSerial;
              } else if (this.connectionSerial !== void 0) {
                params.connectionSerial = this.connectionSerial;
              }
              return params;
            };
            ConnectionManager.prototype.getTransportParams = function(callback) {
              var self2 = this;
              function decideMode(modeCb) {
                if (self2.connectionKey) {
                  modeCb("resume");
                  return;
                }
                if (typeof self2.options.recover === "string") {
                  modeCb("recover");
                  return;
                }
                var recoverFn = self2.options.recover, lastSessionData = getSessionRecoverData();
                if (lastSessionData && typeof recoverFn === "function") {
                  util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.getTransportParams()", "Calling clientOptions-provided recover function with last session data");
                  recoverFn(lastSessionData, function(shouldRecover) {
                    if (shouldRecover) {
                      self2.options.recover = lastSessionData.recoveryKey;
                      modeCb("recover");
                    } else {
                      modeCb("clean");
                    }
                  });
                  return;
                }
                modeCb("clean");
              }
              decideMode(function(mode) {
                var transportParams = self2.createTransportParams(null, mode);
                if (mode === "recover") {
                  util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.getTransportParams()", "Transport recovery mode = recover; recoveryKey = " + self2.options.recover);
                  var match = self2.options.recover.split(":");
                  if (match && match[2]) {
                    self2.msgSerial = match[2];
                  }
                } else {
                  util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.getTransportParams()", "Transport params = " + transportParams.toString());
                }
                callback(transportParams);
              });
            };
            ConnectionManager.prototype.tryATransport = function(transportParams, candidate, callback) {
              var self2 = this, host = transportParams.host;
              util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.tryATransport()", "trying " + candidate);
              ConnectionManager.supportedTransports[candidate].tryConnect(this, this.realtime.auth, transportParams, function(wrappedErr, transport) {
                var state = self2.state;
                if (state == self2.states.closing || state == self2.states.closed || state == self2.states.failed) {
                  if (transport) {
                    util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.tryATransport()", "connection " + state.state + " while we were attempting the transport; closing " + transport);
                    transport.close();
                  }
                  callback(true);
                  return;
                }
                if (wrappedErr) {
                  util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.tryATransport()", "transport " + candidate + " " + wrappedErr.event + ", err: " + wrappedErr.error.toString());
                  if (client_auth.isTokenErr(wrappedErr.error) && !(self2.errorReason && client_auth.isTokenErr(self2.errorReason))) {
                    self2.errorReason = wrappedErr.error;
                    self2.realtime.auth._forceNewToken(null, null, function(err) {
                      if (err) {
                        self2.actOnErrorFromAuthorize(err);
                        return;
                      }
                      self2.tryATransport(transportParams, candidate, callback);
                    });
                  } else if (wrappedErr.event === "failed") {
                    self2.notifyState({ state: "failed", error: wrappedErr.error });
                    callback(true);
                  } else if (wrappedErr.event === "disconnected") {
                    if (!connectionerror.isRetriable(wrappedErr.error)) {
                      self2.notifyState({ state: self2.states.connecting.failState, error: wrappedErr.error });
                      callback(true);
                    } else {
                      callback(false);
                    }
                  }
                  return;
                }
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.tryATransport()", "viable transport " + candidate + "; setting pending");
                self2.setTransportPending(transport, transportParams);
                callback(null, transport);
              });
            };
            ConnectionManager.prototype.setTransportPending = function(transport, transportParams) {
              var mode = transportParams.mode;
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.setTransportPending()", "transport = " + transport + "; mode = " + mode);
              utils.arrDeleteValue(this.proposedTransports, transport);
              this.pendingTransports.push(transport);
              var self2 = this;
              transport.once("connected", function(error, connectionId, connectionDetails, connectionPosition) {
                if (mode == "upgrade" && self2.activeProtocol) {
                  if (transport.shortName !== optimalTransport && utils.arrIn(self2.getUpgradePossibilities(), optimalTransport)) {
                    setTimeout(function() {
                      self2.scheduleTransportActivation(error, transport, connectionId, connectionDetails, connectionPosition);
                    }, self2.options.timeouts.parallelUpgradeDelay);
                  } else {
                    self2.scheduleTransportActivation(error, transport, connectionId, connectionDetails, connectionPosition);
                  }
                } else {
                  self2.activateTransport(error, transport, connectionId, connectionDetails, connectionPosition);
                  utils.nextTick(function() {
                    self2.connectImpl(transportParams);
                  });
                }
                if (mode === "recover" && self2.options.recover) {
                  self2.options.recover = null;
                  self2.unpersistConnection();
                }
              });
              transport.on(["disconnected", "closed", "failed"], function(error) {
                self2.deactivateTransport(transport, this.event, error);
              });
              this.emit("transport.pending", transport);
            };
            ConnectionManager.prototype.scheduleTransportActivation = function(error, transport, connectionId, connectionDetails, upgradeConnectionPosition) {
              var self2 = this, currentTransport = this.activeProtocol && this.activeProtocol.getTransport(), abandon = function() {
                transport.disconnect();
                utils.arrDeleteValue(self2.pendingTransports, transport);
              };
              if (this.state !== this.states.connected && this.state !== this.states.connecting) {
                util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.scheduleTransportActivation()", "Current connection state (" + this.state.state + (this.state === this.states.synchronizing ? ", but with an upgrade already in progress" : "") + ") is not valid to upgrade in; abandoning upgrade to " + transport.shortName);
                abandon();
                return;
              }
              if (currentTransport && !betterTransportThan(transport, currentTransport)) {
                util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.scheduleTransportActivation()", "Proposed transport " + transport.shortName + " is no better than current active transport " + currentTransport.shortName + " - abandoning upgrade");
                abandon();
                return;
              }
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.scheduleTransportActivation()", "Scheduling transport upgrade; transport = " + transport);
              this.realtime.channels.onceNopending(function(err) {
                var oldProtocol;
                if (err) {
                  util_logger.logAction(util_logger.LOG_ERROR, "ConnectionManager.scheduleTransportActivation()", "Unable to activate transport; transport = " + transport + "; err = " + err);
                  return;
                }
                if (!transport.isConnected) {
                  util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.scheduleTransportActivation()", "Proposed transport " + transport.shortName + "is no longer connected; abandoning upgrade");
                  abandon();
                  return;
                }
                if (self2.state === self2.states.connected) {
                  util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.scheduleTransportActivation()", "Currently connected, so temporarily pausing events until the upgrade is complete");
                  self2.state = self2.states.synchronizing;
                  oldProtocol = self2.activeProtocol;
                } else if (self2.state !== self2.states.connecting) {
                  util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.scheduleTransportActivation()", "Current connection state (" + self2.state.state + (self2.state === self2.states.synchronizing ? ", but with an upgrade already in progress" : "") + ") is not valid to upgrade in; abandoning upgrade to " + transport.shortName);
                  abandon();
                  return;
                }
                var connectionReset = connectionId !== self2.connectionId, syncPosition = connectionReset ? upgradeConnectionPosition : self2;
                if (connectionReset) {
                  util_logger.logAction(util_logger.LOG_ERROR, "ConnectionManager.scheduleTransportActivation()", "Upgrade resulted in new connectionId; resetting library connection position from " + (self2.timeSerial || self2.connectionSerial) + " to " + (syncPosition.timeSerial || syncPosition.connectionSerial) + "; upgrade error was " + error);
                }
                util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.scheduleTransportActivation()", "Syncing transport; transport = " + transport);
                self2.sync(transport, syncPosition, function(syncErr, connectionId2, postSyncPosition) {
                  if (syncErr) {
                    if (self2.state === self2.states.synchronizing) {
                      util_logger.logAction(util_logger.LOG_ERROR, "ConnectionManager.scheduleTransportActivation()", "Unexpected error attempting to sync transport; transport = " + transport + "; err = " + syncErr);
                      self2.disconnectAllTransports();
                    }
                    return;
                  }
                  var finishUpgrade = function() {
                    util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.scheduleTransportActivation()", "Activating transport; transport = " + transport);
                    self2.activateTransport(error, transport, connectionId2, connectionDetails, postSyncPosition);
                    if (self2.state === self2.states.synchronizing) {
                      util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.scheduleTransportActivation()", "Pre-upgrade protocol idle, sending queued messages on upgraded transport; transport = " + transport);
                      self2.state = self2.states.connected;
                    } else {
                      util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.scheduleTransportActivation()", "Pre-upgrade protocol idle, but state is now " + self2.state.state + ", so leaving unchanged");
                    }
                    if (self2.state.sendEvents) {
                      self2.sendQueuedMessages();
                    }
                  };
                  if (oldProtocol) {
                    oldProtocol.onceIdle(finishUpgrade);
                  } else {
                    finishUpgrade();
                  }
                });
              });
            };
            ConnectionManager.prototype.activateTransport = function(error, transport, connectionId, connectionDetails, connectionPosition) {
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.activateTransport()", "transport = " + transport);
              if (error) {
                util_logger.logAction(util_logger.LOG_ERROR, "ConnectionManager.activateTransport()", "error = " + error);
              }
              if (connectionId) {
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.activateTransport()", "connectionId =  " + connectionId);
              }
              if (connectionDetails) {
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.activateTransport()", "connectionDetails =  " + JSON.stringify(connectionDetails));
              }
              if (connectionPosition) {
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.activateTransport()", "serial =  " + (connectionPosition.timeSerial || connectionPosition.connectionSerial));
              }
              this.persistTransportPreference(transport);
              var existingState = this.state, connectedState = this.states.connected.state;
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.activateTransport()", "current state = " + existingState.state);
              if (existingState.state == this.states.closing.state || existingState.state == this.states.closed.state || existingState.state == this.states.failed.state) {
                util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.activateTransport()", "Disconnecting transport and abandoning");
                transport.disconnect();
                return false;
              }
              utils.arrDeleteValue(this.pendingTransports, transport);
              if (!transport.isConnected) {
                util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.activateTransport()", "Declining to activate transport " + transport + " since it appears to no longer be connected");
                return false;
              }
              var existingActiveProtocol = this.activeProtocol;
              this.activeProtocol = new protocol(transport);
              this.host = transport.params.host;
              var connectionKey = connectionDetails.connectionKey;
              if (connectionKey && this.connectionKey != connectionKey) {
                this.setConnection(connectionId, connectionDetails, connectionPosition, !!error);
              }
              this.onConnectionDetailsUpdate(connectionDetails, transport);
              var self2 = this;
              utils.nextTick(function() {
                transport.on("connected", function(connectedErr, _connectionId, connectionDetails2) {
                  self2.onConnectionDetailsUpdate(connectionDetails2, transport);
                  self2.emit("update", new connectionstatechange(connectedState, connectedState, null, connectedErr));
                });
              });
              if (existingState.state === this.states.connected.state) {
                if (error) {
                  this.errorReason = this.realtime.connection.errorReason = error;
                  this.emit("update", new connectionstatechange(connectedState, connectedState, null, error));
                }
              } else {
                this.notifyState({ state: "connected", error });
                this.errorReason = this.realtime.connection.errorReason = error || null;
              }
              this.emit("transport.active", transport);
              if (existingActiveProtocol) {
                if (existingActiveProtocol.messageQueue.count() > 0) {
                  util_logger.logAction(util_logger.LOG_ERROR, "ConnectionManager.activateTransport()", "Previous active protocol (for transport " + existingActiveProtocol.transport.shortName + ", new one is " + transport.shortName + ") finishing with " + existingActiveProtocol.messageQueue.count() + " messages still pending");
                }
                if (existingActiveProtocol.transport === transport) {
                  var msg = "Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = " + transport.shortName + "; stack = " + new Error().stack;
                  util_logger.logAction(util_logger.LOG_ERROR, "ConnectionManager.activateTransport()", msg);
                  errorreporter.report("error", msg, "transport-previously-active");
                } else {
                  existingActiveProtocol.finish();
                }
              }
              utils.safeArrForEach(this.pendingTransports, function(pendingTransport) {
                if (pendingTransport === transport) {
                  var msg2 = "Assumption violated: activating a transport that is still marked as a pending transport; transport = " + transport.shortName + "; stack = " + new Error().stack;
                  util_logger.logAction(util_logger.LOG_ERROR, "ConnectionManager.activateTransport()", msg2);
                  errorreporter.report("error", msg2, "transport-activating-pending");
                  utils.arrDeleteValue(self2.pendingTransports, transport);
                } else {
                  pendingTransport.disconnect();
                }
              });
              utils.safeArrForEach(this.proposedTransports, function(proposedTransport) {
                if (proposedTransport === transport) {
                  var msg2 = "Assumption violated: activating a transport that is still marked as a proposed transport; transport = " + transport.shortName + "; stack = " + new Error().stack;
                  util_logger.logAction(util_logger.LOG_ERROR, "ConnectionManager.activateTransport()", msg2);
                  errorreporter.report("error", msg2, "transport-activating-proposed");
                  utils.arrDeleteValue(self2.proposedTransports, transport);
                } else {
                  proposedTransport.dispose();
                }
              });
              return true;
            };
            ConnectionManager.prototype.deactivateTransport = function(transport, state, error) {
              var currentProtocol = this.activeProtocol, wasActive = currentProtocol && currentProtocol.getTransport() === transport, wasPending = utils.arrDeleteValue(this.pendingTransports, transport), wasProposed = utils.arrDeleteValue(this.proposedTransports, transport), noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.deactivateTransport()", "transport = " + transport);
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.deactivateTransport()", "state = " + state + (wasActive ? "; was active" : wasPending ? "; was pending" : wasProposed ? "; was proposed" : "") + (noTransportsScheduledForActivation ? "" : "; another transport is scheduled for activation"));
              if (error && error.message)
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.deactivateTransport()", "reason =  " + error.message);
              if (wasActive) {
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.deactivateTransport()", "Getting, clearing, and requeuing " + this.activeProtocol.messageQueue.count() + " pending messages");
                this.queuePendingMessages(currentProtocol.getPendingMessages());
                utils.nextTick(function() {
                  currentProtocol.clearPendingMessages();
                });
                this.activeProtocol = this.host = null;
                clearTimeout(this.channelResumeCheckTimer);
              }
              this.emit("transport.inactive", transport);
              if (wasActive && noTransportsScheduledForActivation || (wasActive && state === "failed" || state === "closed") || currentProtocol === null && wasPending && this.pendingTransports.length === 0) {
                if (state === "disconnected" && error && error.statusCode > 500 && this.httpHosts.length > 1) {
                  this.unpersistTransportPreference();
                  this.forceFallbackHost = true;
                  this.notifyState({ state, error, retryImmediately: true });
                  return;
                }
                var newConnectionState = state === "failed" && client_auth.isTokenErr(error) ? "disconnected" : state;
                this.notifyState({ state: newConnectionState, error });
                return;
              }
              if (wasActive && state === "disconnected" && this.state !== this.states.synchronizing) {
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.deactivateTransport()", "wasActive but another transport is connected and scheduled for activation, so going into the connecting state until it activates");
                this.startSuspendTimer();
                this.startTransitionTimer(this.states.connecting);
                this.notifyState({ state: "connecting", error });
              }
            };
            ConnectionManager.prototype.noTransportsScheduledForActivation = function() {
              return utils.isEmpty(this.pendingTransports) || this.pendingTransports.every(function(transport) {
                return !transport.isConnected;
              });
            };
            ConnectionManager.prototype.sync = function(transport, requestedSyncPosition, callback) {
              var timeout = setTimeout(function() {
                transport.off("sync");
                callback(new errorinfo("Timeout waiting for sync response", 5e4, 500));
              }, this.options.timeouts.realtimeRequestTimeout);
              var syncMessage = protocolmessage.fromValues({
                action: actions.SYNC,
                connectionKey: this.connectionKey
              });
              if (requestedSyncPosition.timeSerial) {
                syncMessage.timeSerial = requestedSyncPosition.timeSerial;
              } else if (requestedSyncPosition.connectionSerial !== void 0) {
                syncMessage.connectionSerial = requestedSyncPosition.connectionSerial;
              }
              transport.send(syncMessage);
              transport.once("sync", function(connectionId, syncPosition) {
                clearTimeout(timeout);
                callback(null, connectionId, syncPosition);
              });
            };
            ConnectionManager.prototype.setConnection = function(connectionId, connectionDetails, connectionPosition, hasConnectionError) {
              var self2 = this;
              var prevConnId = this.connectionid, connIdChanged = prevConnId && prevConnId !== connectionId, recoverFailure = !prevConnId && hasConnectionError;
              if (connIdChanged || recoverFailure) {
                util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.setConnection()", "Resetting msgSerial");
                this.msgSerial = 0;
              }
              if (this.connectionId !== connectionId) {
                util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.setConnection()", "New connectionId; reattaching any attached channels");
                utils.nextTick(function() {
                  self2.realtime.channels.reattach();
                });
              } else if (this.options.checkChannelsOnResume) {
                util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.setConnection()", "Same connectionId; checkChannelsOnResume is enabled");
                clearTimeout(this.channelResumeCheckTimer);
                this.realtime.channels.resetAttachedMsgIndicators();
                this.channelResumeCheckTimer = setTimeout(function() {
                  self2.realtime.channels.checkAttachedMsgIndicators(connectionId);
                }, 3e4);
              }
              this.realtime.connection.id = this.connectionId = connectionId;
              this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;
              var forceResetMessageSerial = connIdChanged || !prevConnId;
              this.setConnectionSerial(connectionPosition, forceResetMessageSerial);
            };
            ConnectionManager.prototype.clearConnection = function() {
              this.realtime.connection.id = this.connectionId = void 0;
              this.realtime.connection.key = this.connectionKey = void 0;
              this.clearConnectionSerial();
              this.msgSerial = 0;
              this.unpersistConnection();
            };
            ConnectionManager.prototype.setConnectionSerial = function(connectionPosition, force) {
              var timeSerial = connectionPosition.timeSerial, connectionSerial = connectionPosition.connectionSerial;
              util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.setConnectionSerial()", "Updating connection serial; serial = " + connectionSerial + "; timeSerial = " + timeSerial + "; force = " + force + "; previous = " + this.connectionSerial);
              if (timeSerial !== void 0) {
                if (timeSerial <= this.timeSerial && !force) {
                  util_logger.logAction(util_logger.LOG_ERROR, "ConnectionManager.setConnectionSerial()", "received message with timeSerial " + timeSerial + ", but current timeSerial is " + this.timeSerial + "; assuming message is a duplicate and discarding it");
                  return true;
                }
                this.realtime.connection.timeSerial = this.timeSerial = timeSerial;
                this.setRecoveryKey();
                return;
              }
              if (connectionSerial !== void 0) {
                if (connectionSerial <= this.connectionSerial && !force) {
                  util_logger.logAction(util_logger.LOG_ERROR, "ConnectionManager.setConnectionSerial()", "received message with connectionSerial " + connectionSerial + ", but current connectionSerial is " + this.connectionSerial + "; assuming message is a duplicate and discarding it");
                  return true;
                }
                this.realtime.connection.serial = this.connectionSerial = connectionSerial;
                this.setRecoveryKey();
              }
            };
            ConnectionManager.prototype.clearConnectionSerial = function() {
              this.realtime.connection.serial = this.connectionSerial = void 0;
              this.realtime.connection.timeSerial = this.timeSerial = void 0;
              this.clearRecoveryKey();
            };
            ConnectionManager.prototype.setRecoveryKey = function() {
              this.realtime.connection.recoveryKey = this.connectionKey + ":" + (this.timeSerial || this.connectionSerial) + ":" + this.msgSerial;
            };
            ConnectionManager.prototype.clearRecoveryKey = function() {
              this.realtime.connection.recoveryKey = null;
            };
            ConnectionManager.prototype.checkConnectionStateFreshness = function() {
              if (!this.lastActivity || !this.connectionId) {
                return;
              }
              var sinceLast = utils.now() - this.lastActivity;
              if (sinceLast > this.connectionStateTtl + this.maxIdleInterval) {
                util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.checkConnectionStateFreshness()", "Last known activity from realtime was " + sinceLast + "ms ago; discarding connection state");
                this.clearConnection();
                this.states.connecting.failState = "suspended";
                this.states.connecting.queueEvents = false;
              }
            };
            ConnectionManager.prototype.persistConnection = function() {
              if (haveSessionStorage) {
                var recoveryKey = this.realtime.connection.recoveryKey;
                if (recoveryKey) {
                  setSessionRecoverData({
                    recoveryKey,
                    disconnectedAt: utils.now(),
                    location: global.location,
                    clientId: this.realtime.auth.clientId
                  }, this.connectionStateTtl);
                }
              }
            };
            ConnectionManager.prototype.unpersistConnection = function() {
              clearSessionRecoverData();
            };
            ConnectionManager.prototype.getError = function() {
              return this.errorReason || this.getStateError();
            };
            ConnectionManager.prototype.getStateError = function() {
              return connectionerror[this.state.state];
            };
            ConnectionManager.prototype.activeState = function() {
              return this.state.queueEvents || this.state.sendEvents;
            };
            ConnectionManager.prototype.enactStateChange = function(stateChange) {
              var logLevel = stateChange.current === "failed" ? util_logger.LOG_ERROR : util_logger.LOG_MAJOR;
              util_logger.logAction(logLevel, "Connection state", stateChange.current + (stateChange.reason ? "; reason: " + stateChange.reason : ""));
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.enactStateChange", "setting new state: " + stateChange.current + "; reason = " + (stateChange.reason && stateChange.reason.message));
              var newState = this.state = this.states[stateChange.current];
              if (stateChange.reason) {
                this.errorReason = stateChange.reason;
                this.realtime.connection.errorReason = stateChange.reason;
              }
              if (newState.terminal || newState.state === "suspended") {
                this.clearConnection();
              }
              this.emit("connectionstate", stateChange);
            };
            ConnectionManager.prototype.startTransitionTimer = function(transitionState) {
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.startTransitionTimer()", "transitionState: " + transitionState.state);
              if (this.transitionTimer) {
                util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.startTransitionTimer()", "clearing already-running timer");
                clearTimeout(this.transitionTimer);
              }
              var self2 = this;
              this.transitionTimer = setTimeout(function() {
                if (self2.transitionTimer) {
                  self2.transitionTimer = null;
                  util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager " + transitionState.state + " timer expired", "requesting new state: " + transitionState.failState);
                  self2.notifyState({ state: transitionState.failState });
                }
              }, transitionState.retryDelay);
            };
            ConnectionManager.prototype.cancelTransitionTimer = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.cancelTransitionTimer()", "");
              if (this.transitionTimer) {
                clearTimeout(this.transitionTimer);
                this.transitionTimer = null;
              }
            };
            ConnectionManager.prototype.startSuspendTimer = function() {
              var self2 = this;
              if (this.suspendTimer)
                return;
              this.suspendTimer = setTimeout(function() {
                if (self2.suspendTimer) {
                  self2.suspendTimer = null;
                  util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager suspend timer expired", "requesting new state: suspended");
                  self2.states.connecting.failState = "suspended";
                  self2.states.connecting.queueEvents = false;
                  self2.notifyState({ state: "suspended" });
                }
              }, this.connectionStateTtl);
            };
            ConnectionManager.prototype.checkSuspendTimer = function(state) {
              if (state !== "disconnected" && state !== "suspended" && state !== "connecting")
                this.cancelSuspendTimer();
            };
            ConnectionManager.prototype.cancelSuspendTimer = function() {
              this.states.connecting.failState = "disconnected";
              this.states.connecting.queueEvents = true;
              if (this.suspendTimer) {
                clearTimeout(this.suspendTimer);
                this.suspendTimer = null;
              }
            };
            ConnectionManager.prototype.startRetryTimer = function(interval) {
              var self2 = this;
              this.retryTimer = setTimeout(function() {
                util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager retry timer expired", "retrying");
                self2.retryTimer = null;
                self2.requestState({ state: "connecting" });
              }, interval);
            };
            ConnectionManager.prototype.cancelRetryTimer = function() {
              if (this.retryTimer) {
                clearTimeout(this.retryTimer);
                this.retryTimer = null;
              }
            };
            ConnectionManager.prototype.notifyState = function(indicated) {
              var state = indicated.state, self2 = this;
              var retryImmediately = state === "disconnected" && (this.state === this.states.connected || this.state === this.states.synchronizing || indicated.retryImmediately || this.state === this.states.connecting && indicated.error && client_auth.isTokenErr(indicated.error) && !(this.errorReason && client_auth.isTokenErr(this.errorReason)));
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.notifyState()", "new state: " + state + (retryImmediately ? "; will retry connection immediately" : ""));
              if (state == this.state.state)
                return;
              this.cancelTransitionTimer();
              this.cancelRetryTimer();
              this.checkSuspendTimer(indicated.state);
              if (this.state.terminal)
                return;
              var newState = this.states[indicated.state], change = new connectionstatechange(this.state.state, newState.state, newState.retryDelay, indicated.error || connectionerror[newState.state]);
              if (retryImmediately) {
                var autoReconnect = function() {
                  if (self2.state === self2.states.disconnected) {
                    self2.lastAutoReconnectAttempt = utils.now();
                    self2.requestState({ state: "connecting" });
                  }
                };
                var sinceLast = this.lastAutoReconnectAttempt && utils.now() - this.lastAutoReconnectAttempt + 1;
                if (sinceLast && sinceLast < 1e3) {
                  util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.notifyState()", "Last reconnect attempt was only " + sinceLast + "ms ago, waiting another " + (1e3 - sinceLast) + "ms before trying again");
                  setTimeout(autoReconnect, 1e3 - sinceLast);
                } else {
                  utils.nextTick(autoReconnect);
                }
              } else if (state === "disconnected" || state === "suspended") {
                this.startRetryTimer(newState.retryDelay);
              }
              if (state === "disconnected" && !retryImmediately || state === "suspended" || newState.terminal) {
                utils.nextTick(function() {
                  self2.disconnectAllTransports();
                });
              }
              if (state == "connected" && !this.activeProtocol) {
                util_logger.logAction(util_logger.LOG_ERROR, "ConnectionManager.notifyState()", "Broken invariant: attempted to go into connected state, but there is no active protocol");
              }
              this.enactStateChange(change);
              if (this.state.sendEvents) {
                this.sendQueuedMessages();
              } else if (!this.state.queueEvents) {
                this.realtime.channels.propogateConnectionInterruption(state, change.reason);
                this.failQueuedMessages(change.reason);
              }
            };
            ConnectionManager.prototype.requestState = function(request) {
              var state = request.state, self2 = this;
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.requestState()", "requested state: " + state + "; current state: " + this.state.state);
              if (state == this.state.state)
                return;
              this.cancelTransitionTimer();
              this.cancelRetryTimer();
              this.checkSuspendTimer(state);
              if (state == "connecting" && this.state.state == "connected")
                return;
              if (state == "closing" && this.state.state == "closed")
                return;
              var newState = this.states[state], change = new connectionstatechange(this.state.state, newState.state, null, request.error || connectionerror[newState.state]);
              this.enactStateChange(change);
              if (state == "connecting") {
                utils.nextTick(function() {
                  self2.startConnect();
                });
              }
              if (state == "closing") {
                this.closeImpl();
              }
            };
            ConnectionManager.prototype.startConnect = function() {
              if (this.state !== this.states.connecting) {
                util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.startConnect()", "Must be in connecting state to connect, but was " + this.state.state);
                return;
              }
              var auth = this.realtime.auth, self2 = this;
              var connectCount = ++this.connectCounter;
              var connect = function() {
                self2.checkConnectionStateFreshness();
                self2.getTransportParams(function(transportParams) {
                  if (connectCount !== self2.connectCounter) {
                    return;
                  }
                  self2.connectImpl(transportParams, connectCount);
                });
              };
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.startConnect()", "starting connection");
              this.startSuspendTimer();
              this.startTransitionTimer(this.states.connecting);
              if (auth.method === "basic") {
                connect();
              } else {
                var authCb = function(err) {
                  if (connectCount !== self2.connectCounter) {
                    return;
                  }
                  if (err) {
                    self2.actOnErrorFromAuthorize(err);
                  } else {
                    connect();
                  }
                };
                if (this.errorReason && client_auth.isTokenErr(this.errorReason)) {
                  auth._forceNewToken(null, null, authCb);
                } else {
                  auth._ensureValidAuthCredentials(false, authCb);
                }
              }
            };
            ConnectionManager.prototype.connectImpl = function(transportParams, connectCount) {
              var state = this.state.state;
              if (state !== this.states.connecting.state && state !== this.states.connected.state) {
                util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.connectImpl()", "Must be in connecting state to connect (or connected to upgrade), but was " + state);
              } else if (this.pendingTransports.length) {
                util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.connectImpl()", "Transports " + this.pendingTransports[0].toString() + " currently pending; taking no action");
              } else if (state == this.states.connected.state) {
                this.upgradeIfNeeded(transportParams);
              } else if (this.transports.length > 1 && this.getTransportPreference()) {
                this.connectPreference(transportParams);
              } else {
                this.connectBase(transportParams, connectCount);
              }
            };
            ConnectionManager.prototype.connectPreference = function(transportParams) {
              var preference = this.getTransportPreference(), self2 = this, preferenceTimeoutExpired = false;
              if (!utils.arrIn(this.transports, preference)) {
                this.unpersistTransportPreference();
                this.connectImpl(transportParams);
              }
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.connectPreference()", "Trying to connect with stored transport preference " + preference);
              var preferenceTimeout = setTimeout(function() {
                preferenceTimeoutExpired = true;
                if (!(self2.state.state === self2.states.connected.state)) {
                  util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.connectPreference()", "Shortcircuit connection attempt with " + preference + " failed; clearing preference and trying from scratch");
                  self2.disconnectAllTransports();
                  self2.unpersistTransportPreference();
                }
                self2.connectImpl(transportParams);
              }, this.options.timeouts.preferenceConnectTimeout);
              transportParams.host = self2.httpHosts[0];
              self2.tryATransport(transportParams, preference, function(fatal, transport) {
                clearTimeout(preferenceTimeout);
                if (preferenceTimeoutExpired && transport) {
                  transport.off();
                  transport.disconnect();
                  utils.arrDeleteValue(this.pendingTransports, transport);
                } else if (!transport && !fatal) {
                  self2.unpersistTransportPreference();
                  self2.connectImpl(transportParams);
                }
              });
            };
            ConnectionManager.prototype.connectBase = function(transportParams, connectCount) {
              var self2 = this, giveUp = function(err) {
                self2.notifyState({ state: self2.states.connecting.failState, error: err });
              }, candidateHosts = this.httpHosts.slice(), hostAttemptCb = function(fatal, transport) {
                if (connectCount !== self2.connectCounter) {
                  return;
                }
                if (!transport && !fatal) {
                  tryFallbackHosts();
                }
              };
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.connectBase()", "Trying to connect with base transport " + this.baseTransport);
              var host = candidateHosts.shift();
              if (!host) {
                giveUp(new errorinfo("Unable to connect (no available host)", 80003, 404));
                return;
              }
              transportParams.host = host;
              function tryFallbackHosts() {
                if (!candidateHosts.length) {
                  giveUp(new errorinfo("Unable to connect (and no more fallback hosts to try)", 80003, 404));
                  return;
                }
                util_http.checkConnectivity(function(err, connectivity) {
                  if (connectCount !== self2.connectCounter) {
                    return;
                  }
                  if (err) {
                    giveUp(err);
                    return;
                  }
                  if (!connectivity) {
                    giveUp(new errorinfo("Unable to connect (network unreachable)", 80003, 404));
                    return;
                  }
                  transportParams.host = utils.arrPopRandomElement(candidateHosts);
                  self2.tryATransport(transportParams, self2.baseTransport, hostAttemptCb);
                });
              }
              if (this.forceFallbackHost && candidateHosts.length) {
                this.forceFallbackHost = false;
                tryFallbackHosts();
                return;
              }
              this.tryATransport(transportParams, this.baseTransport, hostAttemptCb);
            };
            ConnectionManager.prototype.getUpgradePossibilities = function() {
              var current = this.activeProtocol.getTransport().shortName;
              var currentPosition = utils.arrIndexOf(this.upgradeTransports, current);
              return this.upgradeTransports.slice(currentPosition + 1);
            };
            ConnectionManager.prototype.upgradeIfNeeded = function(transportParams) {
              var upgradePossibilities = this.getUpgradePossibilities(), self2 = this;
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.upgradeIfNeeded()", "upgrade possibilities: " + utils.inspect(upgradePossibilities));
              if (!upgradePossibilities.length) {
                return;
              }
              utils.arrForEach(upgradePossibilities, function(upgradeTransport) {
                var upgradeTransportParams = self2.createTransportParams(transportParams.host, "upgrade");
                self2.tryATransport(upgradeTransportParams, upgradeTransport, noop);
              });
            };
            ConnectionManager.prototype.closeImpl = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.closeImpl()", "closing connection");
              this.cancelSuspendTimer();
              this.startTransitionTimer(this.states.closing);
              utils.safeArrForEach(this.pendingTransports, function(transport) {
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.closeImpl()", "Closing pending transport: " + transport);
                if (transport)
                  transport.close();
              });
              utils.safeArrForEach(this.proposedTransports, function(transport) {
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.closeImpl()", "Disposing of proposed transport: " + transport);
                if (transport)
                  transport.dispose();
              });
              if (this.activeProtocol) {
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.closeImpl()", "Closing active transport: " + this.activeProtocol.getTransport());
                this.activeProtocol.getTransport().close();
              }
              this.notifyState({ state: "closed" });
            };
            ConnectionManager.prototype.onAuthUpdated = function(tokenDetails, callback) {
              var self2 = this;
              switch (this.state.state) {
                case "connected":
                  util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.onAuthUpdated()", "Sending AUTH message on active transport");
                  if ((this.pendingTransports.length || this.proposedTransports.length) && self2.state !== self2.states.synchronizing) {
                    this.disconnectAllTransports(true);
                    var transportParams = this.activeProtocol.getTransport().params;
                    utils.nextTick(function() {
                      if (self2.state.state === "connected") {
                        self2.upgradeIfNeeded(transportParams);
                      }
                    });
                  }
                  this.activeProtocol.getTransport().onAuthUpdated(tokenDetails);
                  var authMsg = protocolmessage.fromValues({
                    action: actions.AUTH,
                    auth: {
                      accessToken: tokenDetails.token
                    }
                  });
                  this.send(authMsg);
                  var successListener = function() {
                    self2.off(failureListener);
                    callback(null, tokenDetails);
                  };
                  var failureListener = function(stateChange) {
                    if (stateChange.current === "failed") {
                      self2.off(successListener);
                      self2.off(failureListener);
                      callback(stateChange.reason || self2.getStateError());
                    }
                  };
                  this.once("connectiondetails", successListener);
                  this.on("connectionstate", failureListener);
                  break;
                case "connecting":
                  util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.onAuthUpdated()", "Aborting current connection attempts in order to start again with the new auth details");
                  this.disconnectAllTransports();
                default:
                  util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.onAuthUpdated()", "Connection state is " + this.state.state + "; waiting until either connected or failed");
                  var listener = function(stateChange) {
                    switch (stateChange.current) {
                      case "connected":
                        self2.off(listener);
                        callback(null, tokenDetails);
                        break;
                      case "failed":
                      case "closed":
                      case "suspended":
                        self2.off(listener);
                        callback(stateChange.reason || self2.getStateError());
                        break;
                      default:
                        break;
                    }
                  };
                  self2.on("connectionstate", listener);
                  if (this.state.state === "connecting") {
                    self2.startConnect();
                  } else {
                    self2.requestState({ state: "connecting" });
                  }
              }
            };
            ConnectionManager.prototype.disconnectAllTransports = function(exceptActive) {
              util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.disconnectAllTransports()", "Disconnecting all transports" + (exceptActive ? " except the active transport" : ""));
              this.connectCounter++;
              utils.safeArrForEach(this.pendingTransports, function(transport) {
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.disconnectAllTransports()", "Disconnecting pending transport: " + transport);
                if (transport)
                  transport.disconnect();
              });
              this.pendingTransports = [];
              utils.safeArrForEach(this.proposedTransports, function(transport) {
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.disconnectAllTransports()", "Disposing of proposed transport: " + transport);
                if (transport)
                  transport.dispose();
              });
              this.proposedTransports = [];
              if (this.activeProtocol && !exceptActive) {
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.disconnectAllTransports()", "Disconnecting active transport: " + this.activeProtocol.getTransport());
                this.activeProtocol.getTransport().disconnect();
              }
            };
            ConnectionManager.prototype.send = function(msg, queueEvent, callback) {
              callback = callback || noop;
              var state = this.state;
              if (state.sendEvents) {
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.send()", "sending event");
                this.sendImpl(new PendingMessage(msg, callback));
                return;
              }
              var shouldQueue = queueEvent && state.queueEvents || state.forceQueueEvents;
              if (!shouldQueue) {
                var err = "rejecting event, queueEvent was " + queueEvent + ", state was " + state.state;
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.send()", err);
                callback(this.errorReason || new errorinfo(err, 9e4, 400));
                return;
              }
              if (util_logger.shouldLog(util_logger.LOG_MICRO)) {
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.send()", "queueing msg; " + protocolmessage.stringify(msg));
              }
              this.queue(msg, callback);
            };
            ConnectionManager.prototype.sendImpl = function(pendingMessage) {
              var msg = pendingMessage.message;
              if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {
                msg.msgSerial = this.msgSerial++;
                this.setRecoveryKey();
              }
              try {
                this.activeProtocol.send(pendingMessage);
              } catch (e) {
                util_logger.logAction(util_logger.LOG_ERROR, "ConnectionManager.sendImpl()", "Unexpected exception in transport.send(): " + e.stack);
              }
            };
            function bundleWith(dest, src, maxSize) {
              var action;
              if (dest.channel !== src.channel) {
                return false;
              }
              if ((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {
                return false;
              }
              if (action !== src.action) {
                return false;
              }
              var kind = action === actions.PRESENCE ? "presence" : "messages", proposed = dest[kind].concat(src[kind]), size = types_message.getMessagesSize(proposed);
              if (size > maxSize) {
                return false;
              }
              if (!utils.allSame(proposed, "clientId")) {
                return false;
              }
              if (!utils.arrEvery(proposed, function(msg) {
                return !msg.id;
              })) {
                return false;
              }
              dest[kind] = proposed;
              return true;
            }
            ;
            ConnectionManager.prototype.queue = function(msg, callback) {
              util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.queue()", "queueing event");
              var lastQueued = this.queuedMessages.last();
              var maxSize = this.options.maxMessageSize;
              if (lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {
                if (!lastQueued.merged) {
                  lastQueued.callback = util_multicaster([lastQueued.callback]);
                  lastQueued.merged = true;
                }
                lastQueued.callback.push(callback);
              } else {
                this.queuedMessages.push(new PendingMessage(msg, callback));
              }
            };
            ConnectionManager.prototype.sendQueuedMessages = function() {
              util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.sendQueuedMessages()", "sending " + this.queuedMessages.count() + " queued messages");
              var pendingMessage;
              while (pendingMessage = this.queuedMessages.shift())
                this.sendImpl(pendingMessage);
            };
            ConnectionManager.prototype.queuePendingMessages = function(pendingMessages) {
              if (pendingMessages && pendingMessages.length) {
                util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.queuePendingMessages()", "queueing " + pendingMessages.length + " pending messages");
                this.queuedMessages.prepend(pendingMessages);
              }
            };
            ConnectionManager.prototype.failQueuedMessages = function(err) {
              var numQueued = this.queuedMessages.count();
              if (numQueued > 0) {
                util_logger.logAction(util_logger.LOG_ERROR, "ConnectionManager.failQueuedMessages()", "failing " + numQueued + " queued messages, err = " + utils.inspectError(err));
                this.queuedMessages.completeAllMessages(err);
              }
            };
            ConnectionManager.prototype.onChannelMessage = function(message, transport) {
              var onActiveTransport = this.activeProtocol && transport === this.activeProtocol.getTransport(), onUpgradeTransport = utils.arrIn(this.pendingTransports, transport) && this.state == this.states.synchronizing, notControlMsg = message.action === actions.MESSAGE || message.action === actions.PRESENCE;
              if (onActiveTransport || onUpgradeTransport) {
                if (notControlMsg) {
                  var suppressed = this.setConnectionSerial(message);
                  if (suppressed) {
                    return;
                  }
                  if (protocolmessage.isDuplicate(message, this.mostRecentMsg)) {
                    util_logger.logAction(util_logger.LOG_ERROR, "ConnectionManager.onChannelMessage()", "received message with different connectionSerial, but same message id as a previous; discarding; id = " + message.id);
                    return;
                  }
                  this.mostRecentMsg = message;
                }
                this.realtime.channels.onChannelMessage(message);
              } else {
                if (utils.arrIndexOf([actions.ACK, actions.NACK, actions.ERROR], message.action) > -1) {
                  this.realtime.channels.onChannelMessage(message);
                } else {
                  util_logger.logAction(util_logger.LOG_MICRO, "ConnectionManager.onChannelMessage()", "received message " + JSON.stringify(message) + "on defunct transport; discarding");
                }
              }
            };
            ConnectionManager.prototype.ping = function(transport, callback) {
              if (transport) {
                util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.ping()", "transport = " + transport);
                var onTimeout = function() {
                  transport.off("heartbeat", onHeartbeat);
                  callback(new errorinfo("Timeout waiting for heartbeat response", 5e4, 500));
                };
                var pingStart = utils.now(), id = utils.cheapRandStr();
                var onHeartbeat = function(responseId) {
                  if (responseId === id) {
                    transport.off("heartbeat", onHeartbeat);
                    clearTimeout(timer);
                    var responseTime = utils.now() - pingStart;
                    callback(null, responseTime);
                  }
                };
                var timer = setTimeout(onTimeout, this.options.timeouts.realtimeRequestTimeout);
                transport.on("heartbeat", onHeartbeat);
                transport.ping(id);
                return;
              }
              if (this.state.state !== "connected") {
                callback(new errorinfo("Unable to ping service; not connected", 4e4, 400));
                return;
              }
              var completed = false, self2 = this;
              var onPingComplete = function(err, responseTime) {
                self2.off("transport.active", onTransportActive);
                if (!completed) {
                  completed = true;
                  callback(err, responseTime);
                }
              };
              var onTransportActive = function() {
                if (!completed) {
                  completed = true;
                  utils.nextTick(function() {
                    self2.ping(null, callback);
                  });
                }
              };
              this.on("transport.active", onTransportActive);
              this.ping(this.activeProtocol.getTransport(), onPingComplete);
            };
            ConnectionManager.prototype.abort = function(error) {
              this.activeProtocol.getTransport().fail(error);
            };
            ConnectionManager.prototype.registerProposedTransport = function(transport) {
              this.proposedTransports.push(transport);
            };
            ConnectionManager.prototype.getTransportPreference = function() {
              return this.transportPreference || haveWebStorage && webstorage.get(transportPreferenceName);
            };
            ConnectionManager.prototype.persistTransportPreference = function(transport) {
              if (utils.arrIn(util_defaults.upgradeTransports, transport.shortName)) {
                this.transportPreference = transport.shortName;
                if (haveWebStorage) {
                  webstorage.set(transportPreferenceName, transport.shortName);
                }
              }
            };
            ConnectionManager.prototype.unpersistTransportPreference = function() {
              this.transportPreference = null;
              if (haveWebStorage) {
                webstorage.remove(transportPreferenceName);
              }
            };
            ConnectionManager.prototype.actOnErrorFromAuthorize = function(err) {
              if (err.code === 40171) {
                this.notifyState({ state: "failed", error: err });
              } else if (err.statusCode === 403) {
                var msg = "Client configured authentication provider returned 403; failing the connection";
                util_logger.logAction(util_logger.LOG_ERROR, "ConnectionManager.actOnErrorFromAuthorize()", msg);
                this.notifyState({ state: "failed", error: new errorinfo(msg, 80019, 403, err) });
              } else {
                var msg = "Client configured authentication provider request failed";
                util_logger.logAction(util_logger.LOG_MINOR, "ConnectionManager.actOnErrorFromAuthorize", msg);
                this.notifyState({ state: this.state.failState, error: new errorinfo(msg, 80019, 401, err) });
              }
            };
            ConnectionManager.prototype.onConnectionDetailsUpdate = function(connectionDetails, transport) {
              if (!connectionDetails) {
                return;
              }
              this.connectionDetails = connectionDetails;
              if (connectionDetails.maxMessageSize) {
                this.options.maxMessageSize = connectionDetails.maxMessageSize;
              }
              var clientId = connectionDetails.clientId;
              if (clientId) {
                var err = this.realtime.auth._uncheckedSetClientId(clientId);
                if (err) {
                  util_logger.logAction(util_logger.LOG_ERROR, "ConnectionManager.onConnectionDetailsUpdate()", err.message);
                  transport.fail(err);
                  return;
                }
              }
              var connectionStateTtl = connectionDetails.connectionStateTtl;
              if (connectionStateTtl) {
                this.connectionStateTtl = connectionStateTtl;
              }
              this.maxIdleInterval = connectionDetails.maxIdleInterval;
              this.emit("connectiondetails", connectionDetails);
            };
            return ConnectionManager;
          }();
          var connectionmanager = connectionmanager_ConnectionManager;
          var connection_Connection = function() {
            function noop() {
            }
            function Connection(ably, options) {
              eventemitter.call(this);
              this.ably = ably;
              this.connectionManager = new connectionmanager(ably, options);
              this.state = this.connectionManager.state.state;
              this.key = void 0;
              this.id = void 0;
              this.serial = void 0;
              this.timeSerial = void 0;
              this.recoveryKey = void 0;
              this.errorReason = null;
              var self2 = this;
              this.connectionManager.on("connectionstate", function(stateChange) {
                var state = self2.state = stateChange.current;
                utils.nextTick(function() {
                  self2.emit(state, stateChange);
                });
              });
              this.connectionManager.on("update", function(stateChange) {
                utils.nextTick(function() {
                  self2.emit("update", stateChange);
                });
              });
            }
            utils.inherits(Connection, eventemitter);
            Connection.prototype.whenState = function(state, listener) {
              return eventemitter.prototype.whenState.call(this, state, this.state, listener, new connectionstatechange(void 0, state));
            };
            Connection.prototype.connect = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "Connection.connect()", "");
              this.connectionManager.requestState({ state: "connecting" });
            };
            Connection.prototype.ping = function(callback) {
              util_logger.logAction(util_logger.LOG_MINOR, "Connection.ping()", "");
              if (!callback) {
                if (this.ably.options.promises) {
                  return utils.promisify(this, "ping", arguments);
                }
                callback = noop;
              }
              this.connectionManager.ping(null, callback);
            };
            Connection.prototype.close = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "Connection.close()", "connectionKey = " + this.key);
              this.connectionManager.requestState({ state: "closing" });
            };
            return Connection;
          }();
          var client_connection = connection_Connection;
          var ChannelStateChange = function() {
            function ChannelStateChange2(previous, current, resumed, reason) {
              this.previous = previous;
              this.current = current;
              if (current === "attached")
                this.resumed = resumed;
              if (reason)
                this.reason = reason;
            }
            return ChannelStateChange2;
          }();
          var channelstatechange = ChannelStateChange;
          var realtimepresence_RealtimePresence = function() {
            var noop = function() {
            };
            function memberKey(item) {
              return item.clientId + ":" + item.connectionId;
            }
            function getClientId(realtimePresence) {
              return realtimePresence.channel.realtime.auth.clientId;
            }
            function isAnonymousOrWildcard(realtimePresence) {
              var realtime = realtimePresence.channel.realtime;
              var clientId = realtime.auth.clientId;
              return (!clientId || clientId === "*") && realtime.connection.state === "connected";
            }
            function waitAttached(channel, callback, action) {
              switch (channel.state) {
                case "attached":
                case "suspended":
                  action();
                  break;
                case "initialized":
                case "detached":
                case "detaching":
                case "attaching":
                  channel.attach(function(err) {
                    if (err)
                      callback(err);
                    else
                      action();
                  });
                  break;
                default:
                  callback(errorinfo.fromValues(realtimechannel.invalidStateError(channel.state)));
              }
            }
            function RealtimePresence(channel, options) {
              client_presence.call(this, channel);
              this.syncComplete = false;
              this.members = new PresenceMap(this);
              this._myMembers = new PresenceMap(this);
              this.subscriptions = new eventemitter();
              this.pendingPresence = [];
            }
            utils.inherits(RealtimePresence, client_presence);
            RealtimePresence.prototype.enter = function(data, callback) {
              if (isAnonymousOrWildcard(this)) {
                throw new errorinfo("clientId must be specified to enter a presence channel", 40012, 400);
              }
              return this._enterOrUpdateClient(void 0, data, "enter", callback);
            };
            RealtimePresence.prototype.update = function(data, callback) {
              if (isAnonymousOrWildcard(this)) {
                throw new errorinfo("clientId must be specified to update presence data", 40012, 400);
              }
              return this._enterOrUpdateClient(void 0, data, "update", callback);
            };
            RealtimePresence.prototype.enterClient = function(clientId, data, callback) {
              return this._enterOrUpdateClient(clientId, data, "enter", callback);
            };
            RealtimePresence.prototype.updateClient = function(clientId, data, callback) {
              return this._enterOrUpdateClient(clientId, data, "update", callback);
            };
            RealtimePresence.prototype._enterOrUpdateClient = function(clientId, data, action, callback) {
              if (!callback) {
                if (typeof data === "function") {
                  callback = data;
                  data = null;
                } else {
                  if (this.channel.realtime.options.promises) {
                    return utils.promisify(this, "_enterOrUpdateClient", [clientId, data, action]);
                  }
                  callback = noop;
                }
              }
              var channel = this.channel;
              if (!channel.connectionManager.activeState()) {
                callback(channel.connectionManager.getError());
                return;
              }
              util_logger.logAction(util_logger.LOG_MICRO, "RealtimePresence." + action + "Client()", "channel = " + channel.name + ", client = " + (clientId || "(implicit) " + getClientId(this)));
              var presence = presencemessage.fromValues({
                action,
                data
              });
              if (clientId) {
                presence.clientId = clientId;
              }
              var self2 = this;
              presencemessage.encode(presence, channel.channelOptions, function(err) {
                if (err) {
                  callback(err);
                  return;
                }
                switch (channel.state) {
                  case "attached":
                    channel.sendPresence(presence, callback);
                    break;
                  case "initialized":
                  case "detached":
                    channel.attach();
                  case "attaching":
                    self2.pendingPresence.push({
                      presence,
                      callback
                    });
                    break;
                  default:
                    err = new errorinfo("Unable to " + action + " presence channel while in " + channel.state + " state", 90001);
                    err.code = 90001;
                    callback(err);
                }
              });
            };
            RealtimePresence.prototype.leave = function(data, callback) {
              if (isAnonymousOrWildcard(this)) {
                throw new errorinfo("clientId must have been specified to enter or leave a presence channel", 40012, 400);
              }
              return this.leaveClient(void 0, data, callback);
            };
            RealtimePresence.prototype.leaveClient = function(clientId, data, callback) {
              if (!callback) {
                if (typeof data === "function") {
                  callback = data;
                  data = null;
                } else {
                  if (this.channel.realtime.options.promises) {
                    return utils.promisify(this, "leaveClient", [clientId, data]);
                  }
                  callback = noop;
                }
              }
              var channel = this.channel;
              if (!channel.connectionManager.activeState()) {
                callback(channel.connectionManager.getError());
                return;
              }
              util_logger.logAction(util_logger.LOG_MICRO, "RealtimePresence.leaveClient()", "leaving; channel = " + this.channel.name + ", client = " + clientId);
              var presence = presencemessage.fromValues({
                action: "leave",
                data
              });
              if (clientId) {
                presence.clientId = clientId;
              }
              switch (channel.state) {
                case "attached":
                  channel.sendPresence(presence, callback);
                  break;
                case "attaching":
                  this.pendingPresence.push({
                    presence,
                    callback
                  });
                  break;
                case "initialized":
                case "failed":
                  var err = new errorinfo("Unable to leave presence channel (incompatible state)", 90001);
                  callback(err);
                  break;
                default:
                  callback(connectionerror.failed);
              }
            };
            RealtimePresence.prototype.get = function() {
              var args = Array.prototype.slice.call(arguments);
              if (args.length == 1 && typeof args[0] == "function")
                args.unshift(null);
              var params = args[0], callback = args[1], waitForSync = !params || ("waitForSync" in params ? params.waitForSync : true);
              if (!callback) {
                if (this.channel.realtime.options.promises) {
                  return utils.promisify(this, "get", args);
                }
                callback = noop;
              }
              function returnMembers(members) {
                callback(null, params ? members.list(params) : members.values());
              }
              if (this.channel.state === "suspended") {
                if (waitForSync) {
                  callback(errorinfo.fromValues({
                    statusCode: 400,
                    code: 91005,
                    message: "Presence state is out of sync due to channel being in the SUSPENDED state"
                  }));
                } else {
                  returnMembers(this.members);
                }
                return;
              }
              var self2 = this;
              waitAttached(this.channel, callback, function() {
                var members = self2.members;
                if (waitForSync) {
                  members.waitSync(function() {
                    returnMembers(members);
                  });
                } else {
                  returnMembers(members);
                }
              });
            };
            RealtimePresence.prototype.history = function(params, callback) {
              util_logger.logAction(util_logger.LOG_MICRO, "RealtimePresence.history()", "channel = " + this.name);
              if (callback === void 0) {
                if (typeof params == "function") {
                  callback = params;
                  params = null;
                } else {
                  if (this.channel.realtime.options.promises) {
                    return utils.promisify(this, "history", arguments);
                  }
                  callback = noop;
                }
              }
              if (params && params.untilAttach) {
                if (this.channel.state === "attached") {
                  delete params.untilAttach;
                  params.from_serial = this.channel.properties.attachSerial;
                } else {
                  callback(new errorinfo("option untilAttach requires the channel to be attached, was: " + this.channel.state, 4e4, 400));
                }
              }
              client_presence.prototype._history.call(this, params, callback);
            };
            RealtimePresence.prototype.setPresence = function(presenceSet, isSync, syncChannelSerial) {
              util_logger.logAction(util_logger.LOG_MICRO, "RealtimePresence.setPresence()", "received presence for " + presenceSet.length + " participants; syncChannelSerial = " + syncChannelSerial);
              var syncCursor, match, members = this.members, myMembers = this._myMembers, broadcastMessages = [], connId = this.channel.connectionManager.connectionId;
              if (isSync) {
                this.members.startSync();
                if (syncChannelSerial && (match = syncChannelSerial.match(/^[\w\-]+:(.*)$/))) {
                  syncCursor = match[1];
                }
              }
              for (var i = 0; i < presenceSet.length; i++) {
                var presence = presencemessage.fromValues(presenceSet[i]);
                switch (presence.action) {
                  case "leave":
                    if (members.remove(presence)) {
                      broadcastMessages.push(presence);
                    }
                    if (presence.connectionId === connId && !presence.isSynthesized()) {
                      myMembers.remove(presence);
                    }
                    break;
                  case "enter":
                  case "present":
                  case "update":
                    if (members.put(presence)) {
                      broadcastMessages.push(presence);
                    }
                    if (presence.connectionId === connId) {
                      myMembers.put(presence);
                    }
                    break;
                }
              }
              if (isSync && !syncCursor) {
                members.endSync();
                this._ensureMyMembersPresent();
                this.channel.setInProgress(realtimechannel.progressOps.sync, false);
                this.channel.syncChannelSerial = null;
              }
              for (var i = 0; i < broadcastMessages.length; i++) {
                var presence = broadcastMessages[i];
                this.subscriptions.emit(presence.action, presence);
              }
            };
            RealtimePresence.prototype.onAttached = function(hasPresence) {
              util_logger.logAction(util_logger.LOG_MINOR, "RealtimePresence.onAttached()", "channel = " + this.channel.name + ", hasPresence = " + hasPresence);
              if (hasPresence) {
                this.members.startSync();
              } else {
                this._synthesizeLeaves(this.members.values());
                this.members.clear();
                this._ensureMyMembersPresent();
              }
              var pendingPresence = this.pendingPresence, pendingPresCount = pendingPresence.length;
              if (pendingPresCount) {
                this.pendingPresence = [];
                var presenceArray = [];
                var multicaster = util_multicaster();
                util_logger.logAction(util_logger.LOG_MICRO, "RealtimePresence.onAttached", "sending " + pendingPresCount + " queued presence messages");
                for (var i = 0; i < pendingPresCount; i++) {
                  var event = pendingPresence[i];
                  presenceArray.push(event.presence);
                  multicaster.push(event.callback);
                }
                this.channel.sendPresence(presenceArray, multicaster);
              }
            };
            RealtimePresence.prototype.actOnChannelState = function(state, hasPresence, err) {
              switch (state) {
                case "attached":
                  this.onAttached(hasPresence);
                  break;
                case "detached":
                case "failed":
                  this._clearMyMembers();
                  this.members.clear();
                case "suspended":
                  this.failPendingPresence(err);
                  break;
              }
            };
            RealtimePresence.prototype.failPendingPresence = function(err) {
              if (this.pendingPresence.length) {
                util_logger.logAction(util_logger.LOG_MINOR, "RealtimeChannel.failPendingPresence", "channel; name = " + this.channel.name + ", err = " + utils.inspectError(err));
                for (var i = 0; i < this.pendingPresence.length; i++)
                  try {
                    this.pendingPresence[i].callback(err);
                  } catch (e) {
                  }
                this.pendingPresence = [];
              }
            };
            RealtimePresence.prototype._clearMyMembers = function() {
              this._myMembers.clear();
            };
            RealtimePresence.prototype._ensureMyMembersPresent = function() {
              var self2 = this, members = this.members, myMembers = this._myMembers, reenterCb = function(err) {
                if (err) {
                  var msg = "Presence auto-re-enter failed: " + err.toString();
                  var wrappedErr = new errorinfo(msg, 91004, 400);
                  util_logger.logAction(util_logger.LOG_ERROR, "RealtimePresence._ensureMyMembersPresent()", msg);
                  var change = new channelstatechange(self2.channel.state, self2.channel.state, true, wrappedErr);
                  self2.channel.emit("update", change);
                }
              };
              for (var memberKey2 in myMembers.map) {
                if (!(memberKey2 in members.map)) {
                  var entry = myMembers.map[memberKey2];
                  util_logger.logAction(util_logger.LOG_MICRO, "RealtimePresence._ensureMyMembersPresent()", 'Auto-reentering clientId "' + entry.clientId + '" into the presence set');
                  this._enterOrUpdateClient(entry.clientId, entry.data, "enter", reenterCb);
                  delete myMembers.map[memberKey2];
                }
              }
            };
            RealtimePresence.prototype._synthesizeLeaves = function(items) {
              var subscriptions = this.subscriptions;
              utils.arrForEach(items, function(item) {
                var presence = presencemessage.fromValues({
                  action: "leave",
                  connectionId: item.connectionId,
                  clientId: item.clientId,
                  data: item.data,
                  encoding: item.encoding,
                  timestamp: utils.now()
                });
                subscriptions.emit("leave", presence);
              });
            };
            RealtimePresence.prototype.on = function() {
              util_logger.deprecated("presence.on", "presence.subscribe");
              this.subscribe.apply(this, arguments);
            };
            RealtimePresence.prototype.off = function() {
              util_logger.deprecated("presence.off", "presence.unsubscribe");
              this.unsubscribe.apply(this, arguments);
            };
            RealtimePresence.prototype.subscribe = function() {
              var args = realtimechannel.processListenerArgs(arguments);
              var event = args[0];
              var listener = args[1];
              var callback = args[2];
              var channel = this.channel;
              var self2 = this;
              if (!callback) {
                if (this.channel.realtime.options.promises) {
                  return utils.promisify(this, "subscribe", [event, listener]);
                }
                callback = noop;
              }
              if (channel.state === "failed") {
                callback(errorinfo.fromValues(realtimechannel.invalidStateError("failed")));
                return;
              }
              this.subscriptions.on(event, listener);
              channel.attach(callback);
            };
            RealtimePresence.prototype.unsubscribe = function() {
              var args = realtimechannel.processListenerArgs(arguments);
              var event = args[0];
              var listener = args[1];
              this.subscriptions.off(event, listener);
            };
            function PresenceMap(presence) {
              eventemitter.call(this);
              this.presence = presence;
              this.map = Object.create(null);
              this.syncInProgress = false;
              this.residualMembers = null;
            }
            utils.inherits(PresenceMap, eventemitter);
            PresenceMap.prototype.get = function(key) {
              return this.map[key];
            };
            PresenceMap.prototype.getClient = function(clientId) {
              var map = this.map, result = [];
              for (var key in map) {
                var item = map[key];
                if (item.clientId == clientId && item.action != "absent")
                  result.push(item);
              }
              return result;
            };
            PresenceMap.prototype.list = function(params) {
              var map = this.map, clientId = params && params.clientId, connectionId = params && params.connectionId, result = [];
              for (var key in map) {
                var item = map[key];
                if (item.action === "absent")
                  continue;
                if (clientId && clientId != item.clientId)
                  continue;
                if (connectionId && connectionId != item.connectionId)
                  continue;
                result.push(item);
              }
              return result;
            };
            function newerThan(item, existing) {
              if (item.isSynthesized() || existing.isSynthesized()) {
                return item.timestamp > existing.timestamp;
              }
              var itemOrderings = item.parseId(), existingOrderings = existing.parseId();
              if (itemOrderings.msgSerial === existingOrderings.msgSerial) {
                return itemOrderings.index > existingOrderings.index;
              } else {
                return itemOrderings.msgSerial > existingOrderings.msgSerial;
              }
            }
            PresenceMap.prototype.put = function(item) {
              if (item.action === "enter" || item.action === "update") {
                item = presencemessage.fromValues(item);
                item.action = "present";
              }
              var map = this.map, key = memberKey(item);
              if (this.residualMembers)
                delete this.residualMembers[key];
              var existingItem = map[key];
              if (existingItem && !newerThan(item, existingItem)) {
                return false;
              }
              map[key] = item;
              return true;
            };
            PresenceMap.prototype.values = function() {
              var map = this.map, result = [];
              for (var key in map) {
                var item = map[key];
                if (item.action != "absent")
                  result.push(item);
              }
              return result;
            };
            PresenceMap.prototype.remove = function(item) {
              var map = this.map, key = memberKey(item);
              var existingItem = map[key];
              if (existingItem && !newerThan(item, existingItem)) {
                return false;
              }
              if (this.syncInProgress) {
                item = presencemessage.fromValues(item);
                item.action = "absent";
                map[key] = item;
              } else {
                delete map[key];
              }
              return true;
            };
            PresenceMap.prototype.startSync = function() {
              var map = this.map, syncInProgress = this.syncInProgress;
              util_logger.logAction(util_logger.LOG_MINOR, "PresenceMap.startSync()", "channel = " + this.presence.channel.name + "; syncInProgress = " + syncInProgress);
              if (!this.syncInProgress) {
                this.residualMembers = utils.copy(map);
                this.setInProgress(true);
              }
            };
            PresenceMap.prototype.endSync = function() {
              var map = this.map, syncInProgress = this.syncInProgress;
              util_logger.logAction(util_logger.LOG_MINOR, "PresenceMap.endSync()", "channel = " + this.presence.channel.name + "; syncInProgress = " + syncInProgress);
              if (syncInProgress) {
                for (var memberKey2 in map) {
                  var entry = map[memberKey2];
                  if (entry.action === "absent") {
                    delete map[memberKey2];
                  }
                }
                this.presence._synthesizeLeaves(utils.valuesArray(this.residualMembers));
                for (var memberKey2 in this.residualMembers) {
                  delete map[memberKey2];
                }
                this.residualMembers = null;
                this.setInProgress(false);
              }
              this.emit("sync");
            };
            PresenceMap.prototype.waitSync = function(callback) {
              var syncInProgress = this.syncInProgress;
              util_logger.logAction(util_logger.LOG_MINOR, "PresenceMap.waitSync()", "channel = " + this.presence.channel.name + "; syncInProgress = " + syncInProgress);
              if (!syncInProgress) {
                callback();
                return;
              }
              this.once("sync", callback);
            };
            PresenceMap.prototype.clear = function(callback) {
              this.map = {};
              this.setInProgress(false);
              this.residualMembers = null;
            };
            PresenceMap.prototype.setInProgress = function(inProgress) {
              util_logger.logAction(util_logger.LOG_MICRO, "PresenceMap.setInProgress()", "inProgress = " + inProgress);
              this.syncInProgress = inProgress;
              this.presence.syncComplete = !inProgress;
            };
            return RealtimePresence;
          }();
          var realtimepresence = realtimepresence_RealtimePresence;
          var realtimechannel_RealtimeChannel = function() {
            var actions = protocolmessage.Action;
            var noop = function() {
            };
            var statechangeOp = "statechange";
            var syncOp = "sync";
            function RealtimeChannel(realtime, name, options) {
              util_logger.logAction(util_logger.LOG_MINOR, "RealtimeChannel()", "started; name = " + name);
              client_channel.call(this, realtime, name, options);
              this.realtime = realtime;
              this.presence = new realtimepresence(this, realtime.options);
              this.connectionManager = realtime.connection.connectionManager;
              this.state = "initialized";
              this.subscriptions = new eventemitter();
              this.syncChannelSerial = void 0;
              this.properties = {
                attachSerial: void 0
              };
              this.setOptions(options);
              this.errorReason = null;
              this._requestedFlags = null;
              this._mode = null;
              this._attachedMsgIndicator = false;
              this._attachResume = false;
              this._decodingContext = {
                channelOptions: this.channelOptions,
                plugins: realtime.options.plugins || {},
                baseEncodedPreviousPayload: void 0
              };
              this._lastPayload = {
                messageId: null,
                protocolMessageChannelSerial: null,
                decodeFailureRecoveryInProgress: null
              };
              this._allChannelChanges = new eventemitter();
            }
            utils.inherits(RealtimeChannel, client_channel);
            RealtimeChannel.invalidStateError = function(state) {
              return {
                statusCode: 400,
                code: 90001,
                message: "Channel operation failed as channel state is " + state
              };
            };
            RealtimeChannel.progressOps = {
              statechange: statechangeOp,
              sync: syncOp
            };
            RealtimeChannel.processListenerArgs = function(args) {
              args = Array.prototype.slice.call(args);
              if (typeof args[0] === "function") {
                args.unshift(null);
              }
              if (args[args.length - 1] == void 0) {
                args.pop();
              }
              return args;
            };
            RealtimeChannel.prototype.setOptions = function(options, callback) {
              if (!callback) {
                if (this.rest.options.promises) {
                  return utils.promisify(this, "setOptions", arguments);
                }
                callback = function(err2) {
                  if (err2) {
                    util_logger.logAction(util_logger.LOG_ERROR, "RealtimeChannel.setOptions()", "Set options failed: " + err2.toString());
                  }
                };
              }
              var err = validateChannelOptions(options);
              if (err) {
                callback(err);
                return;
              }
              client_channel.prototype.setOptions.call(this, options);
              if (this._decodingContext)
                this._decodingContext.channelOptions = this.channelOptions;
              if (this._shouldReattachToSetOptions(options)) {
                this.attachImpl();
                this._allChannelChanges.once(function(stateChange) {
                  switch (this.event) {
                    case "update":
                    case "attached":
                      callback(null);
                      return;
                    default:
                      callback(stateChange.reason);
                      return;
                  }
                });
              } else {
                callback();
              }
            };
            function validateChannelOptions(options) {
              if (options && "params" in options && !utils.isObject(options.params)) {
                return new errorinfo("options.params must be an object", 4e4, 400);
              }
              if (options && "modes" in options) {
                if (!utils.isArray(options.modes)) {
                  return new errorinfo("options.modes must be an array", 4e4, 400);
                }
                for (var i = 0; i < options.modes.length; i++) {
                  var currentMode = options.modes[i];
                  if (!currentMode || typeof currentMode !== "string" || !utils.arrIn(protocolmessage.channelModes, String.prototype.toUpperCase.call(currentMode))) {
                    return new errorinfo("Invalid channel mode: " + currentMode, 4e4, 400);
                  }
                }
              }
            }
            RealtimeChannel.prototype._shouldReattachToSetOptions = function(options) {
              return (this.state === "attached" || this.state === "attaching") && (options.params || options.modes);
            };
            RealtimeChannel.prototype.publish = function() {
              var argCount = arguments.length, messages = arguments[0], callback = arguments[argCount - 1];
              if (typeof callback !== "function") {
                if (this.realtime.options.promises) {
                  return utils.promisify(this, "publish", arguments);
                }
                callback = noop;
                ++argCount;
              }
              if (!this.connectionManager.activeState()) {
                callback(this.connectionManager.getError());
                return;
              }
              if (argCount == 2) {
                if (utils.isObject(messages))
                  messages = [types_message.fromValues(messages)];
                else if (utils.isArray(messages))
                  messages = types_message.fromValuesArray(messages);
                else
                  throw new errorinfo("The single-argument form of publish() expects a message object or an array of message objects", 40013, 400);
              } else {
                messages = [types_message.fromValues({ name: arguments[0], data: arguments[1] })];
              }
              var self2 = this, maxMessageSize = this.realtime.options.maxMessageSize;
              types_message.encodeArray(messages, this.channelOptions, function(err) {
                if (err) {
                  callback(err);
                  return;
                }
                var size = types_message.getMessagesSize(messages);
                if (size > maxMessageSize) {
                  callback(new errorinfo("Maximum size of messages that can be published at once exceeded ( was " + size + " bytes; limit is " + maxMessageSize + " bytes)", 40009, 400));
                  return;
                }
                self2._publish(messages, callback);
              });
            };
            RealtimeChannel.prototype._publish = function(messages, callback) {
              util_logger.logAction(util_logger.LOG_MICRO, "RealtimeChannel.publish()", "message count = " + messages.length);
              var state = this.state;
              switch (state) {
                case "failed":
                case "suspended":
                  callback(errorinfo.fromValues(RealtimeChannel.invalidStateError(state)));
                  break;
                default:
                  util_logger.logAction(util_logger.LOG_MICRO, "RealtimeChannel.publish()", "sending message; channel state is " + state);
                  var msg = new protocolmessage();
                  msg.action = actions.MESSAGE;
                  msg.channel = this.name;
                  msg.messages = messages;
                  this.sendMessage(msg, callback);
                  break;
              }
            };
            RealtimeChannel.prototype.onEvent = function(messages) {
              util_logger.logAction(util_logger.LOG_MICRO, "RealtimeChannel.onEvent()", "received message");
              var subscriptions = this.subscriptions;
              for (var i = 0; i < messages.length; i++) {
                var message = messages[i];
                subscriptions.emit(message.name, message);
              }
            };
            RealtimeChannel.prototype.attach = function(flags, callback) {
              if (typeof flags === "function") {
                callback = flags;
                flags = null;
              }
              if (!callback) {
                if (this.realtime.options.promises) {
                  return utils.promisify(this, "attach", arguments);
                }
                callback = function(err) {
                  if (err) {
                    util_logger.logAction(util_logger.LOG_MAJOR, "RealtimeChannel.attach()", "Channel attach failed: " + err.toString());
                  }
                };
              }
              if (flags) {
                util_logger.deprecated("channel.attach() with flags", "channel.setOptions() with channelOptions.params");
                this._requestedFlags = flags;
              } else if (this.state === "attached") {
                callback();
                return;
              }
              this._attach(false, null, callback);
            };
            RealtimeChannel.prototype._attach = function(forceReattach, attachReason, callback) {
              if (!callback) {
                callback = function(err) {
                  if (err) {
                    util_logger.logAction(util_logger.LOG_ERROR, "RealtimeChannel._attach()", "Channel attach failed: " + err.toString());
                  }
                };
              }
              var connectionManager = this.connectionManager;
              if (!connectionManager.activeState()) {
                callback(connectionManager.getError());
                return;
              }
              if (this.state !== "attaching" || forceReattach) {
                this.requestState("attaching", attachReason);
              }
              this.once(function(stateChange) {
                switch (this.event) {
                  case "attached":
                    callback();
                    break;
                  case "detached":
                  case "suspended":
                  case "failed":
                    callback(stateChange.reason || connectionManager.getError() || new errorinfo("Unable to attach; reason unknown; state = " + this.event, 9e4, 500));
                    break;
                  case "detaching":
                    callback(new errorinfo("Attach request superseded by a subsequent detach request", 9e4, 409));
                    break;
                }
              });
            };
            RealtimeChannel.prototype.attachImpl = function() {
              util_logger.logAction(util_logger.LOG_MICRO, "RealtimeChannel.attachImpl()", "sending ATTACH message");
              this.setInProgress(statechangeOp, true);
              var attachMsg = protocolmessage.fromValues({ action: actions.ATTACH, channel: this.name, params: this.channelOptions.params });
              if (this._requestedFlags) {
                attachMsg.encodeModesToFlags(this._requestedFlags);
              } else if (this.channelOptions.modes) {
                attachMsg.encodeModesToFlags(utils.allToUpperCase(this.channelOptions.modes));
              }
              if (this._attachResume) {
                attachMsg.setFlag("ATTACH_RESUME");
              }
              if (this._lastPayload.decodeFailureRecoveryInProgress) {
                attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;
              }
              this.sendMessage(attachMsg, noop);
            };
            RealtimeChannel.prototype.detach = function(callback) {
              if (!callback) {
                if (this.realtime.options.promises) {
                  return utils.promisify(this, "detach", arguments);
                }
                callback = noop;
              }
              var connectionManager = this.connectionManager;
              if (!connectionManager.activeState()) {
                callback(connectionManager.getError());
                return;
              }
              switch (this.state) {
                case "suspended":
                  this.notifyState("detached");
                  callback();
                  break;
                case "detached":
                  callback();
                  break;
                case "failed":
                  callback(new errorinfo("Unable to detach; channel state = failed", 90001, 400));
                  break;
                default:
                  this.requestState("detaching");
                case "detaching":
                  this.once(function(stateChange) {
                    switch (this.event) {
                      case "detached":
                        callback();
                        break;
                      case "attached":
                      case "suspended":
                      case "failed":
                        callback(stateChange.reason || connectionManager.getError() || new errorinfo("Unable to detach; reason unknown; state = " + this.event, 9e4, 500));
                        break;
                      case "attaching":
                        callback(new errorinfo("Detach request superseded by a subsequent attach request", 9e4, 409));
                        break;
                    }
                  });
              }
            };
            RealtimeChannel.prototype.detachImpl = function(callback) {
              util_logger.logAction(util_logger.LOG_MICRO, "RealtimeChannel.detach()", "sending DETACH message");
              this.setInProgress(statechangeOp, true);
              var msg = protocolmessage.fromValues({ action: actions.DETACH, channel: this.name });
              this.sendMessage(msg, callback || noop);
            };
            RealtimeChannel.prototype.subscribe = function() {
              var args = RealtimeChannel.processListenerArgs(arguments);
              var event = args[0];
              var listener = args[1];
              var callback = args[2];
              if (!callback) {
                if (this.realtime.options.promises) {
                  return utils.promisify(this, "subscribe", [event, listener]);
                }
                callback = noop;
              }
              if (this.state === "failed") {
                callback(errorinfo.fromValues(RealtimeChannel.invalidStateError("failed")));
                return;
              }
              this.subscriptions.on(event, listener);
              return this.attach(callback);
            };
            RealtimeChannel.prototype.unsubscribe = function() {
              var args = RealtimeChannel.processListenerArgs(arguments);
              var event = args[0];
              var listener = args[1];
              this.subscriptions.off(event, listener);
            };
            RealtimeChannel.prototype.sync = function() {
              switch (this.state) {
                case "initialized":
                case "detaching":
                case "detached":
                  throw new errorinfo("Unable to sync to channel; not attached", 4e4);
                default:
              }
              var connectionManager = this.connectionManager;
              if (!connectionManager.activeState()) {
                throw connectionManager.getError();
              }
              var syncMessage = protocolmessage.fromValues({ action: actions.SYNC, channel: this.name });
              if (this.syncChannelSerial) {
                syncMessage.channelSerial = this.syncChannelSerial;
              }
              connectionManager.send(syncMessage);
            };
            RealtimeChannel.prototype.sendMessage = function(msg, callback) {
              this.connectionManager.send(msg, this.realtime.options.queueMessages, callback);
            };
            RealtimeChannel.prototype.sendPresence = function(presence, callback) {
              var msg = protocolmessage.fromValues({
                action: actions.PRESENCE,
                channel: this.name,
                presence: utils.isArray(presence) ? presencemessage.fromValuesArray(presence) : [presencemessage.fromValues(presence)]
              });
              this.sendMessage(msg, callback);
            };
            RealtimeChannel.prototype.onMessage = function(message) {
              var syncChannelSerial, isSync = false;
              switch (message.action) {
                case actions.ATTACHED:
                  this._attachedMsgIndicator = true;
                  this.properties.attachSerial = message.channelSerial;
                  this._mode = message.getMode();
                  this.params = message.params || {};
                  var modesFromFlags = message.decodeModesFromFlags();
                  this.modes = modesFromFlags && utils.allToLowerCase(modesFromFlags) || void 0;
                  var resumed = message.hasFlag("RESUMED");
                  var hasPresence = message.hasFlag("HAS_PRESENCE");
                  if (this.state === "attached") {
                    this.setInProgress(statechangeOp, false);
                    if (!resumed) {
                      this.presence.onAttached(hasPresence);
                    }
                    var change = new channelstatechange(this.state, this.state, resumed, message.error);
                    this._allChannelChanges.emit("update", change);
                    if (!resumed || this.channelOptions.updateOnAttached) {
                      this.emit("update", change);
                    }
                  } else if (this.state === "detaching") {
                    this.checkPendingState();
                  } else {
                    this.notifyState("attached", message.error, resumed, hasPresence);
                  }
                  break;
                case actions.DETACHED:
                  var err = message.error ? errorinfo.fromValues(message.error) : new errorinfo("Channel detached", 90001, 404);
                  if (this.state === "detaching") {
                    if (this.connectionManager.mostRecentMsg && this.connectionManager.mostRecentMsg.channel === this.name) {
                      this.connectionManager.mostRecentMsg = null;
                    }
                    this.notifyState("detached", err);
                  } else if (this.state === "attaching") {
                    this.notifyState("suspended", err);
                  } else {
                    this.requestState("attaching", err);
                  }
                  break;
                case actions.SYNC:
                  isSync = true;
                  syncChannelSerial = this.syncChannelSerial = message.channelSerial;
                  if (!message.presence)
                    break;
                case actions.PRESENCE:
                  var presence = message.presence, id = message.id, connectionId = message.connectionId, timestamp = message.timestamp;
                  var options = this.channelOptions;
                  for (var i = 0; i < presence.length; i++) {
                    try {
                      var presenceMsg = presence[i];
                      presencemessage.decode(presenceMsg, options);
                    } catch (e) {
                      util_logger.logAction(util_logger.LOG_ERROR, "RealtimeChannel.onMessage()", e.toString());
                    }
                    if (!presenceMsg.connectionId)
                      presenceMsg.connectionId = connectionId;
                    if (!presenceMsg.timestamp)
                      presenceMsg.timestamp = timestamp;
                    if (!presenceMsg.id)
                      presenceMsg.id = id + ":" + i;
                  }
                  this.presence.setPresence(presence, isSync, syncChannelSerial);
                  break;
                case actions.MESSAGE:
                  if (this.state !== "attached") {
                    util_logger.logAction(util_logger.LOG_MAJOR, "RealtimeChannel.onMessage()", 'Message "' + message.id + '" skipped as this channel "' + this.name + '" state is not "attached" (state is "' + this.state + '").');
                    return;
                  }
                  var messages = message.messages, firstMessage = messages[0], lastMessage = messages[messages.length - 1], id = message.id, connectionId = message.connectionId, timestamp = message.timestamp;
                  if (firstMessage.extras && firstMessage.extras.delta && firstMessage.extras.delta.from !== this._lastPayload.messageId) {
                    var msg = 'Delta message decode failure - previous message not available for message "' + message.id + '" on this channel "' + this.name + '".';
                    util_logger.logAction(util_logger.LOG_ERROR, "RealtimeChannel.onMessage()", msg);
                    this._startDecodeFailureRecovery(new errorinfo(msg, 40018, 400));
                    break;
                  }
                  for (var i = 0; i < messages.length; i++) {
                    var msg = messages[i];
                    try {
                      types_message.decode(msg, this._decodingContext);
                    } catch (e) {
                      util_logger.logAction(util_logger.LOG_ERROR, "RealtimeChannel.onMessage()", e.toString());
                      switch (e.code) {
                        case 40018:
                          this._startDecodeFailureRecovery(e);
                          return;
                        case 40019:
                        case 40021:
                          this.notifyState("failed", e);
                          return;
                      }
                    }
                    if (!msg.connectionId)
                      msg.connectionId = connectionId;
                    if (!msg.timestamp)
                      msg.timestamp = timestamp;
                    if (!msg.id)
                      msg.id = id + ":" + i;
                  }
                  this._lastPayload.messageId = lastMessage.id;
                  this._lastPayload.protocolMessageChannelSerial = message.channelSerial;
                  this.onEvent(messages);
                  break;
                case actions.ERROR:
                  var err = message.error;
                  if (err && err.code == 80016) {
                    this.checkPendingState();
                  } else {
                    this.notifyState("failed", errorinfo.fromValues(err));
                  }
                  break;
                default:
                  util_logger.logAction(util_logger.LOG_ERROR, "RealtimeChannel.onMessage()", "Fatal protocol error: unrecognised action (" + message.action + ")");
                  this.connectionManager.abort(connectionerror.unknownChannelErr);
              }
            };
            RealtimeChannel.prototype._startDecodeFailureRecovery = function(reason) {
              var self2 = this;
              if (!this._lastPayload.decodeFailureRecoveryInProgress) {
                util_logger.logAction(util_logger.LOG_MAJOR, "RealtimeChannel.onMessage()", "Starting decode failure recovery process.");
                this._lastPayload.decodeFailureRecoveryInProgress = true;
                this._attach(true, reason, function() {
                  self2._lastPayload.decodeFailureRecoveryInProgress = false;
                });
              }
            };
            RealtimeChannel.prototype.onAttached = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "RealtimeChannel.onAttached", "activating channel; name = " + this.name);
            };
            RealtimeChannel.prototype.notifyState = function(state, reason, resumed, hasPresence) {
              util_logger.logAction(util_logger.LOG_MICRO, "RealtimeChannel.notifyState", "name = " + this.name + ", current state = " + this.state + ", notifying state " + state);
              this.clearStateTimer();
              if (state === this.state) {
                return;
              }
              this.presence.actOnChannelState(state, hasPresence, reason);
              if (state === "suspended" && this.connectionManager.state.sendEvents) {
                this.startRetryTimer();
              } else {
                this.cancelRetryTimer();
              }
              if (reason) {
                this.errorReason = reason;
              }
              var change = new channelstatechange(this.state, state, resumed, reason);
              var logLevel = state === "failed" ? util_logger.LOG_ERROR : util_logger.LOG_MAJOR;
              util_logger.logAction(logLevel, 'Channel state for channel "' + this.name + '"', state + (reason ? "; reason: " + reason : ""));
              if (state === "attached") {
                this.onAttached();
                this.setInProgress(syncOp, hasPresence);
                this.setInProgress(statechangeOp, false);
              } else if (state === "detached" || state === "failed" || state === "suspended") {
                this.setInProgress(statechangeOp, false);
                this.setInProgress(syncOp, false);
              }
              if (state === "attached") {
                this._attachResume = true;
              } else if (state === "detaching" || state === "failed") {
                this._attachResume = false;
              }
              this.state = state;
              this._allChannelChanges.emit(state, change);
              this.emit(state, change);
            };
            RealtimeChannel.prototype.requestState = function(state, reason) {
              util_logger.logAction(util_logger.LOG_MINOR, "RealtimeChannel.requestState", "name = " + this.name + ", state = " + state);
              this.notifyState(state, reason);
              this.checkPendingState();
            };
            RealtimeChannel.prototype.checkPendingState = function() {
              var cmState = this.connectionManager.state;
              if (!(cmState.sendEvents || cmState.forceQueueEvents)) {
                util_logger.logAction(util_logger.LOG_MINOR, "RealtimeChannel.checkPendingState", "sendEvents is false; state is " + this.connectionManager.state.state);
                return;
              }
              util_logger.logAction(util_logger.LOG_MINOR, "RealtimeChannel.checkPendingState", "name = " + this.name + ", state = " + this.state);
              switch (this.state) {
                case "attaching":
                  this.startStateTimerIfNotRunning();
                  this.attachImpl();
                  break;
                case "detaching":
                  this.startStateTimerIfNotRunning();
                  this.detachImpl();
                  break;
                case "attached":
                  this.sync();
                default:
                  break;
              }
            };
            RealtimeChannel.prototype.timeoutPendingState = function() {
              switch (this.state) {
                case "attaching":
                  var err = new errorinfo("Channel attach timed out", 90007, 408);
                  this.notifyState("suspended", err);
                  break;
                case "detaching":
                  var err = new errorinfo("Channel detach timed out", 90007, 408);
                  this.notifyState("attached", err);
                  break;
                default:
                  this.checkPendingState();
                  break;
              }
            };
            RealtimeChannel.prototype.startStateTimerIfNotRunning = function() {
              var self2 = this;
              if (!this.stateTimer) {
                this.stateTimer = setTimeout(function() {
                  util_logger.logAction(util_logger.LOG_MINOR, "RealtimeChannel.startStateTimerIfNotRunning", "timer expired");
                  self2.stateTimer = null;
                  self2.timeoutPendingState();
                }, this.realtime.options.timeouts.realtimeRequestTimeout);
              }
            };
            RealtimeChannel.prototype.clearStateTimer = function() {
              var stateTimer = this.stateTimer;
              if (stateTimer) {
                clearTimeout(stateTimer);
                this.stateTimer = null;
              }
            };
            RealtimeChannel.prototype.startRetryTimer = function() {
              var self2 = this;
              if (this.retryTimer)
                return;
              this.retryTimer = setTimeout(function() {
                if (self2.state === "suspended" && self2.connectionManager.state.sendEvents) {
                  self2.retryTimer = null;
                  util_logger.logAction(util_logger.LOG_MINOR, "RealtimeChannel retry timer expired", "attempting a new attach");
                  self2.requestState("attaching");
                }
              }, this.realtime.options.timeouts.channelRetryTimeout);
            };
            RealtimeChannel.prototype.cancelRetryTimer = function() {
              if (this.retryTimer) {
                clearTimeout(this.retryTimer);
                this.suspendTimer = null;
              }
            };
            RealtimeChannel.prototype.setInProgress = function(operation, value) {
              this.rest.channels.setInProgress(this, operation, value);
            };
            RealtimeChannel.prototype.history = function(params, callback) {
              util_logger.logAction(util_logger.LOG_MICRO, "RealtimeChannel.history()", "channel = " + this.name);
              if (callback === void 0) {
                if (typeof params == "function") {
                  callback = params;
                  params = null;
                } else {
                  if (this.rest.options.promises) {
                    return utils.promisify(this, "history", arguments);
                  }
                  callback = noop;
                }
              }
              if (params && params.untilAttach) {
                if (this.state !== "attached") {
                  callback(new errorinfo("option untilAttach requires the channel to be attached", 4e4, 400));
                  return;
                }
                if (!this.properties.attachSerial) {
                  callback(new errorinfo("untilAttach was specified and channel is attached, but attachSerial is not defined", 4e4, 400));
                  return;
                }
                delete params.untilAttach;
                params.from_serial = this.properties.attachSerial;
              }
              client_channel.prototype._history.call(this, params, callback);
            };
            RealtimeChannel.prototype.whenState = function(state, listener) {
              return eventemitter.prototype.whenState.call(this, state, this.state, listener);
            };
            RealtimeChannel.prototype.getReleaseErr = function() {
              var s = this.state;
              if (s === "initialized" || s === "detached" || s === "failed") {
                return null;
              }
              return new errorinfo("Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was " + s, 90001, 400);
            };
            return RealtimeChannel;
          }();
          var realtimechannel = realtimechannel_RealtimeChannel;
          var realtime_Realtime = function() {
            function Realtime(options) {
              if (!(this instanceof Realtime)) {
                return new Realtime(options);
              }
              util_logger.logAction(util_logger.LOG_MINOR, "Realtime()", "");
              client_rest.call(this, options);
              this.connection = new client_connection(this, this.options);
              this.channels = new Channels(this);
              if (options.autoConnect !== false)
                this.connect();
            }
            utils.inherits(Realtime, client_rest);
            Realtime.prototype.connect = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "Realtime.connect()", "");
              this.connection.connect();
            };
            Realtime.prototype.close = function() {
              util_logger.logAction(util_logger.LOG_MINOR, "Realtime.close()", "");
              this.connection.close();
            };
            function Channels(realtime) {
              eventemitter.call(this);
              this.realtime = realtime;
              this.all = Object.create(null);
              this.inProgress = Object.create(null);
              var self2 = this;
              realtime.connection.connectionManager.on("transport.active", function() {
                self2.onTransportActive();
              });
            }
            utils.inherits(Channels, eventemitter);
            Channels.prototype.onChannelMessage = function(msg) {
              var channelName = msg.channel;
              if (channelName === void 0) {
                util_logger.logAction(util_logger.LOG_ERROR, "Channels.onChannelMessage()", "received event unspecified channel, action = " + msg.action);
                return;
              }
              var channel = this.all[channelName];
              if (!channel) {
                util_logger.logAction(util_logger.LOG_ERROR, "Channels.onChannelMessage()", "received event for non-existent channel: " + channelName);
                return;
              }
              channel.onMessage(msg);
            };
            Channels.prototype.onTransportActive = function() {
              for (var channelName in this.all) {
                var channel = this.all[channelName];
                if (channel.state === "attaching" || channel.state === "detaching") {
                  channel.checkPendingState();
                } else if (channel.state === "suspended") {
                  channel.attach();
                }
              }
            };
            Channels.prototype.reattach = function(reason) {
              for (var channelId in this.all) {
                var channel = this.all[channelId];
                if (channel.state === "attached") {
                  channel.requestState("attaching", reason);
                }
              }
            };
            Channels.prototype.resetAttachedMsgIndicators = function() {
              for (var channelId in this.all) {
                var channel = this.all[channelId];
                if (channel.state === "attached") {
                  channel._attachedMsgIndicator = false;
                }
              }
            };
            Channels.prototype.checkAttachedMsgIndicators = function(connectionId) {
              for (var channelId in this.all) {
                var channel = this.all[channelId];
                if (channel.state === "attached" && channel._attachedMsgIndicator === false) {
                  var msg = "30s after a resume, found channel which has not received an attached; channelId = " + channelId + "; connectionId = " + connectionId;
                  util_logger.logAction(util_logger.LOG_ERROR, "Channels.checkAttachedMsgIndicators()", msg);
                  errorreporter.report("error", msg, "channel-no-attached-after-resume");
                  channel.requestState("attaching");
                }
                ;
              }
            };
            Channels.prototype.propogateConnectionInterruption = function(connectionState, reason) {
              var connectionStateToChannelState = {
                "closing": "detached",
                "closed": "detached",
                "failed": "failed",
                "suspended": "suspended"
              };
              var fromChannelStates = ["attaching", "attached", "detaching", "suspended"];
              var toChannelState = connectionStateToChannelState[connectionState];
              for (var channelId in this.all) {
                var channel = this.all[channelId];
                if (utils.arrIn(fromChannelStates, channel.state)) {
                  channel.notifyState(toChannelState, reason);
                }
              }
            };
            Channels.prototype.get = function(name, channelOptions) {
              name = String(name);
              var channel = this.all[name];
              if (!channel) {
                channel = this.all[name] = new realtimechannel(this.realtime, name, channelOptions);
              } else if (channelOptions) {
                if (channel._shouldReattachToSetOptions(channelOptions)) {
                  throw new errorinfo("Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.", 4e4, 400);
                }
                channel.setOptions(channelOptions);
              }
              return channel;
            };
            Channels.prototype.release = function(name) {
              name = String(name);
              var channel = this.all[name];
              if (!channel) {
                return;
              }
              var releaseErr = channel.getReleaseErr();
              if (releaseErr) {
                throw releaseErr;
              }
              delete this.all[name];
              delete this.inProgress[name];
            };
            Channels.prototype.setInProgress = function(channel, operation, inProgress) {
              this.inProgress[channel.name] = this.inProgress[channel.name] || {};
              this.inProgress[channel.name][operation] = inProgress;
              if (!inProgress && this.hasNopending()) {
                this.emit("nopending");
              }
            };
            Channels.prototype.onceNopending = function(listener) {
              if (this.hasNopending()) {
                listener();
                return;
              }
              this.once("nopending", listener);
            };
            Channels.prototype.hasNopending = function() {
              return utils.arrEvery(utils.valuesArray(this.inProgress, true), function(operations) {
                return !utils.containsValue(operations, true);
              });
            };
            return Realtime;
          }();
          realtime_Realtime.Promise = function(options) {
            options = util_defaults.objectifyOptions(options);
            options.promises = true;
            return new realtime_Realtime(options);
          };
          realtime_Realtime.Callbacks = realtime_Realtime;
          var client_realtime = realtime_Realtime;
          var msgpack_msgpack = function() {
            "use strict";
            var exports3 = {};
            exports3.inspect = inspect;
            function inspect(buffer) {
              if (buffer === void 0)
                return "undefined";
              var view;
              var type;
              if (buffer instanceof ArrayBuffer) {
                type = "ArrayBuffer";
                view = new DataView(buffer);
              } else if (buffer instanceof DataView) {
                type = "DataView";
                view = buffer;
              }
              if (!view)
                return JSON.stringify(buffer);
              var bytes = [];
              for (var i = 0; i < buffer.byteLength; i++) {
                if (i > 20) {
                  bytes.push("...");
                  break;
                }
                var byte_ = view.getUint8(i).toString(16);
                if (byte_.length === 1)
                  byte_ = "0" + byte_;
                bytes.push(byte_);
              }
              return "<" + type + " " + bytes.join(" ") + ">";
            }
            exports3.utf8Write = utf8Write;
            function utf8Write(view, offset, string) {
              var byteLength = view.byteLength;
              for (var i = 0, l = string.length; i < l; i++) {
                var codePoint = string.charCodeAt(i);
                if (codePoint < 128) {
                  view.setUint8(offset++, codePoint >>> 0 & 127 | 0);
                  continue;
                }
                if (codePoint < 2048) {
                  view.setUint8(offset++, codePoint >>> 6 & 31 | 192);
                  view.setUint8(offset++, codePoint >>> 0 & 63 | 128);
                  continue;
                }
                if (codePoint < 65536) {
                  view.setUint8(offset++, codePoint >>> 12 & 15 | 224);
                  view.setUint8(offset++, codePoint >>> 6 & 63 | 128);
                  view.setUint8(offset++, codePoint >>> 0 & 63 | 128);
                  continue;
                }
                if (codePoint < 1114112) {
                  view.setUint8(offset++, codePoint >>> 18 & 7 | 240);
                  view.setUint8(offset++, codePoint >>> 12 & 63 | 128);
                  view.setUint8(offset++, codePoint >>> 6 & 63 | 128);
                  view.setUint8(offset++, codePoint >>> 0 & 63 | 128);
                  continue;
                }
                throw new Error("bad codepoint " + codePoint);
              }
            }
            exports3.utf8Read = utf8Read;
            function utf8Read(view, offset, length) {
              var string = "";
              for (var i = offset, end = offset + length; i < end; i++) {
                var byte_ = view.getUint8(i);
                if ((byte_ & 128) === 0) {
                  string += String.fromCharCode(byte_);
                  continue;
                }
                if ((byte_ & 224) === 192) {
                  string += String.fromCharCode((byte_ & 15) << 6 | view.getUint8(++i) & 63);
                  continue;
                }
                if ((byte_ & 240) === 224) {
                  string += String.fromCharCode((byte_ & 15) << 12 | (view.getUint8(++i) & 63) << 6 | (view.getUint8(++i) & 63) << 0);
                  continue;
                }
                if ((byte_ & 248) === 240) {
                  string += String.fromCharCode((byte_ & 7) << 18 | (view.getUint8(++i) & 63) << 12 | (view.getUint8(++i) & 63) << 6 | (view.getUint8(++i) & 63) << 0);
                  continue;
                }
                throw new Error("Invalid byte " + byte_.toString(16));
              }
              return string;
            }
            exports3.utf8ByteCount = utf8ByteCount;
            function utf8ByteCount(string) {
              var count = 0;
              for (var i = 0, l = string.length; i < l; i++) {
                var codePoint = string.charCodeAt(i);
                if (codePoint < 128) {
                  count += 1;
                  continue;
                }
                if (codePoint < 2048) {
                  count += 2;
                  continue;
                }
                if (codePoint < 65536) {
                  count += 3;
                  continue;
                }
                if (codePoint < 1114112) {
                  count += 4;
                  continue;
                }
                throw new Error("bad codepoint " + codePoint);
              }
              return count;
            }
            exports3.encode = function(value, sparse) {
              var size = sizeof(value, sparse);
              if (size == 0)
                return void 0;
              var buffer = new ArrayBuffer(size);
              var view = new DataView(buffer);
              encode(value, view, 0, sparse);
              return buffer;
            };
            exports3.decode = decode;
            var SH_L_32 = (1 << 16) * (1 << 16), SH_R_32 = 1 / SH_L_32;
            function getInt64(view, offset) {
              offset = offset || 0;
              return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);
            }
            function getUint64(view, offset) {
              offset = offset || 0;
              return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);
            }
            function setInt64(view, offset, val) {
              if (val < 9223372036854776e3) {
                view.setInt32(offset, Math.floor(val * SH_R_32));
                view.setInt32(offset + 4, val & -1);
              } else {
                view.setUint32(offset, 2147483647);
                view.setUint32(offset + 4, 2147483647);
              }
            }
            function setUint64(view, offset, val) {
              if (val < 18446744073709552e3) {
                view.setUint32(offset, Math.floor(val * SH_R_32));
                view.setInt32(offset + 4, val & -1);
              } else {
                view.setUint32(offset, 4294967295);
                view.setUint32(offset + 4, 4294967295);
              }
            }
            function Decoder(view, offset) {
              this.offset = offset || 0;
              this.view = view;
            }
            Decoder.prototype.map = function(length) {
              var value = {};
              for (var i = 0; i < length; i++) {
                var key = this.parse();
                value[key] = this.parse();
              }
              return value;
            };
            Decoder.prototype.bin = Decoder.prototype.buf = function(length) {
              var value = new ArrayBuffer(length);
              new Uint8Array(value).set(new Uint8Array(this.view.buffer, this.offset, length), 0);
              this.offset += length;
              return value;
            };
            Decoder.prototype.str = function(length) {
              var value = utf8Read(this.view, this.offset, length);
              this.offset += length;
              return value;
            };
            Decoder.prototype.array = function(length) {
              var value = new Array(length);
              for (var i = 0; i < length; i++) {
                value[i] = this.parse();
              }
              return value;
            };
            Decoder.prototype.ext = function(length) {
              var value = {};
              value["type"] = this.view.getInt8(this.offset);
              this.offset++;
              value["data"] = this.buf(length);
              this.offset += length;
              return value;
            };
            Decoder.prototype.parse = function() {
              var type = this.view.getUint8(this.offset);
              var value, length;
              if ((type & 128) === 0) {
                this.offset++;
                return type;
              }
              if ((type & 240) === 128) {
                length = type & 15;
                this.offset++;
                return this.map(length);
              }
              if ((type & 240) === 144) {
                length = type & 15;
                this.offset++;
                return this.array(length);
              }
              if ((type & 224) === 160) {
                length = type & 31;
                this.offset++;
                return this.str(length);
              }
              if ((type & 224) === 224) {
                value = this.view.getInt8(this.offset);
                this.offset++;
                return value;
              }
              switch (type) {
                case 192:
                  this.offset++;
                  return null;
                case 193:
                  this.offset++;
                  return void 0;
                case 194:
                  this.offset++;
                  return false;
                case 195:
                  this.offset++;
                  return true;
                case 196:
                  length = this.view.getUint8(this.offset + 1);
                  this.offset += 2;
                  return this.bin(length);
                case 197:
                  length = this.view.getUint16(this.offset + 1);
                  this.offset += 3;
                  return this.bin(length);
                case 198:
                  length = this.view.getUint32(this.offset + 1);
                  this.offset += 5;
                  return this.bin(length);
                case 199:
                  length = this.view.getUint8(this.offset + 1);
                  this.offset += 2;
                  return this.ext(length);
                case 200:
                  length = this.view.getUint16(this.offset + 1);
                  this.offset += 3;
                  return this.ext(length);
                case 201:
                  length = this.view.getUint32(this.offset + 1);
                  this.offset += 5;
                  return this.ext(length);
                case 202:
                  value = this.view.getFloat32(this.offset + 1);
                  this.offset += 5;
                  return value;
                case 203:
                  value = this.view.getFloat64(this.offset + 1);
                  this.offset += 9;
                  return value;
                case 204:
                  value = this.view.getUint8(this.offset + 1);
                  this.offset += 2;
                  return value;
                case 205:
                  value = this.view.getUint16(this.offset + 1);
                  this.offset += 3;
                  return value;
                case 206:
                  value = this.view.getUint32(this.offset + 1);
                  this.offset += 5;
                  return value;
                case 207:
                  value = getUint64(this.view, this.offset + 1);
                  this.offset += 9;
                  return value;
                case 208:
                  value = this.view.getInt8(this.offset + 1);
                  this.offset += 2;
                  return value;
                case 209:
                  value = this.view.getInt16(this.offset + 1);
                  this.offset += 3;
                  return value;
                case 210:
                  value = this.view.getInt32(this.offset + 1);
                  this.offset += 5;
                  return value;
                case 211:
                  value = getInt64(this.view, this.offset + 1);
                  this.offset += 9;
                  return value;
                case 212:
                  length = 1;
                  this.offset++;
                  return this.ext(length);
                case 213:
                  length = 2;
                  this.offset++;
                  return this.ext(length);
                case 214:
                  length = 4;
                  this.offset++;
                  return this.ext(length);
                case 215:
                  length = 8;
                  this.offset++;
                  return this.ext(length);
                case 216:
                  length = 16;
                  this.offset++;
                  return this.ext(length);
                case 217:
                  length = this.view.getUint8(this.offset + 1);
                  this.offset += 2;
                  return this.str(length);
                case 218:
                  length = this.view.getUint16(this.offset + 1);
                  this.offset += 3;
                  return this.str(length);
                case 219:
                  length = this.view.getUint32(this.offset + 1);
                  this.offset += 5;
                  return this.str(length);
                case 220:
                  length = this.view.getUint16(this.offset + 1);
                  this.offset += 3;
                  return this.array(length);
                case 221:
                  length = this.view.getUint32(this.offset + 1);
                  this.offset += 5;
                  return this.array(length);
                case 222:
                  length = this.view.getUint16(this.offset + 1);
                  this.offset += 3;
                  return this.map(length);
                case 223:
                  length = this.view.getUint32(this.offset + 1);
                  this.offset += 5;
                  return this.map(length);
              }
              throw new Error("Unknown type 0x" + type.toString(16));
            };
            function decode(buffer) {
              var view = new DataView(buffer);
              var decoder = new Decoder(view);
              var value = decoder.parse();
              if (decoder.offset !== buffer.byteLength)
                throw new Error(buffer.byteLength - decoder.offset + " trailing bytes");
              return value;
            }
            function encodeableKeys(value, sparse) {
              var keys = [];
              for (var key in value) {
                if (!value.hasOwnProperty(key))
                  continue;
                keys.push(key);
              }
              return keys.filter(function(e) {
                var val = value[e], type = typeof val;
                return (!sparse || val !== void 0 && val !== null) && (type !== "function" || !!val.toJSON);
              });
            }
            function encode(value, view, offset, sparse) {
              var type = typeof value;
              if (type === "string") {
                var length = utf8ByteCount(value);
                if (length < 32) {
                  view.setUint8(offset, length | 160);
                  utf8Write(view, offset + 1, value);
                  return 1 + length;
                }
                if (length < 256) {
                  view.setUint8(offset, 217);
                  view.setUint8(offset + 1, length);
                  utf8Write(view, offset + 2, value);
                  return 2 + length;
                }
                if (length < 65536) {
                  view.setUint8(offset, 218);
                  view.setUint16(offset + 1, length);
                  utf8Write(view, offset + 3, value);
                  return 3 + length;
                }
                if (length < 4294967296) {
                  view.setUint8(offset, 219);
                  view.setUint32(offset + 1, length);
                  utf8Write(view, offset + 5, value);
                  return 5 + length;
                }
              }
              if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {
                value = value.buffer;
              }
              if (value instanceof ArrayBuffer) {
                var length = value.byteLength;
                if (length < 256) {
                  view.setUint8(offset, 196);
                  view.setUint8(offset + 1, length);
                  new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 2);
                  return 2 + length;
                }
                if (length < 65536) {
                  view.setUint8(offset, 197);
                  view.setUint16(offset + 1, length);
                  new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 3);
                  return 3 + length;
                }
                if (length < 4294967296) {
                  view.setUint8(offset, 198);
                  view.setUint32(offset + 1, length);
                  new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 5);
                  return 5 + length;
                }
              }
              if (type === "number") {
                if (Math.floor(value) !== value) {
                  view.setUint8(offset, 203);
                  view.setFloat64(offset + 1, value);
                  return 9;
                }
                if (value >= 0) {
                  if (value < 128) {
                    view.setUint8(offset, value);
                    return 1;
                  }
                  if (value < 256) {
                    view.setUint8(offset, 204);
                    view.setUint8(offset + 1, value);
                    return 2;
                  }
                  if (value < 65536) {
                    view.setUint8(offset, 205);
                    view.setUint16(offset + 1, value);
                    return 3;
                  }
                  if (value < 4294967296) {
                    view.setUint8(offset, 206);
                    view.setUint32(offset + 1, value);
                    return 5;
                  }
                  if (value < 18446744073709552e3) {
                    view.setUint8(offset, 207);
                    setUint64(view, offset + 1, value);
                    return 9;
                  }
                  throw new Error("Number too big 0x" + value.toString(16));
                }
                if (value >= -32) {
                  view.setInt8(offset, value);
                  return 1;
                }
                if (value >= -128) {
                  view.setUint8(offset, 208);
                  view.setInt8(offset + 1, value);
                  return 2;
                }
                if (value >= -32768) {
                  view.setUint8(offset, 209);
                  view.setInt16(offset + 1, value);
                  return 3;
                }
                if (value >= -2147483648) {
                  view.setUint8(offset, 210);
                  view.setInt32(offset + 1, value);
                  return 5;
                }
                if (value >= -9223372036854776e3) {
                  view.setUint8(offset, 211);
                  setInt64(view, offset + 1, value);
                  return 9;
                }
                throw new Error("Number too small -0x" + (-value).toString(16).substr(1));
              }
              if (type === "undefined") {
                if (sparse)
                  return 0;
                view.setUint8(offset, 212);
                view.setUint8(offset + 1, 0);
                view.setUint8(offset + 2, 0);
                return 3;
              }
              if (value === null) {
                if (sparse)
                  return 0;
                view.setUint8(offset, 192);
                return 1;
              }
              if (type === "boolean") {
                view.setUint8(offset, value ? 195 : 194);
                return 1;
              }
              if (typeof value.toJSON === "function")
                return encode(value.toJSON(), view, offset, sparse);
              if (type === "object") {
                var length, size = 0;
                var isArray = Array.isArray(value);
                if (isArray) {
                  length = value.length;
                } else {
                  var keys = encodeableKeys(value, sparse);
                  length = keys.length;
                }
                var size;
                if (length < 16) {
                  view.setUint8(offset, length | (isArray ? 144 : 128));
                  size = 1;
                } else if (length < 65536) {
                  view.setUint8(offset, isArray ? 220 : 222);
                  view.setUint16(offset + 1, length);
                  size = 3;
                } else if (length < 4294967296) {
                  view.setUint8(offset, isArray ? 221 : 223);
                  view.setUint32(offset + 1, length);
                  size = 5;
                }
                if (isArray) {
                  for (var i = 0; i < length; i++) {
                    size += encode(value[i], view, offset + size, sparse);
                  }
                } else {
                  for (var i = 0; i < length; i++) {
                    var key = keys[i];
                    size += encode(key, view, offset + size);
                    size += encode(value[key], view, offset + size, sparse);
                  }
                }
                return size;
              }
              if (type === "function")
                return 0;
              throw new Error("Unknown type " + type);
            }
            function sizeof(value, sparse) {
              var type = typeof value;
              if (type === "string") {
                var length = utf8ByteCount(value);
                if (length < 32) {
                  return 1 + length;
                }
                if (length < 256) {
                  return 2 + length;
                }
                if (length < 65536) {
                  return 3 + length;
                }
                if (length < 4294967296) {
                  return 5 + length;
                }
              }
              if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {
                value = value.buffer;
              }
              if (value instanceof ArrayBuffer) {
                var length = value.byteLength;
                if (length < 256) {
                  return 2 + length;
                }
                if (length < 65536) {
                  return 3 + length;
                }
                if (length < 4294967296) {
                  return 5 + length;
                }
              }
              if (type === "number") {
                if (Math.floor(value) !== value)
                  return 9;
                if (value >= 0) {
                  if (value < 128)
                    return 1;
                  if (value < 256)
                    return 2;
                  if (value < 65536)
                    return 3;
                  if (value < 4294967296)
                    return 5;
                  if (value < 18446744073709552e3)
                    return 9;
                  throw new Error("Number too big 0x" + value.toString(16));
                }
                if (value >= -32)
                  return 1;
                if (value >= -128)
                  return 2;
                if (value >= -32768)
                  return 3;
                if (value >= -2147483648)
                  return 5;
                if (value >= -9223372036854776e3)
                  return 9;
                throw new Error("Number too small -0x" + value.toString(16).substr(1));
              }
              if (type === "boolean")
                return 1;
              if (value === null)
                return sparse ? 0 : 1;
              if (value === void 0)
                return sparse ? 0 : 3;
              if (typeof value.toJSON === "function")
                return sizeof(value.toJSON(), sparse);
              if (type === "object") {
                var length, size = 0;
                if (Array.isArray(value)) {
                  length = value.length;
                  for (var i = 0; i < length; i++) {
                    size += sizeof(value[i], sparse);
                  }
                } else {
                  var keys = encodeableKeys(value, sparse);
                  length = keys.length;
                  for (var i = 0; i < length; i++) {
                    var key = keys[i];
                    size += sizeof(key) + sizeof(value[key], sparse);
                  }
                }
                if (length < 16) {
                  return 1 + size;
                }
                if (length < 65536) {
                  return 3 + size;
                }
                if (length < 4294967296) {
                  return 5 + size;
                }
                throw new Error("Array or object too long 0x" + length.toString(16));
              }
              if (type === "function")
                return 0;
              throw new Error("Unknown type " + type);
            }
            return exports3;
          }();
          var util_msgpack = msgpack_msgpack;
          client_rest.Utils = utils;
          client_rest.BufferUtils = bufferutils;
          client_rest.Crypto = util_crypto;
          client_rest.Defaults = util_defaults;
          client_rest.Http = util_http;
          client_rest.Resource = client_resource;
          client_rest.Message = types_message;
          client_rest.PresenceMessage = presencemessage;
          client_realtime.Utils = utils;
          client_realtime.BufferUtils = bufferutils;
          client_realtime.Crypto = util_crypto;
          client_realtime.Defaults = util_defaults;
          client_realtime.Http = util_http;
          client_realtime.Message = types_message;
          client_realtime.PresenceMessage = presencemessage;
          client_realtime.ProtocolMessage = protocolmessage;
          client_realtime.ConnectionManager = connectionmanager;
          var lib = __webpack_exports__["default"] = {
            Rest: client_rest,
            Realtime: client_realtime,
            msgpack: util_msgpack
          };
        }
      ])["default"];
    });
  }
});

// .netlify/server/entries/pages/index.svelte.js
var require_index_svelte = __commonJS({
  ".netlify/server/entries/pages/index.svelte.js"(exports2) {
    var __create = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __reExport = (target, module22, desc) => {
      if (module22 && typeof module22 === "object" || typeof module22 === "function") {
        for (let key of __getOwnPropNames(module22))
          if (!__hasOwnProp2.call(target, key) && key !== "default")
            __defProp2(target, key, { get: () => module22[key], enumerable: !(desc = __getOwnPropDesc(module22, key)) || desc.enumerable });
      }
      return target;
    };
    var __toModule = (module22) => {
      return __reExport(__markAsModule(__defProp2(module22 != null ? __create(__getProtoOf(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? { get: () => module22.default, enumerable: true } : { value: module22, enumerable: true })), module22);
    };
    __export(exports2, {
      default: () => Routes,
      load: () => load
    });
    var import_index_08869495 = __toModule(require_index_08869495());
    var import_load_user_data_ba355a80 = __toModule(require_load_user_data_ba355a80());
    var Ably = __toModule(require_ably_node());
    var browser = false;
    var subscriber_queue = [];
    function writable(value, start = import_index_08869495.n) {
      let stop;
      const subscribers = new Set();
      function set(new_value) {
        if ((0, import_index_08869495.a)(value, new_value)) {
          value = new_value;
          if (stop) {
            const run_queue = !subscriber_queue.length;
            for (const subscriber of subscribers) {
              subscriber[1]();
              subscriber_queue.push(subscriber, value);
            }
            if (run_queue) {
              for (let i = 0; i < subscriber_queue.length; i += 2) {
                subscriber_queue[i][0](subscriber_queue[i + 1]);
              }
              subscriber_queue.length = 0;
            }
          }
        }
      }
      function update(fn) {
        set(fn(value));
      }
      function subscribe2(run, invalidate = import_index_08869495.n) {
        const subscriber = [run, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
          stop = start(set) || import_index_08869495.n;
        }
        run(value);
        return () => {
          subscribers.delete(subscriber);
          if (subscribers.size === 0) {
            stop();
            stop = null;
          }
        };
      }
      return { set, update, subscribe: subscribe2 };
    }
    async function load({ session }) {
      return (0, import_load_user_data_ba355a80.l)(session, "/index.svelte");
    }
    var Routes = (0, import_index_08869495.c)(($$result, $$props, $$bindings, slots) => {
      let $remote_id, $$unsubscribe_remote_id;
      const remote_id = writable("");
      $$unsubscribe_remote_id = (0, import_index_08869495.b)(remote_id, (value) => $remote_id = value);
      var local_id;
      var local_video_element;
      var remote_video_element;
      let { user } = $$props;
      let { ably_token } = $$props;
      var ably;
      if ($$props.remote_id === void 0 && $$bindings.remote_id && remote_id !== void 0)
        $$bindings.remote_id(remote_id);
      if ($$props.user === void 0 && $$bindings.user && user !== void 0)
        $$bindings.user(user);
      if ($$props.ably_token === void 0 && $$bindings.ably_token && ably_token !== void 0)
        $$bindings.ably_token(ably_token);
      {
        {
          if (ably_token && browser) {
            console.log("can listen to ably channel now!");
            let clientOptions = {
              token: ably_token,
              authUrl: `${window.location.origin}/ably_auth`,
              ttl: 36e5
            };
            ably = new Ably.Realtime.Promise(clientOptions);
            ably.connection.on("connected", function() {
              console.log("Connected to Ably");
            });
            ably.connection.on("failed", function(err) {
              console.log("Failed to connect to Ably", err);
            });
            ably.connection.on("disconnected", function() {
              console.log("Disconnected from Ably");
            });
            ably.connection.on("suspended", function() {
              console.log("Suspended from Ably");
            });
            ably.connection.on("closed", function() {
              console.log("Closed from Ably");
            });
            ably.channels.get("user_list").subscribe(function(msg) {
              console.log("Received message: " + msg);
            });
          }
        }
      }
      $$unsubscribe_remote_id();
      return `${!user ? `<section class="${"hero is-small is-info"}"><div class="${"hero-body"}"><p class="${"title"}">Welcome!</p>
			<p class="${"subtitle"}">This is an audio/video chatting site to help you find kindred spirits.</p></div></section>
	<section class="${"section"}"><h1 class="${"title"}">How&#39;s it work?</h1>

		<div class="${"columns is-desktop"}"><div class="${"column"}"><article class="${"message is-info"}"><div class="${"message-header"}"><p>1. Sign up <span class="${"icon"}"><i class="${"fas fa-user-plus"}"></i></span></p></div>
					<div class="${"message-body"}">You can signup using your pre-existing accounts on:<br>
						<div class="${"content p-2 m-2"}"><div class="${"tags"}"><span class="${"tag is-dark"}">Github <span class="${"icon"}"><i class="${"fab fa-github"}"></i></span></span>
								<span class="${"tag is-dark"}">Linkedin <span class="${"icon"}"><i class="${"fab fa-linkedin"}"></i></span></span>
								<span class="${"tag is-dark"}">Discord <span class="${"icon"}"><i class="${"fab fa-discord"}"></i></span></span>
								<span class="${"tag is-dark"}">Google <span class="${"icon"}"><i class="${"fab fa-google"}"></i></span></span></div></div>
						Alternatively, you can sign up using a standard email<span class="${"icon"}"><i class="${"fas fa-envelope"}"></i></span>
						and password <span class="${"icon"}"><i class="${"fas fa-key"}"></i></span>.
					</div></article></div>
			<div class="${"column"}"><article class="${"message is-success"}"><div class="${"message-header"}"><p>2. Interact <span class="${"icon"}"><i class="${"fas fa-comments"}"></i></span></p></div>
					<div class="${"message-body"}">We use learning algorithms to match you with the most suitable available user. Based on
						your interaction, you can either <strong>like</strong> or <strong>dislike</strong> the user.
						These ratings will inform the algorithm to match you in the future.
					</div></article></div>
			<div class="${"column"}"><article class="${"message is-warning"}"><div class="${"message-header"}"><p>3. Bad interactions <span class="${"icon"}"><i class="${"fas fa-exclamation-triangle"}"></i></span></p></div>
					<div class="${"message-body"}">If you encounter a bad interaction, you can report it. This is not like other reporting
						processes.

						<strong>Reporting an interaction will kick off a remediation process. </strong>
						<br>
						<br>
						This process consists of the following steps:
						<br>
						<div class="${"content"}"><ol><li>Both members will be notified of the bad interaction. Both accounts are
									temporarily blocked from interacting with others until they either resolve the
									issue or agree to the remediation process.
								</li>
								<li>The video of the interaction will be reviewed by 3 community members and see if
									the interaction conforms to the rules of the server at the time of interaction.
								</li>
								<li>If the reported bad interaction does not conform to the global and server rules, a
									redemption will be required by the offender to resolve the issue. Each server must
									define its own redemption process.
								</li></ol></div></div></article></div></div></section>` : ``}

${user ? `<section class="${"hero is-small is-success"}"><div class="${"hero-body"}"><p class="${"title"}">Welcome back!</p></div></section>
	${``}

	<section class="${"section"}"><div class="${"columns"}"><div class="${"column"}"><div class="${"box"}"><div class="${"content"}"><p class="${"title"}">Your Video</p>

						<video class="${"column is-full is-dark"}"${(0, import_index_08869495.d)("this", local_video_element, 0)}><track kind="${"captions"}"></video>
						<div class="${"field"}"><div class="${"control"}"><label class="${"label"}">Peer id
									<input class="${"input"}" type="${"text"}"${(0, import_index_08869495.d)("value", local_id, 0)} readonly></label></div>

							<small>(Send this peer id to your chatting partner. It is your identifier.)</small></div></div></div></div>
			<div class="${"column"}"><div class="${"box"}"><div class="${"content"}"><p class="${"title"}">Remote Video</p>

						<video class="${"column is-full is-dark"}"${(0, import_index_08869495.d)("this", remote_video_element, 0)}><track kind="${"captions"}"></video>
						<div class="${"field"}"><div class="${"control"}"><label class="${"label"}">Remote ID
									<input class="${"input"}" type="${"text"}"${(0, import_index_08869495.d)("value", $remote_id, 0)} readonly></label></div></div></div></div></div></div></section>
	<section class="${"section"}"><div class="${"card"}"><div class="${"card-content"}"><div class="${"content"}">
					<div class="${"field"}"><div class="${"control"}"><label class="${"label"}">Call Remote ID
								<input class="${"input"}" type="${"text"}" placeholder="${"Remote ID"}"${(0, import_index_08869495.d)("value", $remote_id, 0)}></label></div></div></div></div></div></section>` : ``}`;
    });
  }
});

// .netlify/server/nodes/2.js
var require__3 = __commonJS({
  ".netlify/server/nodes/2.js"(exports2) {
    var __create = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __reExport = (target, module32, desc) => {
      if (module32 && typeof module32 === "object" || typeof module32 === "function") {
        for (let key of __getOwnPropNames(module32))
          if (!__hasOwnProp2.call(target, key) && key !== "default")
            __defProp2(target, key, { get: () => module32[key], enumerable: !(desc = __getOwnPropDesc(module32, key)) || desc.enumerable });
      }
      return target;
    };
    var __toModule = (module32) => {
      return __reExport(__markAsModule(__defProp2(module32 != null ? __create(__getProtoOf(module32)) : {}, "default", module32 && module32.__esModule && "default" in module32 ? { get: () => module32.default, enumerable: true } : { value: module32, enumerable: true })), module32);
    };
    __export(exports2, {
      css: () => css,
      entry: () => entry,
      js: () => js,
      module: () => module2
    });
    var module2 = __toModule(require_index_svelte());
    var entry = "pages/index.svelte-737b6076.js";
    var js = ["pages/index.svelte-737b6076.js", "chunks/preload-helper-ec9aa979.js", "chunks/vendor-1860a60a.js", "chunks/load_user_data-ba355a80.js"];
    var css = [];
  }
});

// .netlify/server/entries/pages/account.svelte.js
var require_account_svelte = __commonJS({
  ".netlify/server/entries/pages/account.svelte.js"(exports2) {
    var __create = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __reExport = (target, module22, desc) => {
      if (module22 && typeof module22 === "object" || typeof module22 === "function") {
        for (let key of __getOwnPropNames(module22))
          if (!__hasOwnProp2.call(target, key) && key !== "default")
            __defProp2(target, key, { get: () => module22[key], enumerable: !(desc = __getOwnPropDesc(module22, key)) || desc.enumerable });
      }
      return target;
    };
    var __toModule = (module22) => {
      return __reExport(__markAsModule(__defProp2(module22 != null ? __create(__getProtoOf(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? { get: () => module22.default, enumerable: true } : { value: module22, enumerable: true })), module22);
    };
    __export(exports2, {
      default: () => Account,
      load: () => load
    });
    var import_index_08869495 = __toModule(require_index_08869495());
    var import_load_user_data_ba355a80 = __toModule(require_load_user_data_ba355a80());
    var User_card = (0, import_index_08869495.c)(($$result, $$props, $$bindings, slots) => {
      let { user } = $$props;
      if ($$props.user === void 0 && $$bindings.user && user !== void 0)
        $$bindings.user(user);
      return `<div class="${"card"}"><div class="${"card-content"}"><div class="${"media"}"><div class="${"media-left"}"><figure class="${"image is-48x48"}"><img${(0, import_index_08869495.d)("src", user.picture, 0)} alt="${"This User's Avatar"}"></figure></div>
        <div class="${"media-content"}"><p class="${"title is-4"}">${(0, import_index_08869495.e)(user.name || user.email)}</p>
          <p class="${"subtitle is-6"}">@${(0, import_index_08869495.e)(user.nickname || user.name)}</p></div></div></div></div>`;
    });
    async function load({ session }) {
      return (0, import_load_user_data_ba355a80.l)(session, "/account.svelte");
    }
    var Account = (0, import_index_08869495.c)(($$result, $$props, $$bindings, slots) => {
      let { user } = $$props;
      if ($$props.user === void 0 && $$bindings.user && user !== void 0)
        $$bindings.user(user);
      return `${user ? `<section class="${"hero is-small is-warning"}"><div class="${"hero-body"}"><p class="${"title"}">Account Info:</p>
			${(0, import_index_08869495.v)(User_card, "UserCard").$$render($$result, { user }, {}, {})}</div></section>` : ``}
`;
    });
  }
});

// .netlify/server/nodes/3.js
var require__4 = __commonJS({
  ".netlify/server/nodes/3.js"(exports2) {
    var __create = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __reExport = (target, module32, desc) => {
      if (module32 && typeof module32 === "object" || typeof module32 === "function") {
        for (let key of __getOwnPropNames(module32))
          if (!__hasOwnProp2.call(target, key) && key !== "default")
            __defProp2(target, key, { get: () => module32[key], enumerable: !(desc = __getOwnPropDesc(module32, key)) || desc.enumerable });
      }
      return target;
    };
    var __toModule = (module32) => {
      return __reExport(__markAsModule(__defProp2(module32 != null ? __create(__getProtoOf(module32)) : {}, "default", module32 && module32.__esModule && "default" in module32 ? { get: () => module32.default, enumerable: true } : { value: module32, enumerable: true })), module32);
    };
    __export(exports2, {
      css: () => css,
      entry: () => entry,
      js: () => js,
      module: () => module2
    });
    var module2 = __toModule(require_account_svelte());
    var entry = "pages/account.svelte-79370477.js";
    var js = ["pages/account.svelte-79370477.js", "chunks/vendor-1860a60a.js", "chunks/load_user_data-ba355a80.js"];
    var css = [];
  }
});

// .netlify/server/entries/endpoints/ably_auth.js
var require_ably_auth = __commonJS({
  ".netlify/server/entries/endpoints/ably_auth.js"(exports2) {
    var __create = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __reExport = (target, module22, desc) => {
      if (module22 && typeof module22 === "object" || typeof module22 === "function") {
        for (let key of __getOwnPropNames(module22))
          if (!__hasOwnProp2.call(target, key) && key !== "default")
            __defProp2(target, key, { get: () => module22[key], enumerable: !(desc = __getOwnPropDesc(module22, key)) || desc.enumerable });
      }
      return target;
    };
    var __toModule = (module22) => {
      return __reExport(__markAsModule(__defProp2(module22 != null ? __create(__getProtoOf(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? { get: () => module22.default, enumerable: true } : { value: module22, enumerable: true })), module22);
    };
    __export(exports2, {
      get: () => get
    });
    var Ably = __toModule(require_ably_node());
    process.env["ABLY_ADMIN_KEY"];
    var ably_subscribe_key = process.env["ABLY_SUBSCRIBE_KEY"];
    async function get({ url, params, locals }) {
      console.log("params", params);
      console.log("url", url);
      console.log("locals", locals);
      let my_url = new URL(url);
      let rnd = my_url.searchParams.get("rnd");
      let ably = new Ably.Rest.Promise(ably_subscribe_key);
      let tokenParams = {
        rnd,
        ttl: 36e5
      };
      let token = await ably.auth.createTokenRequest(tokenParams);
      console.log("ASDFtoken", token);
      locals.ably_token = token;
      return {
        body: token,
        status: 200,
        headers: {
          "Content-Type": "application/json"
        }
      };
    }
  }
});

// .netlify/server/entries/endpoints/callback.js
var require_callback = __commonJS({
  ".netlify/server/entries/endpoints/callback.js"(exports2) {
    var __create = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __reExport = (target, module22, desc) => {
      if (module22 && typeof module22 === "object" || typeof module22 === "function") {
        for (let key of __getOwnPropNames(module22))
          if (!__hasOwnProp2.call(target, key) && key !== "default")
            __defProp2(target, key, { get: () => module22[key], enumerable: !(desc = __getOwnPropDesc(module22, key)) || desc.enumerable });
      }
      return target;
    };
    var __toModule = (module22) => {
      return __reExport(__markAsModule(__defProp2(module22 != null ? __create(__getProtoOf(module22)) : {}, "default", module22 && module22.__esModule && "default" in module22 ? { get: () => module22.default, enumerable: true } : { value: module22, enumerable: true })), module22);
    };
    __export(exports2, {
      get: () => get
    });
    var Ably = __toModule(require_ably_node());
    var baseURL = process.env["AUTH0_BASE_URL"];
    var client_id = process.env["CLIENT_ID"];
    var client_secret = process.env["CLIENT_SECRET"];
    process.env["ABLY_ADMIN_KEY"];
    var ably_subscribe_key = process.env["ABLY_SUBSCRIBE_KEY"];
    async function get({ url, locals }) {
      let my_url = new URL(url);
      let code = my_url.searchParams.get("code");
      let redirect_uri = url.origin.replace(/\/login$/, "");
      let response = await getToken(code, redirect_uri);
      let json = await response.json();
      let access_token = json.access_token;
      let user = await getUser(access_token);
      let user_json = await user.json();
      locals.user = user_json;
      let token = await get_ably_user_using_api_key(user_json.email, url.origin);
      locals.ably_token = token;
      let able_add_channel_url = "https://make_ably_channel.robert-admin.workers.dev/?user_identifier=" + user_json.email;
      let ably_channel_add_response = await fetch(able_add_channel_url, {
        method: "GET"
      });
      locals.ably_channel_add_response = await ably_channel_add_response.json();
      console.log("In the callback endpoint: " + JSON.stringify(locals, null, 2));
      return {
        status: 301,
        headers: {
          location: "/"
        }
      };
    }
    async function get_ably_user_using_api_key(email, origin) {
      const ably = new Ably.Realtime.Promise({ key: ably_subscribe_key });
      var tokenParams = {
        ttl: 36e5,
        clientId: email,
        authUrl: `${origin}/ably_auth`
      };
      return await ably.auth.authorize(tokenParams);
    }
    async function getToken(code, redirect_uri) {
      let grant_type = "authorization_code";
      let tokenURL = `${baseURL}/oauth/token`;
      return await fetch(tokenURL, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: `grant_type=${grant_type}&client_id=${client_id}&client_secret=${client_secret}&code=${code}&redirect_uri=${redirect_uri}`
      });
    }
    async function getUser(access_token) {
      let userURL = `${baseURL}/userinfo`;
      return await fetch(userURL, {
        headers: {
          Authorization: `Bearer ${access_token}`
        }
      });
    }
  }
});

// .netlify/server/entries/endpoints/logout.js
var require_logout = __commonJS({
  ".netlify/server/entries/endpoints/logout.js"(exports2) {
    var __defProp2 = Object.defineProperty;
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    __export(exports2, {
      get: () => get
    });
    function get({ url, headers }) {
      console.log("Logout Endpoint: " + JSON.stringify(url, null, 2));
      return {
        status: 301,
        headers: {
          location: "/"
        }
      };
    }
  }
});

// .netlify/server/entries/endpoints/login.js
var require_login = __commonJS({
  ".netlify/server/entries/endpoints/login.js"(exports2) {
    var __defProp2 = Object.defineProperty;
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    __export(exports2, {
      get: () => get
    });
    var client_id = process.env["CLIENT_ID"];
    var baseURL = process.env["AUTH0_BASE_URL"];
    async function get({ url, headers }) {
      let my_url = new URL(url);
      let params = my_url.searchParams.get("screen_hint");
      console.log("login params: " + JSON.stringify(params, null, 2));
      let redirect_uri = url.origin.replace(/\/login$/, "") + "/callback/";
      let response_type = "code";
      let scope = "openid profile email";
      let screen_hint = params == "signup" ? "signup" : "login";
      return {
        status: 301,
        headers: {
          location: `${baseURL}/authorize?response_type=${response_type}&client_id=${client_id}&redirect_uri=${redirect_uri}&scope=${scope}&screen_hint=${screen_hint}`
        }
      };
    }
  }
});

// .netlify/functions-internal/render.js
var { init } = require_handler();
exports.handler = init({
  appDir: "_app",
  assets: new Set(["favicon.png"]),
  _: {
    mime: { ".png": "image/png" },
    entry: { "file": "start-e6529f45.js", "js": ["start-e6529f45.js", "chunks/vendor-1860a60a.js", "chunks/preload-helper-ec9aa979.js", "chunks/singletons-a42a5e91.js"], "css": ["assets/start-61d1577b.css"] },
    nodes: [
      () => Promise.resolve().then(() => require__()),
      () => Promise.resolve().then(() => require__2()),
      () => Promise.resolve().then(() => require__3()),
      () => Promise.resolve().then(() => require__4())
    ],
    routes: [
      {
        type: "page",
        pattern: /^\/$/,
        params: null,
        path: "/",
        a: [0, 2],
        b: [1]
      },
      {
        type: "endpoint",
        pattern: /^\/ably_auth\/?$/,
        params: null,
        load: () => Promise.resolve().then(() => require_ably_auth())
      },
      {
        type: "endpoint",
        pattern: /^\/callback\/?$/,
        params: null,
        load: () => Promise.resolve().then(() => require_callback())
      },
      {
        type: "page",
        pattern: /^\/account\/?$/,
        params: null,
        path: "/account",
        a: [0, 3],
        b: [1]
      },
      {
        type: "endpoint",
        pattern: /^\/logout\/?$/,
        params: null,
        load: () => Promise.resolve().then(() => require_logout())
      },
      {
        type: "endpoint",
        pattern: /^\/login\/?$/,
        params: null,
        load: () => Promise.resolve().then(() => require_login())
      }
    ]
  }
});
/*!
 * @license Copyright 2021, Ably
 * 
 * Ably JavaScript Library v1.2.17
 * https://github.com/ably/ably-js
 * 
 * Ably Realtime Messaging
 * https://www.ably.com
 * 
 * Released under the Apache Licence v2.0
 */
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
//# sourceMappingURL=render.js.map
